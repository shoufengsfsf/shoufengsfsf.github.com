<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"shoufengsfsf.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="shoufengsfsf.github.io">
<meta property="og:url" content="https://shoufengsfsf.github.io/index.html">
<meta property="og:site_name" content="shoufengsfsf.github.io">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="shoufeng">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://shoufengsfsf.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>shoufengsfsf.github.io</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">shoufengsfsf.github.io</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shoufengsfsf.github.io/2020/06/24/mybatis%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shoufeng">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shoufengsfsf.github.io">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/24/mybatis%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">mybatis问题总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-24 10:45:10" itemprop="dateCreated datePublished" datetime="2020-06-24T10:45:10+08:00">2020-06-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shoufengsfsf.github.io/2020/06/23/mybatis%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shoufeng">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shoufengsfsf.github.io">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/23/mybatis%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" class="post-title-link" itemprop="url">mybatis源码解读</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-23 23:17:58" itemprop="dateCreated datePublished" datetime="2020-06-23T23:17:58+08:00">2020-06-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-24 10:38:21" itemprop="dateModified" datetime="2020-06-24T10:38:21+08:00">2020-06-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mybatis%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">mybatis源码解读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MyBatis源码解读"><a href="#MyBatis源码解读" class="headerlink" title="MyBatis源码解读"></a>MyBatis源码解读</h1><h2 id="带着问题去看源码"><a href="#带着问题去看源码" class="headerlink" title="带着问题去看源码"></a>带着问题去看源码</h2><p>分析源码，我们还是从编程式的 demo 入手。Spring 的集成我们会在后面讲到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream); </span><br><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">BlogMapper mapper = session.getMapper(BlogMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Blog blog = mapper.selectBlogById(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>把文件读取成流的这一步我们就省略了。所以下面我们分成四步来分析。</p>
<p>第一步，我们通过建造者模式创建一个工厂类，配置文件的解析就是在这一步完成 的，包括 mybatis-config.xml 和 Mapper 适配器文件。</p>
<p>问题:解析的时候怎么解析的，做了什么，产生了什么对象，结果存放到了哪里。 解析的结果决定着我们后面有什么对象可以使用，和到哪里去取。</p>
<p>第二步，通过 SqlSessionFactory 创建一个 SqlSession。</p>
<p>问题:SqlSession 是用来操作数据库的，返回了什么实现类，除了 SqlSession，还 创建了什么对象，创建了什么环境?</p>
<p>第三步，获得一个 Mapper 对象。</p>
<p>问题:Mapper 是一个接口，没有实现类，是不能被实例化的，那获取到的这个 Mapper 对象是什么对象?为什么要从 SqlSession 里面去获取?为什么传进去一个接 口，然后还要用接口类型来接收?</p>
<p>第四步，调用接口方法。</p>
<p>问题:我们的接口没有创建实现类，为什么可以调用它的方法?那它调用的是什么 方法?它又是根据什么找到我们要执行的 SQL 的?也就是接口方法怎么和 XML 映射器 里面的 StatementID 关联起来的?</p>
<p>此外，我们的方法参数是怎么转换成 SQL 参数的?获取到的结果集是怎么转换成对 象的?</p>
<p>接下来我们就会详细分析每一步的流程，包括里面有哪些核心的对象和关键的方法。</p>
<h2 id="一、配置解析过程"><a href="#一、配置解析过程" class="headerlink" title="一、配置解析过程"></a>一、配置解析过程</h2><p>首先我们要清楚的是配置解析的过程全部只解析了两种文件。一个是 mybatis-config.xml 全局配置文件。另外就是可能有很多个的 Mapper.xml 文件，也包 括在 Mapper 接口类上面定义的注解。</p>
<p>我们从 mybatis-config.xml 开始。在第一节课的时候我们已经分析了核心配置了， 大概明白了 MyBatis 有哪些配置项，和这些配置项的大致含义。这里我们再具体看一下 这里面的标签都是怎么解析的，解析的时候做了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure>

<p>首先我们 new 了一个 SqlSessionFactoryBuilder，非常明显的建造者模式，它里面 定义了很多个 build 方法的重载，最终返回的是一个 SqlSessionFactory 对象(单例模 式)。我们点进去 build 方法。</p>
<p>这里面创建了一个 XMLConfigBuilder 对象(Configuration 对象也是这个时候创 建的)。</p>
<h3 id="XMLConfigBuilder"><a href="#XMLConfigBuilder" class="headerlink" title="XMLConfigBuilder"></a>XMLConfigBuilder</h3><p>XMLConfigBuilder 是抽象类 BaseBuilder 的一个子类，专门用来解析全局配置文 件，针对不同的构建目标还有其他的一些子类，比如:</p>
<p>XMLMapperBuilder:解析 Mapper 映射器 </p>
<p>XMLStatementBuilder:解析增删改查标签</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg2mz0ztjcj31oi06k7ac.jpg" alt="image-20200623232353388"></p>
<p>根据我们解析的文件流，这里后面两个参数都是空的，创建了一个 parser。</p>
<p>这里有两步，第一步是调用 parser 的 parse()方法，它会返回一个 Configuration 类。</p>
<p>之前我们说过，也就是配置文件里面所有的信息都会放在 Configuration 里面。 Configuration 类里面有很多的属性，有很多是跟 config 里面的标签直接对应的。</p>
<p>我们先看一下 parse()方法:</p>
<p>首先会检查是不是已经解析过，也就是说在应用的生命周期里面，config 配置文件</p>
<p>只需要解析一次，生成的 Configuration 对象也会存在应用的整个生命周期中。接下来就是 parseConfiguration 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseConfiguration(parser.evalNode(<span class="string">"/configuration"</span>));</span><br></pre></td></tr></table></figure>

<p>这下面有十几个方法，对应着 config 文件里面的所有一级标签。</p>
<p>问题:MyBatis 全局配置文件的顺序可以颠倒吗?</p>
<h3 id="propertiesElement"><a href="#propertiesElement" class="headerlink" title="propertiesElement()"></a>propertiesElement()</h3><p>第一个是解析&lt;properties&gt;标签，读取我们引入的外部配置文件。这里面又有两种 类型，一种是放在 resource 目录下的，是相对路径，一种是写的绝对路径的。解析的最 终结果就是我们会把所有的配置信息放到名为 defaults 的 Properties 对象里面，最后把 XPathParser 和 Configuration 的 Properties 属性都设置成我们填充后的 Properties 对象。</p>
<h3 id="settingsAsProperties"><a href="#settingsAsProperties" class="headerlink" title="settingsAsProperties()"></a>settingsAsProperties()</h3><p>第二个，我们把&lt;settings&gt;标签也解析成了一个 Properties 对象，对于&lt;settings&gt; 标签的子标签的处理在后面。</p>
<p>在早期的版本里面解析和设置都是在后面一起的，这里先解析成 Properties 对象是 因为下面的两个方法要用到。</p>
<h3 id="loadCustomVfs-settings"><a href="#loadCustomVfs-settings" class="headerlink" title="loadCustomVfs(settings)"></a>loadCustomVfs(settings)</h3><p>loadCustomVfs 是获取 Vitual File System 的自定义实现类，比如我们要读取本地 文件，或者 FTP 远程文件的时候，就可以用到自定义的 VFS 类。我们根据&lt;settings&gt;标 签里面的&lt;vfsImpl&gt;标签，生成了一个抽象类 VFS 的子类，并且赋值到 Configuration 中。</p>
<h3 id="loadCustomLogImpl-settings"><a href="#loadCustomLogImpl-settings" class="headerlink" title="loadCustomLogImpl(settings)"></a>loadCustomLogImpl(settings)</h3><p>loadCustomLogImpl 是根据&lt;logImpl&gt;标签获取日志的实现类，我们可以用到很 多的日志的方案，包括 LOG4J，LOG4J2，SLF4J 等等。这里生成了一个 Log 接口的实 现类，并且赋值到 Configuration 中。</p>
<h3 id="typeAliasesElement"><a href="#typeAliasesElement" class="headerlink" title="typeAliasesElement()"></a>typeAliasesElement()</h3><p>接下来，我们解析&lt;typeAliases&gt;标签，我们在讲配置的时候也讲过，它有两种定义 方式，一种是直接定义一个类的别名，一种就是指定一个包，那么这个 package 下面所 有的类的名字就会成为这个类全路径的别名。</p>
<p>类的别名和类的关系，我们放在一个 TypeAliasRegistry 对象里面。</p>
<h3 id="pluginElement"><a href="#pluginElement" class="headerlink" title="pluginElement()"></a>pluginElement()</h3><p>接下来就是解析&lt;plugins&gt;标签，比如 Pagehelper 的翻页插件，或者我们自定义的 插件。&lt;plugins&gt;标签里面只有&lt;plugin&gt;标签，&lt;plugin&gt;标签里面只有&lt;property&gt;标 签。</p>
<p>标签解析完以后，会生成一个 Interceptor 对象，并且添加到 Configuration 的 InterceptorChain 属性里面，它是一个 List。</p>
<h3 id="objectFactoryElement-、objectWrapperFactoryElement"><a href="#objectFactoryElement-、objectWrapperFactoryElement" class="headerlink" title="objectFactoryElement()、objectWrapperFactoryElement()"></a>objectFactoryElement()、objectWrapperFactoryElement()</h3><p>接 下 来 的 两 个 标 签 是 用 来 实 例 化 对 象 用 的 ， &lt;objectFactory&gt; 和 &lt;objectWrapperFactory&gt; 这 两 个 标 签 ， 分 别 生 成 ObjectFactory 、 ObjectWrapperFactory 对象，同样设置到 Configuration 的属性里面。</p>
<h3 id="reflectorFactoryElement"><a href="#reflectorFactoryElement" class="headerlink" title="reflectorFactoryElement()"></a>reflectorFactoryElement()</h3><p>解析 reflectorFactory 标签，生成 ReflectorFactory 对象(在官方 3.5.1 的 pdf 文 档里面没有找到这个配置)。</p>
<h3 id="settingsElement-settings"><a href="#settingsElement-settings" class="headerlink" title="settingsElement(settings)"></a>settingsElement(settings)</h3><p>这里就是对&lt;settings&gt;标签里面所有子标签的处理了，前面我们已经把子标签全部 转换成了 Properties 对象，所以在这里处理 Properties 对象就可以了。</p>
<p>二级标签里面有很多的配置，比如二级缓存，延迟加载，自动生成主键这些。需要 注意的是，我们之前提到的所有的默认值，都是在这里赋值的。如果说后面我们不知道这个属性的值是什么，也可以到这一步来确认一下。</p>
<p>所有的值，都会赋值到 Configuration 的属性里面去。</p>
<h3 id="environmentsElement"><a href="#environmentsElement" class="headerlink" title="environmentsElement()"></a>environmentsElement()</h3><p>这一步是解析&lt;environments&gt;标签。</p>
<p>我们前面讲过，一个 environment 就是对应一个数据源，所以在这里我们会根据配 置的&lt;transactionManager&gt;创建一个事务工厂，根据&lt;dataSource&gt;标签创建一个数据 源，最后把这两个对象设置成 Environment 对象的属性，放到 Configuration 里面。</p>
<p>回答了前面的问题:数据源工厂和数据源在哪里创建。 先记下这个问题:数据源和事务工厂在哪里会用到?</p>
<h3 id="databaseIdProviderElement"><a href="#databaseIdProviderElement" class="headerlink" title="databaseIdProviderElement()"></a>databaseIdProviderElement()</h3><p>解析 databaseIdProvider 标签，生成 DatabaseIdProvider 对象(用来支持不同厂 商的数据库)。</p>
<h3 id="typeHandlerElement"><a href="#typeHandlerElement" class="headerlink" title="typeHandlerElement()"></a>typeHandlerElement()</h3><p>跟 TypeAlias 一样，TypeHandler 有两种配置方式，一种是单独配置一个类，一种 是指定一个 package。最后我们得到的是 JavaType 和 JdbcType，以及用来做相互映射 的 TypeHandler 之间的映射关系。</p>
<p>最后存放在 TypeHandlerRegistry 对象里面。</p>
<p>问题:这种三个对象(Java 类型，JDBC 类型，Handler)的关系怎么映射?(Map 里面再放一个 Map)</p>
<h3 id="mapperElement"><a href="#mapperElement" class="headerlink" title="mapperElement()"></a>mapperElement()</h3><p><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#mappers" target="_blank" rel="noopener">http://www.mybatis.org/mybatis-3/zh/configuration.html#mappers</a></p>
<p><strong>1)判断</strong></p>
<p>最后就是&lt;mappers&gt;标签的解析。</p>
<table>
<thead>
<tr>
<th>扫描类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>resource</td>
<td>相对路径</td>
</tr>
<tr>
<td>url</td>
<td>绝对路径</td>
</tr>
<tr>
<td>package</td>
<td>包</td>
</tr>
<tr>
<td>class</td>
<td>单个接口</td>
</tr>
</tbody></table>
<p>首先会判断是不是接口，只有接口才解析;然后判断是不是已经注册了，单个 Mapper 重复注册会抛出异常。</p>
<p><strong>2)注册</strong></p>
<p>XMLMapperBuilder.parse()方法，是对 Mapper 映射器的解析。里面有两个方法:</p>
<p>configurationElement()—— 解 析 所 有 的 子 标 签 ， 其 中 buildStatementFromContext()最终获得 MappedStatement 对象。</p>
<p>bindMapperForNamespace()——把 namespace(接口类型)和工厂类绑定起来。</p>
<p>无论是按 package 扫描，还是按接口扫描，最后都会调用到 MapperRegistry 的 addMapper()方法。</p>
<p>MapperRegistry 里面维护的其实是一个 Map 容器，存储接口和代理工厂的映射关 系。</p>
<p>问题:为什么要放一个代理工厂呢?代理工厂用来干什么?</p>
<p><strong>3)处理注解</strong></p>
<p>除了映射器文件，在这里也会去解析 Mapper 接口方法上的注解。在 addMapper() 方法里面创建了一个 MapperAnnotationBuilder，我们点进去看一下 parse()方法。</p>
<p>parseCache() 和 parseCacheRef() 方 法 其 实 是 对 @CacheNamespace 和 @CacheNamespaceRef 这两个注解的处理。</p>
<p>parseStatement()方法里面的各种 getAnnotation()，都是对注解的解析，比如 @Options，@SelectKey，@ResultMap 等等。</p>
<p>最后同样会解析成 MappedStatement 对象，也就是说在 XML 中配置，和使用注 解配置，最后起到一样的效果。</p>
<p><strong>4)收尾</strong></p>
<p>如果注册没有完成，还要从 Map 里面 remove 掉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MapperRegistry.java</span></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">    knownMappers.remove(type); </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>最后，MapperRegistry 也会放到 Configuration 里面去。</p>
<p>第二步是调用另一个 build()方法，返回 DefaultSqlSessionFactory。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>在这一步，我们主要完成了 config 配置文件、Mapper 文件、Mapper 接口上的注 解的解析。</p>
<p>我们得到了一个最重要的对象 Configuration，这里面存放了全部的配置信息，它在属性里面还有各种各样的容器。</p>
<p>最后，返回了一个 DefaultSqlSessionFactory，里面持有了 Configuration 的实例。</p>
<h2 id="二、会话创建过程"><a href="#二、会话创建过程" class="headerlink" title="二、会话创建过程"></a>二、会话创建过程</h2><p>这是第二步，我们跟数据库的每一次连接，都需要创建一个会话，我们用 openSession()方法来创建。</p>
<p>DefaultSqlSessionFactory —— openSessionFromDataSource()</p>
<p>这个会话里面，需要包含一个 Executor 用来执行 SQL。Executor 又要指定事务类 型和执行器的类型。</p>
<p>所以我们会先从 Configuration 里面拿到 Enviroment，Enviroment 里面就有事务 工厂。</p>
<h3 id="1、创建-Transaction"><a href="#1、创建-Transaction" class="headerlink" title="1、创建 Transaction"></a>1、创建 Transaction</h3><table>
<thead>
<tr>
<th>属性</th>
<th>产生工厂类</th>
<th>产生事务</th>
</tr>
</thead>
<tbody><tr>
<td>JDBC</td>
<td>JdbcTransactionFactory</td>
<td>JdbcTransaction</td>
</tr>
<tr>
<td>MANAGED</td>
<td>ManagedTransactionFactory</td>
<td>ManagedTransaction</td>
</tr>
</tbody></table>
<p>如果配置的是 JDBC，则会使用 Connection 对象的 commit()、rollback()、close() 管理事务。</p>
<p>如果配置成 MANAGED，会把事务交给容器来管理，比如 JBOSS，Weblogic。因 为我们跑的是本地程序，如果配置成 MANAGE 不会有任何事务。</p>
<p>如果是 Spring + MyBatis，则没有必要配置，因为我们会直接在 applicationContext.xml 里面配置数据源和事务管理器，覆盖 MyBatis 的配置。</p>
<h3 id="2、创建-Executor"><a href="#2、创建-Executor" class="headerlink" title="2、创建 Executor"></a>2、创建 Executor</h3><p>我们知道，Executor 的基本类型有三种:SIMPLE、BATCH、REUSE，默认是 SIMPLE (settingsElement()读取默认值)，他们都继承了抽象类 BaseExecutor。</p>
<p>为什么要让抽象类实现接口，然后让具体实现类继承抽象类?(模板方法模式)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“定义一个算法的骨架，并允许子类为一个或者多个步骤提供实现。 模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。”</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg2ngkhjv1j31fc0ga7fi.jpg" alt="image-20200623234043164"></p>
<p>问题:三种类型的区别(通过 update()方法对比)?</p>
<p>SimpleExecutor:每执行一次 update 或 select，就开启一个 Statement 对象，用 完立刻关闭 Statement 对象。</p>
<p>ReuseExecutor:执行 update 或 select，以 sql 作为 key 查找 Statement 对象， 存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map 内， 供下一次使用。简言之，就是重复使用 Statement 对象。</p>
<p>BatchExecutor:执行 update(没有 select，JDBC 批处理不支持 select)，将所 有 sql 都添加到批处理中(addBatch())，等待统一执行(executeBatch())，它缓存 了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。</p>
<p>如果配置了 cacheEnabled=ture，会用装饰器模式对 executor 进行包装:new CachingExecutor(executor)。</p>
<p>包装完毕后，会执行:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executor = (Executor) interceptorChain.pluginAll(executor);</span><br></pre></td></tr></table></figure>

<p>此处会对 executor 进行包装。</p>
<p>回答了前面的问题:数据源和事务工厂在哪里会用到——创建执行器的时候。</p>
<p>最终返回 DefaultSqlSession，属性包括 Configuration、Executor 对象。</p>
<p>总结:创建会话的过程，我们获得了一个 DefaultSqlSession，里面包含了一个 Executor，它是 SQL 的执行者。</p>
<h2 id="三、获得-Mapper-对象"><a href="#三、获得-Mapper-对象" class="headerlink" title="三、获得 Mapper 对象"></a>三、获得 Mapper 对象</h2><p>现在我们已经有一个 DefaultSqlSession 了，必须找到 Mapper.xml 里面定义的 Statement ID，才能执行对应的 SQL 语句。</p>
<p>找到 Statement ID 有两种方式:一种是直接调用 session 的方法，在参数里面传入 Statement ID，这种方式属于硬编码，我们没办法知道有多少处调用，修改起来也很麻 烦。</p>
<p>另一个问题是如果参数传入错误，在编译阶段也是不会报错的，不利于预先发现问 题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blog blog = (Blog) session.selectOne(<span class="string">"com.gupaoedu.mapper.BlogMapper.selectBlogById "</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>所以在 MyBatis 后期的版本提供了第二种方式，就是定义一个接口，然后再调用 Mapper 接口的方法。</p>
<p>由于我们的接口名称跟 Mapper.xml 的 namespace 是对应的，接口的方法跟 statement ID 也都是对应的，所以根据方法就能找到对应的要执行的 SQL。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BlogMapper mapper = session.getMapper(BlogMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>在这里我们主要研究一下 Mapper 对象是怎么获得的，它的本质是什么。</p>
<p>DefaultSqlSession 的 getMapper()方法，调用了 Configuration 的 getMapper() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configuration.&lt;T&gt;getMapper()</span><br></pre></td></tr></table></figure>

<p>Configuration 的 getMapper()方法，又调用了 MapperRegistry 的 getMapper() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapperRegistry.getMapper()</span><br></pre></td></tr></table></figure>

<p>我们知道，在解析 mapper 标签和 Mapper.xml 的时候已经把接口类型和类型对应的 MapperProxyFactory 放到了一个 Map 中。获取 Mapper 代理对象，实际上是从Map 中获取对应的工厂类后，调用以下方法创建对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MapperProxyFactory.newInstance()</span><br></pre></td></tr></table></figure>

<p>最终通过代理模式返回代理对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br></pre></td></tr></table></figure>

<p>回答了前面的问题:为什么要保存一个工厂类，它是用来创建代理对象的。</p>
<p>JDK 动态代理和 MyBatis 用到的 JDK 动态代理有什么区别?</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg35rjp601j30gq048dgn.jpg" alt="image-20200624101405063"></p>
<p>JDK 动态代理:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg35rv0bd4j30nq0g2go8.jpg" alt="image-20200624101423155"></p>
<p>JDK 动态代理代理，在实现了 InvocationHandler 的代理类里面，需要传入一个被 代理对象的实现类。</p>
<p>MyBatis 的动态代理:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg35spwtenj30ne0f476h.jpg" alt="image-20200624101459654"></p>
<p>不需要实现类的原因:我们只需要根据接口类型+方法的名称，就可以找到 Statement ID 了，而唯一要做的一件事情也是这件，所以不需要实现类。在 MapperProxy 里面直接执行逻辑(也就是执行 SQL)就可以。</p>
<p>总结:</p>
<p>获得 Mapper 对象的过程，实质上是获取了一个 MapperProxy 的代理对象。 MapperProxy 中有 sqlSession、mapperInterface、methodCache。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg35tbjh37j30r004m78r.jpg" alt="image-20200624101547188"></p>
<p>先记下这个问题:在代理类中为什么要持有一个 SqlSession?</p>
<h2 id="四、执行-SQL"><a href="#四、执行-SQL" class="headerlink" title="四、执行 SQL"></a>四、执行 SQL</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blog blog = mapper.selectBlog(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>由于所有的 Mapper 都是 MapperProxy 代理对象，所以任意的方法都是执行 MapperProxy 的 invoke()方法。</p>
<p>问题 1:我们引入 MapperProxy 为了解决什么问题?硬编码和编译时检查问题。它 需要做的事情是:根据方法查找 Statement ID 的问题。</p>
<p>问题 2:这里没有实现类，进入到 invoke 方法的时候做了什么事情?它是怎么找到 我们要执行的 SQL 的?</p>
<p>我们看一下 invoke()方法:</p>
<h3 id="1、MapperProxy-invoke"><a href="#1、MapperProxy-invoke" class="headerlink" title="1、MapperProxy.invoke()"></a>1、MapperProxy.invoke()</h3><p>1)首先判断是否需要去执行 SQL，还是直接执行方法。<br> Object 本身的方法和 Java 8 中接口的默认方法不需要去执行 SQL。 思考:isDefaultMethod 判断的是什么?写一个什么方法，它会走到这里? 这个是 Java 8 接口中默认方法的示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IService</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"GP"</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2)获取缓存<br> 这里加入缓存是为了提升 MapperMethod 的获取速度:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取缓存，保存了方法签名和接口方法的关系</span></span><br><span class="line"><span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br></pre></td></tr></table></figure>

<p>Map 的 computeIfAbsent()方法:只有 key 不存在或者 value 为 null 的时候才调用 mappingFunction()。</p>
<h3 id="2、MapperMethod-execute"><a href="#2、MapperMethod-execute" class="headerlink" title="2、MapperMethod.execute()"></a>2、MapperMethod.execute()</h3><p>接下来又调用了 mapperMethod 的 execute 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapperMethod.execute(sqlSession, args);</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg367vzctdj30jk0cyn5z.jpg" alt="image-20200624102947618"></p>
<p>apperMethod 里面主要有两个属性，一个是 SqlCommand，一个是 MethodSignature，这两个都是 MapperMethod 的内部类。</p>
<p>另外定义了多个 execute()方法。</p>
<p>在这一步，根据不同的 type 和返回类型:<br>调用 convertArgsToSqlCommandParam()将参数转换为 SQL 的参数。<br>调用 sqlSession 的 insert()、update()、delete()、selectOne ()方法，我们以查询</p>
<p>为例，会走到 selectOne()方法。</p>
<h3 id="3、DefaultSqlSession-selectOne"><a href="#3、DefaultSqlSession-selectOne" class="headerlink" title="3、DefaultSqlSession.selectOne()"></a>3、DefaultSqlSession.selectOne()</h3><p>selectOne()最终也是调用了 selectList()。</p>
<p>在 SelectList()中，我们先根据 command name(Statement ID)从 Configuration 中拿到 MappedStatement，这个 ms 上面有我们在 xml 中配置的所有属性，包括 id、 statementType、sqlSource、useCache、入参、出参等等。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg369bsc1fj30hk0foqbg.jpg" alt="image-20200624103110454"></p>
<p>然后执行了 Executor 的 query()方法。<br>前面我们说到了 Executor 有三种基本类型，同学们还记得是哪几种么? SIMPLE/REUSE/BATCH，还有一种包装类型，CachingExecutor。 那么在这里到底会选择哪一种执行器呢?<br>我们要回过头去看看 DefaultSqlSession 在初始化的时候是怎么赋值的，这个就是我们的会话创建过程。</p>
<p>如果启用了二级缓存，就会先调用 CachingExecutor 的 query()方法，里面有缓存相关的操作，然后才是再调用基本类型的执行器，比如默认的 SimpleExecutor。</p>
<p>在没有开启二级缓存的情况下，先会走到 BaseExecutor 的 query()方法(否则会先 走到 CachingExecutor)。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg36abstc8j30rq08878a.jpg" alt="image-20200624103208406"></p>
<h3 id="4、BaseExecutor-query"><a href="#4、BaseExecutor-query" class="headerlink" title="4、BaseExecutor.query()"></a>4、BaseExecutor.query()</h3><h4 id="1-创建-CacheKey"><a href="#1-创建-CacheKey" class="headerlink" title="1)创建 CacheKey"></a>1)创建 CacheKey</h4><p>从 Configuration 中获取 MappedStatement， 然后从 BoundSql 中获取 SQL 信 息，创建 CacheKey。这个 CacheKey 就是缓存的 Key。</p>
<p>然后再调用另一个 query()方法。</p>
<h4 id="2-清空本地缓存"><a href="#2-清空本地缓存" class="headerlink" title="2)清空本地缓存"></a>2)清空本地缓存</h4><p>queryStack 用于记录查询栈，防止递归查询重复处理缓存。flushCache=true 的时候，会先清理本地缓存(一级缓存):clearLocalCache();</p>
<p>如果没有缓存，会从数据库查询:queryFromDatabase() 如果 LocalCacheScope == STATEMENT，会清理本地缓存。</p>
<h4 id="3-从数据库查询"><a href="#3-从数据库查询" class="headerlink" title="3)从数据库查询"></a>3)从数据库查询</h4><p>a)缓存 先在缓存用占位符占位。执行查询后，移除占位符，放入数据。</p>
<p>b)查询执行 Executor 的 doQuery();默认是 SimpleExecutor。</p>
<h3 id="5、SimpleExecutor-doQuery"><a href="#5、SimpleExecutor-doQuery" class="headerlink" title="5、SimpleExecutor.doQuery()"></a>5、SimpleExecutor.doQuery()</h3><h4 id="1-创建-StatementHandler"><a href="#1-创建-StatementHandler" class="headerlink" title="1)创建 StatementHandler"></a>1)创建 StatementHandler</h4><p>在 configuration.newStatementHandler()中，new 一个 StatementHandler，先 得到 RoutingStatementHandler。</p>
<p>RoutingStatementHandler 里面没有任何的实现，是用来创建基本的 StatementHandler 的。这里会根据 MappedStatement 里面的 statementType 决定 StatementHandler 的 类 型 。 默 认 是 PREPARED ( STATEMENT 、 PREPARED 、 CALLABLE)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (ms.getStatementType()) &#123; </span><br><span class="line">  <span class="keyword">case</span> STATEMENT:</span><br><span class="line">    delegate = <span class="keyword">new</span> SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> PREPARED:</span><br><span class="line">    delegate = <span class="keyword">new</span> PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> CALLABLE:</span><br><span class="line">    delegate = <span class="keyword">new</span> CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Unknown statement type: "</span> + ms.getStatementType()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StatementHandler 里面包含了处理参数的 ParameterHandler 和处理结果集的 ResultSetHandler。</p>
<p>这两个对象都是在上面 new 的时候创建的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line"><span class="keyword">this</span>.resultSetHandler = configuration.newResultSetHandler(executor, mappedStatement, rowBounds,parameterHandler, resultHandler, boundSql);</span><br></pre></td></tr></table></figure>

<p>这三个对象都是可以被插件拦截的四大对象之一，所以在创建之后都要用拦截器进 行包装的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br></pre></td></tr></table></figure>

<p>PS:四大对象还有一个是谁?在什么时候创建的?(Executor)</p>
<h4 id="2-创建-Statement"><a href="#2-创建-Statement" class="headerlink" title="2)创建 Statement"></a>2)创建 Statement</h4><p>用 new 出来的 StatementHandler 创建 Statement 对象——prepareStatement() 方法对语句进行预编译，处理参数。</p>
<p>handler.parameterize(stmt) ;</p>
<h4 id="3-执行的-StatementHandler-的-query-方法"><a href="#3-执行的-StatementHandler-的-query-方法" class="headerlink" title="3)执行的 StatementHandler 的 query()方法"></a>3)执行的 StatementHandler 的 query()方法</h4><p>RoutingStatementHandler 的 query()方法。<br>delegate 委派，最终执行 PreparedStatementHandler 的 query()方法。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg36f8f6e5j30ei02y75v.jpg" alt="image-20200624103651041"></p>
<h4 id="4-执行-PreparedStatement-的-execute-方法"><a href="#4-执行-PreparedStatement-的-execute-方法" class="headerlink" title="4)执行 PreparedStatement 的 execute()方法"></a>4)执行 PreparedStatement 的 execute()方法</h4><p>后面就是 JDBC 包中的 PreparedStatement 的执行了。</p>
<h4 id="5-ResultSetHandler-处理结果集"><a href="#5-ResultSetHandler-处理结果集" class="headerlink" title="5)ResultSetHandler 处理结果集"></a>5)ResultSetHandler 处理结果集</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> resultSetHandler.handleResultSets(ps);</span><br></pre></td></tr></table></figure>

<p>问题:怎么把 ResultSet 转换成 List<Object>?</p>
<p>ResultSetHandler 只有一个实现类:DefaultResultSetHandler。也就是执行 DefaultResultSetHandler 的 handleResultSets ()方法。</p>
<p>首先我们会先拿到第一个结果集，如果没有配置一个查询返回多个结果集的情况， 一般只有一个结果集。如果下面的这个 while 循环我们也不用，就是执行一次。</p>
<p>然后会调用 handleResultSet()方法。</p>
<p>【作业】总结一下，MyBatis 里面用到了哪些设计模式?</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shoufengsfsf.github.io/2020/06/23/mybatis%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shoufeng">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shoufengsfsf.github.io">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/23/mybatis%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">mybatis体系结构与工作原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-23 10:33:12 / 修改时间：23:04:01" itemprop="dateCreated datePublished" datetime="2020-06-23T10:33:12+08:00">2020-06-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mybatis%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">mybatis源码解读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="mybatis体系结构与工作原理"><a href="#mybatis体系结构与工作原理" class="headerlink" title="mybatis体系结构与工作原理"></a>mybatis体系结构与工作原理</h1><h2 id="MyBatis-的工作流程分析"><a href="#MyBatis-的工作流程分析" class="headerlink" title="MyBatis 的工作流程分析"></a>MyBatis 的工作流程分析</h2><p>首先在 MyBatis 启动的时候我们要去解析配置文件，包括全局配置文件和映射器配置文件，这里面包含了我们怎么控制 MyBatis 的行为，和我们要对数据库下达的指令，也就是我们的 SQL 信息。我们会把它们解析成一个 Configuration 对象。</p>
<p>接下来就是我们操作数据库的接口，它在应用程序和数据库中间，代表我们跟数据库之间的一次连接:这个就是 SqlSession 对象。</p>
<p>我们要获得一个会话，必须有一个会话工厂 SqlSessionFactory。</p>
<p>SqlSessionFactory 里面又必须包含我们的所有的配置信息，所以我们会通过一个 Builder 来创建工厂类。</p>
<p>我们知道，MyBatis 是对 JDBC 的封装，也就是意味着底层一定会出现 JDBC 的一 些核心对象，比如执行 SQL 的 Statement，结果集 ResultSet。在 Mybatis 里面， SqlSession 只是提供给应用的一个接口，还不是 SQL 的真正的执行对象。</p>
<p>我们上次课提到了，SqlSession 持有了一个 Executor 对象，用来封装对数据库的操作。</p>
<p>在执行器 Executor 执行 query 或者 update 操作的时候我们创建一系列的对象， 来处理参数、执行 SQL、处理结果集，这里我们把它简化成一个对象:StatementHandler， 在阅读源码的时候我们再去了解还有什么其他的对象。</p>
<p>这个就是 MyBatis 主要的工作流程，如图:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg2ixaym3zj30pk0n4js3.jpg" alt="mybatis主要工作流程"></p>
<h2 id="MyBatis-架构分层与模块划分"><a href="#MyBatis-架构分层与模块划分" class="headerlink" title="MyBatis 架构分层与模块划分"></a><strong>MyBatis</strong> 架构分层与模块划分</h2><p>在 MyBatis 的主要工作流程里面，不同的功能是由很多不同的类协作完成的，它们 分布在 MyBatis jar 包的不同的 package 里面。</p>
<p>我们来看一下 MyBatis 的 jar 包(基于 3.5.1)，</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg2j43crszj30h40sw0v3.jpg" alt="image-20200623211022205"></p>
<p>大概有 300 多个类，这样看起来不够清楚，不知道什么类在什么环节工作，属于什 么层次。</p>
<p>跟 Spring 一样，MyBatis 按照功能职责的不同，所有的 package 可以分成不同的 工作层次。</p>
<p>我们可以把 MyBatis 的工作流程类比成餐厅的服务流程。</p>
<p>第一个是跟客户打交道的服务员，它是用来接收程序的工作指令的，我们把它叫做 接口层。</p>
<p>第二个是后台的厨师，他们根据客户的点菜单，把原材料加工成成品，然后传到窗 口。这一层是真正去操作数据的，我们把它叫做核心层。</p>
<p>最后就是餐厅也需要有人做后勤(比如清洁、采购、财务)，来支持厨师的工作和 整个餐厅的运营。我们把它叫做基础层。</p>
<p>来看一下这张图，我们根据刚才的分层，和大体的执行流程，做了这么一个总结。 当然，从不同的角度来描述，架构图的划分有所区别，这张图画起来也有很多形式。我们先从总体上建立一个印象。每一层的主要对象和主要的功能我们也给大家分析一下。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg2j5ihscyj31g40u0tlv.jpg" alt="image-20200623211140973"></p>
<h3 id="接口层"><a href="#接口层" class="headerlink" title="接口层"></a>接口层</h3><p>首先接口层是我们打交道最多的。核心对象是 SqlSession，它是上层应用和 MyBatis 打交道的桥梁，SqlSession 上定义了非常多的对数据库的操作方法。接口层在接收到调 用请求的时候，会调用核心处理层的相应模块来完成具体的数据库操作。</p>
<h3 id="核心处理层"><a href="#核心处理层" class="headerlink" title="核心处理层"></a>核心处理层</h3><p>接下来是核心处理层。既然叫核心处理层，也就是跟数据库操作相关的动作都是在 这一层完成的。</p>
<p>核心处理层主要做了这几件事:</p>
<ol>
<li><p>把接口中传入的参数解析并且映射成JDBC类型;</p>
</li>
<li><p>解析xml文件中的SQL语句，包括插入参数，和动态SQL的生成; </p>
</li>
<li><p>执行SQL语句;</p>
</li>
<li><p>处理结果集，并映射成Java对象。</p>
</li>
</ol>
<p>插件也属于核心层，这是由它的工作方式和拦截的对象决定的。</p>
<h3 id="基础支持层"><a href="#基础支持层" class="headerlink" title="基础支持层"></a>基础支持层</h3><p>最后一个就是基础支持层。基础支持层主要是一些抽取出来的通用的功能(实现复 用)，用来支持核心处理层的功能。比如数据源、缓存、日志、xml 解析、反射、IO、 事务等等这些功能。</p>
<p>这个就是 MyBatis 的主要工作流程和架构分层。接下来我们来学习一下基础层里面 的一个主要模块，缓存。我们一起来了解一下 MyBatis 一级缓存和二级缓存的区别，和 它们的工作方式，以及使用过程里面有什么注意事项。</p>
<h2 id="MyBatis-缓存详解"><a href="#MyBatis-缓存详解" class="headerlink" title="MyBatis 缓存详解"></a><strong>MyBatis</strong> 缓存详解</h2><h3 id="cache-缓存"><a href="#cache-缓存" class="headerlink" title="cache 缓存"></a>cache 缓存</h3><p>(基于 mybatis-standalone 工程)</p>
<p>缓存是一般的 ORM 框架都会提供的功能，目的就是提升查询的效率和减少数据库的 压力。跟 Hibernate 一样，MyBatis 也有一级缓存和二级缓存，并且预留了集成第三方 缓存的接口。</p>
<h4 id="缓存体系结构"><a href="#缓存体系结构" class="headerlink" title="缓存体系结构"></a>缓存体系结构</h4><p>MyBatis 跟缓存相关的类都在 cache 包里面，其中有一个 Cache 接口，只有一个默 认的实现类 PerpetualCache，它是用 HashMap 实现的。</p>
<p>除此之外，还有很多的装饰器，通过这些装饰器可以额外实现很多的功能:回收策略、日志记录、定时刷新等等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 煎饼加鸡蛋加香肠</span></span><br><span class="line">“装饰者模式(Decorator Pattern)是指在不改变原有对象的基础之上，将功能附加到对象上，提供了比继承更有弹性的替代方案(扩展原有对象的功能)。”</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg2jdqym38j30vk0bg79s.jpg" alt="image-20200623211938385"></p>
<p>但是无论怎么装饰，经过多少层装饰，最后使用的还是基本的实现类(默认 PerpetualCache)。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg2jfldpvjj30x60fo4bf.jpg" alt="image-20200623212124898"></p>
<p>所有的缓存实现类总体上可分为三类:基本缓存、淘汰算法缓存、装饰器缓存。</p>
<table>
<thead>
<tr>
<th>缓存实现类</th>
<th>描述</th>
<th>作用</th>
<th>装饰条件</th>
</tr>
</thead>
<tbody><tr>
<td>基本缓存</td>
<td>缓存基本实现类</td>
<td>默认是 PerpetualCache，也可以自定义比如 RedisCache、EhCache 等，具备基本功能的缓存类</td>
<td>无</td>
</tr>
<tr>
<td>LruCache</td>
<td>LRU 策略的缓存</td>
<td>当缓存到达上限时候，删除最近最少使用的缓存 (Least Recently Use)</td>
<td>eviction=”LRU”(默 认)</td>
</tr>
<tr>
<td>FifoCache</td>
<td>FIFO 策略的缓存</td>
<td>当缓存到达上限时候，删除最先入队的缓存</td>
<td>eviction=”FIFO”</td>
</tr>
<tr>
<td>SoftCache WeakCache</td>
<td>带清理策略的缓存</td>
<td>通过 JVM 的软引用和弱引用来实现缓存，当 JVM 内存不足时，会自动清理掉这些缓存，基于 SoftReference 和 WeakReference</td>
<td>eviction=”SOFT” eviction=”WEAK”</td>
</tr>
<tr>
<td>LoggingCache</td>
<td>带日志功能的缓存</td>
<td>比如:输出缓存命中率</td>
<td>基本</td>
</tr>
<tr>
<td>SynchronizedCache</td>
<td>同步缓存</td>
<td>基于 synchronized 关键字实现，解决并发问题</td>
<td>基本</td>
</tr>
<tr>
<td>BlockingCache</td>
<td>阻塞缓存</td>
<td>通过在 get/put 方式中加锁，保证只有一个线程操 作缓存，基于 Java 重入锁实现</td>
<td>blocking=true</td>
</tr>
<tr>
<td>SerializedCache</td>
<td>支持序列化的缓存</td>
<td>将对象序列化以后存到缓存中，取出时反序列化</td>
<td>readOnly=false(默 认)</td>
</tr>
<tr>
<td>ScheduledCache</td>
<td>定时调度的缓存</td>
<td>在进行 get/put/remove/getSize 等操作前，判断 缓存时间是否超过了设置的最长缓存时间(默认是 一小时)，如果是则清空缓存–即每隔一段时间清 空一次缓存</td>
<td>flushInterval 不为 空</td>
</tr>
<tr>
<td>TransactionalCache</td>
<td>事务缓存</td>
<td>在二级缓存中使用，可一次存入多个缓存，移除多 个缓存</td>
<td>在 TransactionalCach eManager 中用 Map 维护对应关系</td>
</tr>
</tbody></table>
<p>思考:缓存对象在什么时候创建?什么情况下被装饰?</p>
<p>我们要弄清楚这个问题，就必须要知道 MyBatis 的一级缓存和二级缓存的工作位置 和工作方式的区别。</p>
<h4 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h4><h5 id="一级缓存-本地缓存-介绍"><a href="#一级缓存-本地缓存-介绍" class="headerlink" title="一级缓存(本地缓存)介绍"></a>一级缓存(本地缓存)介绍</h5><p>一级缓存也叫本地缓存，MyBatis 的一级缓存是在会话(SqlSession)层面进行缓 存的。MyBatis 的一级缓存是默认开启的，不需要任何的配置。</p>
<p>首先我们必须去弄清楚一个问题，在 MyBatis 执行的流程里面，涉及到这么多的对 象，那么缓存 PerpetualCache 应该放在哪个对象里面去维护?如果要在同一个会话里面 共享一级缓存，这个对象肯定是在 SqlSession 里面创建的，作为 SqlSession 的一个属 性。</p>
<p>DefaultSqlSession 里面只有两个属性，Configuration 是全局的，所以缓存只可能 放在 Executor 里面维护——SimpleExecutor/ReuseExecutor/BatchExecutor 的父类BaseExecutor 的构造函数中持有了 PerpetualCache。</p>
<p>在同一个会话里面，多次执行相同的 SQL 语句，会直接从内存取到缓存的结果，不会再发送 SQL 到数据库。但是不同的会话里面，即使执行的 SQL 一模一样(通过一个 Mapper 的同一个方法的相同参数调用)，也不能使用到一级缓存。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg2k3bek4xj31580iywio.jpg" alt="image-20200623214412856"></p>
<p>接下来我们来验证一下，MyBatis 的一级缓存到底是不是只能在一个会话里面共享， 以及跨会话(不同 session)操作相同的数据会产生什么问题。</p>
<h5 id="一级缓存验证"><a href="#一级缓存验证" class="headerlink" title="一级缓存验证"></a>一级缓存验证</h5><p>(基于 mybatis-standalone 工程，注意演示一级缓存需要先关闭二级缓存， localCacheScope 设置为 SESSION)</p>
<p>判断是否命中缓存:如果再次发送 SQL 到数据库执行，说明没有命中缓存;如果直 接打印对象，说明是从内存缓存中取到了结果。</p>
<p>1、在同一个 session 中共享</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BlogMapper mapper = session.getMapper(BlogMapper<span class="class">.<span class="keyword">class</span>)</span>; </span><br><span class="line">System.out.println(mapper.selectBlog(<span class="number">1</span>)); </span><br><span class="line">System.out.println(mapper.selectBlog(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>2、不同 session 不能共享</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session1 = sqlSessionFactory.openSession(); </span><br><span class="line">BlogMapper mapper1 = session1.getMapper(BlogMapper<span class="class">.<span class="keyword">class</span>)</span>; </span><br><span class="line">System.out.println(mapper.selectBlog(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>PS:一级缓存在 BaseExecutor 的 query()——queryFromDatabase()中存入。在 queryFromDatabase()之前会 get()。</p>
<p>3、同一个会话中，update(包括 delete)会导致一级缓存被清空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mapper.updateByPrimaryKey(blog); </span><br><span class="line">session.commit();</span><br><span class="line">System.out.println(mapper.selectBlogById(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>一级缓存是在 BaseExecutor 中的 update()方法中调用 clearLocalCache()清空的 (无条件)，query 中会判断。</p>
<p>如果跨会话，会出现什么问题?</p>
<p>4、其他会话更新了数据，导致读取到脏数据(一级缓存不能跨会话共享)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会话 2 更新了数据，会话 2 的一级缓存更新</span></span><br><span class="line">BlogMapper mapper2 = session2.getMapper(BlogMapper<span class="class">.<span class="keyword">class</span>)</span>; </span><br><span class="line">mapper2.updateByPrimaryKey(blog);</span><br><span class="line">session2.commit();</span><br><span class="line"><span class="comment">// 会话 1 读取到脏数据，因为一级缓存不能跨会话共享</span></span><br><span class="line">System.out.println(mapper1.selectBlog(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<h5 id="一级缓存的不足"><a href="#一级缓存的不足" class="headerlink" title="一级缓存的不足"></a>一级缓存的不足</h5><p>使用一级缓存的时候，因为缓存不能跨会话共享，不同的会话之间对于相同的数据 可能有不一样的缓存。在有多个会话或者分布式环境下，会存在脏数据的问题。如果要 解决这个问题，就要用到二级缓存。</p>
<p>【思考】一级缓存怎么命中?CacheKey 怎么构成?</p>
<p>【思考】一级缓存是默认开启的，怎么关闭一级缓存?</p>
<h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h4><h5 id="二级缓存介绍"><a href="#二级缓存介绍" class="headerlink" title="二级缓存介绍"></a>二级缓存介绍</h5><p>二级缓存是用来解决一级缓存不能跨会话共享的问题的，范围是 namespace 级别 的，可以被多个 SqlSession 共享(只要是同一个接口里面的相同方法，都可以共享)， 生命周期和应用同步。</p>
<p>思考一个问题:如果开启了二级缓存，二级缓存应该是工作在一级缓存之前，还是 在一级缓存之后呢?二级缓存是在哪里维护的呢?</p>
<p>作为一个作用范围更广的缓存，它肯定是在 SqlSession 的外层，否则不可能被多个 SqlSession 共享。而一级缓存是在 SqlSession 内部的，所以第一个问题，肯定是工作 在一级缓存之前，也就是只有取不到二级缓存的情况下才到一个会话中去取一级缓存。</p>
<p>第二个问题，二级缓存放在哪个对象中维护呢? 要跨会话共享的话，SqlSession 本 身和它里面的 BaseExecutor 已经满足不了需求了，那我们应该在 BaseExecutor 之外创 建一个对象。</p>
<p>实际上 MyBatis 用了一个装饰器的类来维护，就是 CachingExecutor。如果启用了 二级缓存，MyBatis 在创建 Executor 对象的时候会对 Executor 进行装饰。</p>
<p>CachingExecutor 对于查询请求，会判断二级缓存是否有缓存结果，如果有就直接 返回，如果没有委派交给真正的查询器 Executor 实现类，比如 SimpleExecutor 来执行 查询，再走到一级缓存的流程。最后会把结果缓存起来，并且返回给用户。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg2kw0qa4rj31eu0qg199.jpg" alt="image-20200623221148435"></p>
<p>一级缓存是默认开启的，那二级缓存怎么开启呢?</p>
<h5 id="开启二级缓存的方法"><a href="#开启二级缓存的方法" class="headerlink" title="开启二级缓存的方法"></a>开启二级缓存的方法</h5><p>第一步:在 mybatis-config.xml 中配置了(可以不配置，默认是 true)</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>只要没有显式地设置 cacheEnabled=false，都会用 CachingExecutor 装饰基本的执行器。</p>
<p>第二步:在 Mapper.xml 中配置&lt;cache/&gt;标签:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 声明这个 namespace 使用二级缓存 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">"org.apache.ibatis.cache.impl.PerpetualCache"</span> </span></span><br><span class="line">       size="1024" &lt;!—最多缓存对象个数，默认 1024--&gt; </span><br><span class="line">			 eviction="LRU" <span class="tag">&lt;<span class="name">!—回收策略--</span>&gt;</span> </span><br><span class="line">			 flushInterval="120000" <span class="tag">&lt;<span class="name">!—自动刷新时间</span> <span class="attr">ms</span>，未配置时只有调用时刷新<span class="attr">--</span>&gt;</span> </span><br><span class="line">			 readOnly="false"/&gt; <span class="tag">&lt;<span class="name">!—默认是</span> <span class="attr">false</span>（安全），改为 <span class="attr">true</span> 可读写时，对象必须支持序列 化 <span class="attr">--</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>cache 属性详解:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
<th>取值</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>缓存实现类</td>
<td>需要实现 Cache 接口，默认是 PerpetualCache</td>
</tr>
<tr>
<td>size</td>
<td>最多缓存对象个数</td>
<td>默认 1024</td>
</tr>
<tr>
<td>eviction</td>
<td>回收策略(缓存淘汰算法)</td>
<td>LRU – 最近最少使用的:移除最长时间不被使用的对象(默认)。<br/>FIFO – 先进先出:按对象进入缓存的顺序来移除它们。<br/> SOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。<br/> WEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。</td>
</tr>
<tr>
<td>flushInterval</td>
<td>定时自动清空缓存间隔</td>
<td>自动刷新时间，单位 ms，未配置时只有调用时刷新</td>
</tr>
<tr>
<td>readOnly</td>
<td>是否只读</td>
<td>true:只读缓存;会给所有调用者返回缓存对象的相同实例。因此这些对象 不能被修改。这提供了很重要的性能优势。<br/>false:读写缓存;会返回缓存对象的拷贝(通过序列化)，不会共享。这 会慢一些，但是安全，因此默认是 false。<br/>改为 false 可读写时，对象必须支持序列化。</td>
</tr>
<tr>
<td>blocking</td>
<td>是否使用可重入锁实现 缓存的并发控制</td>
<td>true，会使用 BlockingCache 对 Cache 进行装饰 默认 false</td>
</tr>
</tbody></table>
<p>Mapper.xml 配置了&lt;cache&gt;之后，select()会被缓存。update()、delete()、insert() 会刷新缓存。</p>
<p>思考:如果 cacheEnabled=true，Mapper.xml 没有配置标签，还有二级缓存吗? 还会出现 CachingExecutor 包装对象吗?</p>
<p>只要 cacheEnabled=true 基本执行器就会被装饰。有没有配置&lt;cache&gt;，决定了在启动的时候会不会创建这个 mapper 的 Cache 对象，最终会影响到 CachingExecutor</p>
<p>query 方法里面的判断:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Cache cache = ms.getCache();</span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">    flushCacheIfRequired(ms);</span><br><span class="line">    <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">      ensureNoOutParams(ms, boundSql);</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">      List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">      <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">        list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果某些查询方法对数据的实时性要求很高，不需要二级缓存，怎么办? 我们可以在单个 Statement ID 上显式关闭二级缓存(默认是 true):</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlog"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span> <span class="attr">useCache</span>=<span class="string">"false"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>了解了二级缓存的工作位置和开启关闭的方法之后，我们也来验证一下二级缓存。 </p>
<h5 id="二级缓存验证"><a href="#二级缓存验证" class="headerlink" title="二级缓存验证"></a><strong>二级缓存验证</strong></h5><p>（验证二级缓存需要先开启二级缓存）</p>
<p>1、 事务不提交，二级缓存不存在 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BlogMapper mapper1 = session1.getMapper(BlogMapper<span class="class">.<span class="keyword">class</span>)</span>; </span><br><span class="line">System.out.println(mapper1.selectBlogById(<span class="number">1</span>)); </span><br><span class="line"><span class="comment">// 事务不提交的情况下，二级缓存不会写入 </span></span><br><span class="line"><span class="comment">// session1.commit(); </span></span><br><span class="line">BlogMapper mapper2 = session2.getMapper(BlogMapper<span class="class">.<span class="keyword">class</span>)</span>; </span><br><span class="line">System.out.println(mapper2.selectBlogById(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>思考：为什么事务不提交，二级缓存不生效？</p>
<p>因为二级缓存使用 TransactionalCacheManager（TCM）来管理，最后又调用了 </p>
<p>TransactionalCache 的getObject()、putObject和 commit()方法，TransactionalCache 里面又持有了真正的 Cache 对象，比如是经过层层装饰的 PerpetualCache。 </p>
<p>在 putObject 的时候，只是添加到了 entriesToAddOnCommit 里面，只有它的 commit()方法被调用的时候才会调用 flushPendingEntries()真正写入缓存。它就是在 DefaultSqlSession 调用 commit()的时候被调用的。</p>
<p>2、 使用不同的 session 和 mapper，验证二级缓存可以跨 session 存在取消以上 commit()的注释 </p>
<p>3、 在其他的 session 中执行增删改操作，验证缓存会被刷新</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Blog blog = <span class="keyword">new</span> Blog(); </span><br><span class="line">blog.setBid(<span class="number">1</span>); </span><br><span class="line">blog.setName(<span class="string">"357"</span>); </span><br><span class="line">mapper3.updateByPrimaryKey(blog); </span><br><span class="line">session3.commit(); </span><br><span class="line"><span class="comment">// 执行了更新操作，二级缓存失效，再次发送 SQL 查询 </span></span><br><span class="line">System.out.println(mapper2.selectBlogById(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>思考：为什么增删改操作会清空缓存？ </p>
<p>在 CachingExecutor 的 update()方法里面会调用 flushCacheIfRequired(ms)，isFlushCacheRequired 就是从标签里面渠道的 flushCache 的值。而增删改操作的 flushCache 属性默认为 true。 </p>
<h5 id="什么时候开启二级缓存？"><a href="#什么时候开启二级缓存？" class="headerlink" title="什么时候开启二级缓存？"></a><strong>什么时候开启二级缓存？</strong></h5><p>一级缓存默认是打开的，二级缓存需要配置才可以开启。那么我们必须思考一个问题，在什么情况下才有必要去开启二级缓存？ </p>
<p>1、因为所有的增删改都会刷新二级缓存，导致二级缓存失效，所以适合在查询为主的应用中使用，比如历史交易、历史订单的查询。否则缓存就失去了意义。 </p>
<p>2、如果多个 namespace 中有针对于同一个表的操作，比如 Blog 表，如果在一个namespace 中刷新了缓存，另一个 namespace 中没有刷新，就会出现读到脏数据的情 况。所以，推荐在一个 Mapper 里面只操作单表的情况使用。 </p>
<p>思考：如果要让多个 namespace 共享一个二级缓存，应该怎么做？ 跨 namespace 的缓存共享的问题，可以使用&lt;cache-ref&gt;来解决： </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache-ref</span> <span class="attr">namespace</span>=<span class="string">"com.gupaoedu.crud.dao.DepartmentMapper"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>cache-ref 代表引用别的命名空间的 Cache 配置，两个命名空间的操作使用的是同一个 Cache。在关联的表比较少，或者按照业务可以对表进行分组的时候可以使用。 </p>
<p>注意：在这种情况下，多个 Mapper 的操作都会引起缓存刷新，缓存的意义已经不大了。 </p>
<h5 id="第三方缓存做二级缓存"><a href="#第三方缓存做二级缓存" class="headerlink" title="第三方缓存做二级缓存"></a><strong>第三方缓存做二级缓存</strong></h5><p>除了 MyBatis 自带的二级缓存之外，我们也可以通过实现 Cache 接口来自定义二级缓存。</p>
<p>MyBatis 官方提供了一些第三方缓存集成方式，比如 ehcache 和 redis： </p>
<p><a href="https://github.com/mybatis/redis-cache" target="_blank" rel="noopener">https://github.com/mybatis/redis-cache</a> </p>
<p>pom 文件引入依赖： </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-beta2<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Mapper.xml 配置，type 使用 RedisCache：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">"org.mybatis.caches.redis.RedisCache"</span> <span class="attr">eviction</span>=<span class="string">"FIFO"</span> <span class="attr">flushInterval</span>=<span class="string">"60000"</span> <span class="attr">size</span>=<span class="string">"512"</span> <span class="attr">readOnly</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>redis.properties 配置： </p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">host</span>=<span class="string">localhost </span></span><br><span class="line"><span class="attr">port</span>=<span class="string">6379 </span></span><br><span class="line"><span class="attr">connectionTimeout</span>=<span class="string">5000 </span></span><br><span class="line"><span class="attr">soTimeout</span>=<span class="string">5000 database=0</span></span><br></pre></td></tr></table></figure>

<p>Redis 作为二级缓存的验证： </p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg2mdnianvj313k0i2n74.jpg" alt="image-20200623230224583"></p>
<p>当然，我们也可以使用独立的缓存服务，不使用 MyBatis 自带的二级缓存。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shoufengsfsf.github.io/2020/06/22/mybatis%E5%BA%94%E7%94%A8%E5%88%86%E6%9E%90%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shoufeng">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shoufengsfsf.github.io">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/22/mybatis%E5%BA%94%E7%94%A8%E5%88%86%E6%9E%90%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">mybatis应用分析与最佳实践</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-22 18:20:22" itemprop="dateCreated datePublished" datetime="2020-06-22T18:20:22+08:00">2020-06-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-23 23:19:07" itemprop="dateModified" datetime="2020-06-23T23:19:07+08:00">2020-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mybatis%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">mybatis源码解读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="mybatis应用分析与最佳实践"><a href="#mybatis应用分析与最佳实践" class="headerlink" title="mybatis应用分析与最佳实践"></a>mybatis应用分析与最佳实践</h1><h2 id="1-为什么要用-MyBatis"><a href="#1-为什么要用-MyBatis" class="headerlink" title="1.为什么要用 MyBatis"></a>1.为什么要用 MyBatis</h2><h3 id="JDBC-连接数据库"><a href="#JDBC-连接数据库" class="headerlink" title="JDBC 连接数据库"></a>JDBC 连接数据库</h3><p>在 Java 程序里面去连接数据库，最原始的办法是使用 JDBC 的 API。我们先来回顾 一下使用 JDBC 的方式，我们是怎么操作数据库的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册 JDBC 驱动</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>); <span class="comment">// 打开连接</span></span><br><span class="line">conn = DriverManager.getConnection(DB_URL, USER, PASSWORD);</span><br><span class="line"><span class="comment">// 执行查询</span></span><br><span class="line">stmt = conn.createStatement();</span><br><span class="line">String sql= <span class="string">"SELECT bid, name, author_id FROM blog"</span>; ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line"><span class="comment">// 获取结果集</span></span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line"><span class="keyword">int</span> bid = rs.getInt(<span class="string">"bid"</span>);</span><br><span class="line">String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">String authorId = rs.getString(<span class="string">"author_id"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>我们在 maven 中引入 MySQL 驱动的依赖(JDBC 的包在 java.sql 中)。</p>
</li>
<li><p>注册驱动，第二步，通过 DriverManager 获取一个 Connection，参数里 面填数据库地址，用户名和密码。</p>
</li>
<li><p>我们通过 Connection 创建一个 Statement 对象。</p>
</li>
<li><p>通过 Statement 的 execute()方法执行 SQL。当然 Statement 上面定义了 非常多的方法。execute()方法返回一个 ResultSet 对象，我们把它叫做结果集。</p>
</li>
<li><p>我们通过 ResultSet 获取数据。转换成一个 POJO 对象。</p>
</li>
<li><p>我们要关闭数据库相关的资源，包括 ResultSet、Statement、Connection， 它们的关闭顺序和打开的顺序正好是相反的。</p>
</li>
</ol>
<p>这个就是我们通过 JDBC 的 API 去操作数据库的方法，这个仅仅是一个查询。如果 我们项目当中的业务比较复杂，表非常多，各种操作数据库的增删改查的方法也比较多 的话，那么这样代码会重复出现很多次。</p>
<p>在每一段这样的代码里面，我们都需要自己去管理数据库的连接资源，如果忘记写 close()了，就可能会造成数据库服务连接耗尽。</p>
<p>另外还有一个问题就是处理业务逻辑和处理数据的代码是耦合在一起的。如果业务 流程复杂，跟数据库的交互次数多，耦合在代码里面的 SQL 语句就会非常多。如果要修改业务逻辑，或者修改数据库环境(因为不同的数据库 SQL 语法略有不同)，这个工作 量是也是难以估计的。</p>
<p>还有就是对于结果集的处理，我们要把 ResultSet 转换成 POJO 的时候，必须根据 字段属性的类型一个个地去处理，写这样的代码是非常枯燥的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bid = rs.getInt(<span class="string">"bid"</span>);</span><br><span class="line">String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">String authorId = rs.getString(<span class="string">"author_id"</span>); blog.setAuthorId(authorId); blog.setBid(bid);</span><br><span class="line">blog.setName(name);</span><br></pre></td></tr></table></figure>

<p>也正是因为这样，我们在实际工作中是比较少直接使用 JDBC 的。那么我们在 Java 程序里面有哪些更加简单的操作数据库的方式呢?</p>
<h3 id="Apache-DbUtils"><a href="#Apache-DbUtils" class="headerlink" title="Apache DbUtils"></a>Apache DbUtils</h3><p><a href="https://commons.apache.org/proper/commons-dbutils/" target="_blank" rel="noopener">https://commons.apache.org/proper/commons-dbutils/</a></p>
<p>DbUtils 解决的最核心的问题就是结果集的映射，可以把 ResultSet 封装成 JavaBean。它是怎么做的呢?</p>
<p>首先 DbUtils 提供了一个 QueryRunner 类，它对数据库的增删改查的方法进行了封 装，那么我们操作数据库就可以直接使用它提供的方法。</p>
<p>在 QueryRunner 的构造函数里面，我们又可以传入一个数据源，比如在这里我们 Hikari，这样我们就不需要再去写各种创建和释放连接的代码了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queryRunner = <span class="keyword">new</span> QueryRunner(dataSource);</span><br></pre></td></tr></table></figure>

<p>那我们怎么把结果集转换成对象呢?比如实体类 Bean 或者 List 或者 Map?在DbUtils 里面提供了一系列的支持泛型的 ResultSetHandler。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg1fdwe62gj30dk0jgn63.jpg" alt="image-20200622221548876"></p>
<p>我们只要在 DAO 层调用 QueryRunner 的查询方法，传入这个 Handler，它就可以 自动把结果集转换成实体类 Bean 或者 List 或者 Map。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"select * from blog"</span>;</span><br><span class="line">List&lt;BlogDto&gt; list = queryRunner.query(sql, <span class="keyword">new</span> BeanListHandler&lt;&gt;(BlogDto<span class="class">.<span class="keyword">class</span>))</span>;</span><br></pre></td></tr></table></figure>

<p>没有用过 DbUtils 的同学，可以思考一下通过结果集到实体类的映射是怎么实现的? 也就是说，我只传了一个实体类的类型，它怎么知道这个类型有哪些属性，每个属性是 什么类型?然后创建这个对象并且给这些字段赋值的?答案正是反射。</p>
<p>大家也可以去看一下源码映证一下是不是这样。</p>
<p>问题:输出的结果中，authorId 为什么是空的?DbUtils 要求数据库的字段跟对象 的属性名称完全一致，才可以实现自动映射。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BlogDto&#123;bid=<span class="number">3</span>, name=<span class="string">'MyBatis 源码分析'</span>, authorId=<span class="string">'null'</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h3><p>除了 DbUtils 之外，Spring 也对原生的 JDBC 进行了封装，并且给我们提供了一个 模板方法 JdbcTemplate，来简化我们对数据库的操作。</p>
<p>第一个，我们不再需要去关心资源管理的问题。<br>第二个，对于结果集的处理，Spring JDBC 也提供了一个 RowMapper 接口，可以把结果集转换成 Java 对象。<br>看代码:比如我们要把结果集转换成 Employee 对象，就可以针对一个 Employee</p>
<p>创建一个 RowMapper 对象，实现 RowMapper 接口，并且重写 mapRow()方法。我们 在 mapRow()方法里面完成对结果集的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeRowMapper</span> <span class="keyword">implements</span> <span class="title">RowMapper</span> </span>&#123; </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">mapRow</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123; </span><br><span class="line">    Employee employee = <span class="keyword">new</span> Employee(); </span><br><span class="line">    employee.setEmpId(resultSet.getInt(<span class="string">"emp_id"</span>));</span><br><span class="line">    employee.setEmpName(resultSet.getString(<span class="string">"emp_name"</span>)); </span><br><span class="line">    employee.setEmail(resultSet.getString(<span class="string">"emial"</span>));</span><br><span class="line">    <span class="keyword">return</span> employee;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 DAO 层调用的时候就可以传入自定义的 RowMapper 类，最终返回我们需要的 类型。结果集和实体类类型的映射也是自动完成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">query</span><span class="params">(String sql)</span></span>&#123;</span><br><span class="line">  <span class="keyword">new</span> JdbcTemplate( <span class="keyword">new</span> DruidDataSource());</span><br><span class="line">  <span class="keyword">return</span> jdbcTemplate.query(sql,<span class="keyword">new</span> EmployeeRowMapper());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式，我们对于结果集的处理只需要写一次代码，然后在每一个需要映射 的地方传入这个 RowMapper 就可以了，减少了很多的重复代码。</p>
<p>但是还是有问题:每一个实体类对象，都需要定义一个 Mapper，然后要编写每个 字段映射的 getString()、getInt 这样的代码，还增加了类的数量。</p>
<p>所以有没有办法让一行数据的字段，跟实体类的属性自动对应起来，实现自动映射 呢?当然，我们肯定要解决两个问题，一个就是名称对应的问题，从下划线到驼峰命名;</p>
<p>第二个是类型对应的问题，数据库的 JDBC 类型和 Java 对象的类型要匹配起来。 我们可以创建一个 BaseRowMapper<T>，通过反射的方式自动获取所有属性，把</p>
<p>表字段全部赋值到属性。 上面的方法就可以改成:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> jdbcTemplate.query(sql,<span class="keyword">new</span> BaseRowMapper(Employee<span class="class">.<span class="keyword">class</span>))</span>;</span><br></pre></td></tr></table></figure>

<p>这样，我们在使用的时候只要传入我们需要转换的类型就可以了，不用再单独创建一个 RowMapper。</p>
<p>我们来总结一下，DbUtils 和 Spring JDBC，这两个对 JDBC 做了轻量级封装的框架， 或者说工具类里面，都帮助我们解决了一些问题:</p>
<ol>
<li><p>无论是 QueryRunner 还是 JdbcTemplate，都可以传入一个数据源进行初始 化，也就是资源管理这一部分的事情，可以交给专门的数据源组件去做，不用 我们手动创建和关闭;</p>
</li>
<li><p>对操作数据的增删改查的方法进行了封装;</p>
</li>
<li><p>可以帮助我们映射结果集，无论是映射成 List、Map 还是实体类。 </p>
</li>
</ol>
<p>但是还是存在一些缺点:</p>
<ol>
<li><p>SQL 语句都是写死在代码里面的，依旧存在硬编码的问题;</p>
</li>
<li><p>参数只能按固定位置的顺序传入(数组)，它是通过占位符去替换的，</p>
<p>不能自动映射;</p>
</li>
<li><p>在方法里面，可以把结果集映射成实体类，但是不能直接把实体类映射</p>
<p>成数据库的记录(没有自动生成 SQL 的功能);</p>
</li>
<li><p>查询没有缓存的功能。</p>
</li>
</ol>
<h3 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h3><p>要解决这些问题，使用这些工具类还是不够的，要用到我们今天讲的 ORM 框架。 那什么是 ORM?为什么叫 ORM?<br> ORM 的全拼是 Object Relational Mapping，也就是对象与关系的映射，对象是程</p>
<p>序里面的对象，关系是它与数据库里面的数据的关系。也就是说，ORM 框架帮助我们解 决的问题是程序对象和关系型数据库的相互映射的问题。</p>
<p>O:对象——M:映射——R:关系型数据库</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg1fjxgwguj31180gon33.jpg" alt="image-20200622222135430"></p>
<p>今天听课的同学应该有很多同学是用过 Hibernate 或者现在还在用的。Hibernate 是一个很流行的 ORM 框架，2001 年的时候就出了第一个版本。在使用 Hibernate 的时 候，我们需要为实体类建立一些 hbm 的 xml 映射文件(或者类似于@Table 的这样的注 解)。例如:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"cn.gupaoedu.vo.User"</span> <span class="attr">table</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>/&gt;</span> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cellphone"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span>/&gt;</span> <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后通过 Hibernate 提供(session)的增删改查的方法来操作对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建对象</span></span><br><span class="line">User user = <span class="keyword">new</span> User(); </span><br><span class="line">user.setPassword(<span class="string">"123456"</span>); </span><br><span class="line">user.setCellphone(<span class="string">"18166669999"</span>); </span><br><span class="line">user.setUsername(<span class="string">"qingshan"</span>);</span><br><span class="line"><span class="comment">//获取加载配置管理类</span></span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration(); </span><br><span class="line"><span class="comment">//不给参数就默认加载 hibernate.cfg.xml 文件， </span></span><br><span class="line">configuration.configure();</span><br><span class="line"><span class="comment">//创建 Session 工厂对象</span></span><br><span class="line">SessionFactory factory = configuration.buildSessionFactory(); </span><br><span class="line"><span class="comment">//得到 Session 对象</span></span><br><span class="line">Session session = factory.openSession();</span><br><span class="line"><span class="comment">//使用 Hibernate 操作数据库，都要开启事务,得到事务对象</span></span><br><span class="line">Transaction transaction = session.getTransaction();</span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line">transaction.begin();</span><br><span class="line"><span class="comment">//把对象添加到数据库中</span></span><br><span class="line">session.save(user);</span><br><span class="line"><span class="comment">//提交事务 </span></span><br><span class="line">transaction.commit();</span><br><span class="line"><span class="comment">//关闭 </span></span><br><span class="line">Session session.close();</span><br></pre></td></tr></table></figure>

<p>我们操作对象就跟操作数据库的数据一样。Hibernate 的框架会自动帮我们生成 SQL 语句(可以屏蔽数据库的差异)，自动进行映射。这样我们的代码变得简洁了，程序的 可读性也提高了。</p>
<p>但是 Hibernate 在业务复杂的项目中使用也存在一些问题:</p>
<ol>
<li><p>比如使用 get()、save() 、update()对象的这种方式，实际操作的是所有字段，没有办法指定部分字段，换句话说就是不够灵活。</p>
</li>
<li><p>这种自动生成 SQL 的方式，如果我们要去做一些优化的话，是非常困难的，也就是说可能会出现性能比较差的问题。</p>
</li>
<li><p>不支持动态 SQL(比如分表中的表名变化，以及条件、参数)。</p>
</li>
</ol>
<h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><p>“半自动化”的 ORM 框架 MyBatis 就解决了这几个问题。“半自动化”是相对于 Hibernate 的全自动化来说的，也就是说它的封装程度没有 Hibernate 那么高，不会自 动生成全部的 SQL 语句，主要解决的是 SQL 和对象的映射问题。</p>
<p>在 MyBatis 里面，SQL 和代码是分离的，所以会写 SQL 基本上就会用 MyBatis，没有额外的学习成本。</p>
<p>我们来总结一下，MyBatis 的核心特性，或者说它解决的主要问题是什么:</p>
<ol>
<li>使用连接池对连接进行管理</li>
<li>SQL 和代码分离，集中管理</li>
<li>结果集映射</li>
<li>参数映射和动态 SQL</li>
<li>重复 SQL 的提取</li>
<li>缓存管理</li>
<li>插件机制</li>
</ol>
<p>当然，需要明白的是，Hibernate 和 MyBatis 跟 DbUtils、Spring JDBC 一样，都是对 JDBC 的一个封装，我们去看源码，最后一定会看到 Statement 和 ResultSet 这些 对象。</p>
<p>问题来了，我们有这么多的工具和不同的框架，在实际的项目里面应该怎么选择? 在一些业务比较简单的项目中，我们可以使用 Hibernate;<br>如果需要更加灵活的 SQL，可以使用 MyBatis，对于底层的编码，或者性能要求非常高的场合，可以用 JDBC。<br>实际上在我们的项目中，MyBatis 和 Spring JDBC 是可以混合使用的。 当然，我们也根据项目的需求自己写 ORM 框架，就像之前 Tom 老师跟大家讲的手写 ORM 框架一样。</p>
<h2 id="2-MyBatis-实际使用案例"><a href="#2-MyBatis-实际使用案例" class="headerlink" title="2.MyBatis 实际使用案例"></a>2.MyBatis 实际使用案例</h2><h3 id="编程式使用"><a href="#编程式使用" class="headerlink" title="编程式使用"></a>编程式使用</h3><p>大部分时候，我们都是在 Spring 里面去集成 MyBatis。因为 Spring 对 MyBatis 的 一些操作进行的封装，我们不能直接看到它的本质，所以先看下不使用容器的时候，也 就是编程的方式，MyBatis 怎么使用。</p>
<p>先引入 mybatis jar 包。</p>
<p>首先我们要创建一个全局配置文件，这里面是对 MyBatis 的核心行为的控制，比如 mybatis-config.xml。</p>
<p>第二个就是我们的映射器文件，Mapper.xml，通常来说一张表对应一个，我们会在 这个里面配置我们增删改查的 SQL 语句，以及参数和返回的结果集的映射关系。</p>
<p>跟 JDBC 的代码一样，我们要执行对数据库的操作，必须创建一个会话，这个在 MyBatis 里面就是 SqlSession。SqlSession 又是工厂类根据全局配置文件创建的。所以 整个的流程就是这样的(如下代码)。最后我们通过 SqlSession 接口上的方法，传入我 们的 Statement ID 来执行 SQL。这是第一种方式。</p>
<p>这种方式有一个明显的缺点，就是会对 Statement ID 硬编码，而且不能在编译时进 行类型检查，所以通常我们会使用第二种方式，就是定义一个 Mapper 接口的方式。这 个接口全路径必须跟 Mapper.xml 里面的 namespace 对应起来，方法也要跟 Statement ID 一一对应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMapper</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">  InputStream inputStream = Resources.getResourceAsStream(resource); </span><br><span class="line">  SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">  SqlSession session = sqlSessionFactory.openSession(); </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    BlogMapper mapper = session.getMapper(BlogMapper<span class="class">.<span class="keyword">class</span>)</span>; </span><br><span class="line">    Blog blog = mapper.selectBlogById(<span class="number">1</span>); </span><br><span class="line">    System.out.println(blog);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">    session.close();</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个就是我们单独使用 MyBatis 的全部流程。 这个案例非常重要，后面我们讲源码还是基于它。</p>
<h3 id="核心对象的生命周期"><a href="#核心对象的生命周期" class="headerlink" title="核心对象的生命周期"></a>核心对象的生命周期</h3><p>在编程式使用的这个 demo 里面，我们看到了 MyBatis 里面的几个核心对象: SqlSessionFactoryBuiler、SqlSessionFactory、SqlSession 和 Mapper 对象。这几个 核心对象在 MyBatis 的整个工作流程里面的不同环节发挥作用。如果说我们不用容器，自己去管理这些对象的话，我们必须思考一个问题:什么时候创建和销毁这些对象? 在一些分布式的应用里面，多线程高并发的场景中，如果要写出高效的代码，必须</p>
<p>了解这四个对象的生命周期。这四个对象的声明周期的描述在官网上面也可以找到。 <a href="http://www.mybatis.org/mybatis-3/zh/getting-started.html" target="_blank" rel="noopener">http://www.mybatis.org/mybatis-3/zh/getting-started.html</a> 我们从每个对象的作用的角度来理解一下，只有理解了它们是干什么的，才知道什么时候应该创建，什么时候应该销毁。</p>
<p><strong>1)SqlSessionFactoryBuiler</strong></p>
<p>首先是 SqlSessionFactoryBuiler。它是用来构建 SqlSessionFactory 的，而 SqlSessionFactory 只需要一个，所以只要构建了这一个 SqlSessionFactory，它的使命 就完成了，也就没有存在的意义了。所以它的生命周期只存在于方法的局部。</p>
<p><strong>2)SqlSessionFactory</strong></p>
<p>SqlSessionFactory 是用来创建 SqlSession 的，每次应用程序访问数据库，都需要 创建一个会话。因为我们一直有创建会话的需要，所以 SqlSessionFactory 应该存在于 应用的整个生命周期中(作用域是应用作用域)。创建 SqlSession 只需要一个实例来做 这件事就行了，否则会产生很多的混乱，和浪费资源。所以我们要采用单例模式。</p>
<p><strong>3)SqlSession</strong></p>
<p>SqlSession 是一个会话，因为它不是线程安全的，不能在线程间共享。所以我们在 请求开始的时候创建一个 SqlSession 对象，在请求结束或者说方法执行完毕的时候要及时关闭它(一次请求或者操作中)。</p>
<p><strong>4)Mapper</strong></p>
<p>Mapper(实际上是一个代理对象)是从 SqlSession 中获取的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BlogMapper mapper = session.getMapper(BlogMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>它的作用是发送 SQL 来操作数据库的数据。它应该在一个 SqlSession 事务方法之内。</p>
<p>最后总结如下:</p>
<table>
<thead>
<tr>
<th>对象</th>
<th>生命周期</th>
</tr>
</thead>
<tbody><tr>
<td>SqlSessionFactoryBuiler</td>
<td>方法局部(method)</td>
</tr>
<tr>
<td>SqlSessionFactory(单例)</td>
<td>应用级别(application)</td>
</tr>
<tr>
<td>SqlSession</td>
<td>请求和操作(request/method)</td>
</tr>
<tr>
<td>Mapper</td>
<td>方法(method)</td>
</tr>
</tbody></table>
<p>这个就是我们在编程式的使用里面看到的四个对象的生命周期的总结。</p>
<h3 id="核心配置解读"><a href="#核心配置解读" class="headerlink" title="核心配置解读"></a>核心配置解读</h3><p>第一个是 config 文件。大部分时候我们只需要很少的配置就可以让 MyBatis 运行起 来。其实 MyBatis 里面提供的配置项非常多，我们没有配置的时候使用的是系统的默认值。</p>
<h4 id="一级标签"><a href="#一级标签" class="headerlink" title="一级标签"></a>一级标签</h4><h5 id="configuration"><a href="#configuration" class="headerlink" title="configuration"></a>configuration</h5><p>configuration 是整个配置文件的根标签，实际上也对应着 MyBatis 里面最重要的 配置类 Configuration。它贯穿 MyBatis 执行流程的每一个环节。我们打开这个类看一 下，这里面有很多的属性，跟其他的子标签也能对应上。</p>
<p>注意:MyBatis 全局配置文件顺序是固定的，否则启动的时候会报错。 (一级标签要求全部掌握)</p>
<h5 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h5><p>第一个是 properties 标签，用来配置参数信息，比如最常见的数据库连接信息。</p>
<p>为了避免直接把参数写死在 xml 配置文件中，我们可以把这些参数单独放在 properties 文件中，用 properties 标签引入进来，然后在 xml 配置文件中用${}引用就 可以了。</p>
<p>可以用 resource 引用应用里面的相对路径，也可以用 url 指定本地服务器或者网络 的绝对路径。</p>
<p>我们为什么要把这些配置独立出来?有什么好处?或者说，公司的项目在打包的时 候，有没有把 properties 文件打包进去?</p>
<ol>
<li>提取，利于多处引用，维护简单;</li>
<li>把配置文件放在外部，避免修改后重新编译打包，只需要重启应用;</li>
<li>程序和配置分离，提升数据的安全性，比如生产环境的密码只有运维人员掌握。</li>
</ol>
<h5 id="setttings"><a href="#setttings" class="headerlink" title="setttings"></a>setttings</h5><p>setttings 里面是 MyBatis 的一些核心配置，我们最后再看，先看下其他的以及标签。</p>
<h5 id="typeAliases"><a href="#typeAliases" class="headerlink" title="typeAliases"></a>typeAliases</h5><p>TypeAlias 是类型的别名，跟 Linux 系统里面的 alias 一样，主要用来简化全路径类 名的拼写。比如我们的参数类型和返回值类型都可能会用到我们的 Bean，如果每个地方 都配置全路径的话，那么内容就比较多，还可能会写错。</p>
<p>我们可以为自己的 Bean 创建别名，既可以指定单个类，也可以指定一个 package， 自动转换。配置了别名以后，只需要写别名就可以了，比如 com.gupaoedu.domain.Blog 都只要写 blog 就可以了。</p>
<p>MyBatis 里面有系统预先定义好的类型别名，在 TypeAliasRegistry 中。</p>
<h5 id="typeHandlers【重点】"><a href="#typeHandlers【重点】" class="headerlink" title="typeHandlers【重点】"></a>typeHandlers【重点】</h5><p>由于 Java 类型和数据库的 JDBC 类型不是一一对应的(比如 String 与 varchar)， 所以我们把 Java 对象转换为数据库的值，和把数据库的值转换成 Java 对象，需要经过 一定的转换，这两个方向的转换就要用到 TypeHandler。</p>
<p>有的同学可能会有疑问，我没有做任何的配置，为什么实体类对象里面的一个 String 属性，可以保存成数据库里面的 varchar 字段，或者保存成 char 字段?</p>
<p>这是因为 MyBatis 已经内置了很多 TypeHandler(在 type 包下)，它们全部全部 注册在 TypeHandlerRegistry 中，他们都继承了抽象类 BaseTypeHandler，泛型就是要处理的 Java 数据类型。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg1g0h43jkj30eu0d4jza.jpg" alt="image-20200622223731401"></p>
<p>当我们做数据类型转换的时候，就会自动调用对应的 TypeHandler 的方法。</p>
<p>如果我们需要自定义一些类型转换规则，或者要在处理类型的时候做一些特殊的动 作，就可以编写自己的 TypeHandler，跟系统自定义的 TypeHandler 一样，继承抽象类 BaseTypeHandler&lt;T&gt;。有 4 个抽象方法必须实现，我们把它分成两类:</p>
<p>set 方法从 Java 类型转换成 JDBC 类型的，get 方法是从 JDBC 类型转换成 Java 类 型的。</p>
<table>
<thead>
<tr>
<th>从 Java 类型到 JDBC 类型</th>
<th>从 JDBC 类型到 Java 类型</th>
</tr>
</thead>
<tbody><tr>
<td>setNonNullParameter:设置非空参数</td>
<td>getNullableResult:获取空结果集(根据列名)，一般都是调用这个 getNullableResult:获取空结果集(根据下标值) getNullableResult:存储过程用的</td>
</tr>
</tbody></table>
<p>比如我们想要在获取或者设置 String 类型的时候做一些特殊处理，我们可以写一个 String 类型的 TypeHandler(mybatis-standalone 工程)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTypeHandler</span> <span class="keyword">extends</span> <span class="title">BaseTypeHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, String parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 设置 String 类型的参数的时候调用，Java 类型到 JDBC 类型</span></span><br><span class="line">    System.out.println(<span class="string">"---------------setNonNullParameter1:"</span>+parameter);</span><br><span class="line">    ps.setString(i, parameter); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 根据列名获取 String 类型的参数的时候调用，JDBC 类型到 java 类型</span></span><br><span class="line">    System.out.println(<span class="string">"---------------getNullableResult1:"</span>+columnName);</span><br><span class="line">    <span class="keyword">return</span> rs.getString(columnName); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步，在 mybatis-config.xml 文件中注册:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">"com.gupaoedu.type.MyTypeHandler"</span>&gt;</span><span class="tag">&lt;/<span class="name">typeHandler</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第三步，在我们需要使用的字段上指定，比如:插入值的时候，从 Java 类型到 JDBC 类型，在字段属性中指定 typehandler:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span> = <span class="string">"insertBlog"</span> <span class="attr">parameterType</span> = <span class="string">"com.gupaoedu.domain.Blog"</span>&gt;</span> </span><br><span class="line">  insert into blog (bid, name, author_id)</span><br><span class="line">  values (#&#123;bid,jdbcType=INTEGER&#125;,</span><br><span class="line">  #&#123;name,jdbcType=VARCHAR,typeHandler=com.gupaoedu.type.MyTypeHandler&#125;, #&#123;authorId,jdbcType=INTEGER&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>返回值的时候，从 JDBC 类型到 Java 类型，在 resultMap 的列上指定 typehandler:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">typeHandler</span>=<span class="string">"com.gupaoedu.type.MyTypeHandler"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>【思考，不强制要求完成】 </p>
<p>如果我们的对象里面有复杂对象，比如 Blog 里面包括了一个 Comment 对象，这个时候 Comment 对象的全部属性不能直接映射到数据库的一个字段。 </p>
<p>要求：创建一个 TypeHandler，可以将任意的对象转换为 json 字符串，保存到数据库的 VARCHAR 类型中。在从数据库查询的时候，再转换为原来的 Java 对象。 </p>
<ol>
<li><p>在数据库表添加一个 VARCHAR 字段； </p>
</li>
<li><p>在 Blog 对象中添加一个 Comment 属性，字段 Integer id;String content； </p>
</li>
<li><p>JSON 工具没有要求，jackson 或者 fastjson、gson 都可以。 </p>
</li>
<li><p>在查询和插入的 statement 上使用这个 TypeHandler。 </p>
</li>
</ol>
<h5 id="objectFactory【重点】"><a href="#objectFactory【重点】" class="headerlink" title="objectFactory【重点】"></a><strong>objectFactory【重点】</strong></h5><p>当我们把数据库返回的结果集转换为实体类的时候，需要创建对象的实例，由于我们不知道需要处理的类型是什么，有哪些属性，所以不能用 new 的方式去创建。在MyBatis 里面，它提供了一个工厂类的接口，叫做 ObjectFactory，专门用来创建对象的 实例，里面定义了 4 个方法。 </p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg1geydofhj30s0078dmk.jpg" alt="image-20200622225125122"></p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>void</strong> setProperties(Properties properties);</td>
<td>设置参数时调用</td>
</tr>
<tr>
<td>&lt;T&gt; T create(Class&lt;T&gt; type);</td>
<td>创建对象（调用无参构造函数）</td>
</tr>
<tr>
<td>&lt;T&gt; T create(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs);</td>
<td>创建对象（调用带参数构造函数）</td>
</tr>
<tr>
<td>&lt;T&gt; <strong>boolean</strong> isCollection(Class&lt;T&gt; type)</td>
<td>判断是否集合</td>
</tr>
</tbody></table>
<p>ObjectFactory 有一个默认的实现类 DefaultObjectFactory，创建对象的方法最终都调用了 instantiateClass()，是通过反射来实现的。 </p>
<p>如果想要修改对象工厂在初始化实体类的时候的行为，就可以通过创建自己的对象 工厂，继承 DefaultObjectFactory 来实现（不需要再实现 ObjectFactory 接口）。 </p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GPObjectFactory</span> <span class="keyword">extends</span> <span class="title">DefaultObjectFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">create</span><span class="params">(Class type)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (type.equals(Blog<span class="class">.<span class="keyword">class</span>)) </span>&#123; </span><br><span class="line">      Blog blog = (Blog) <span class="keyword">super</span>.create(type); </span><br><span class="line">      blog.setName(<span class="string">"by object factory"</span>); </span><br><span class="line">      blog.setBid(<span class="number">1111</span>); </span><br><span class="line">      blog.setAuthorId(<span class="number">2222</span>); </span><br><span class="line">      <span class="keyword">return</span> blog; </span><br><span class="line">    &#125;</span><br><span class="line">    Object result = <span class="keyword">super</span>.create(type); </span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以直接用自定义的工厂类来创建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectFactoryTest</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    GPObjectFactory factory = <span class="keyword">new</span> GPObjectFactory(); </span><br><span class="line">    Blog myBlog = (Blog) factory.create(Blog<span class="class">.<span class="keyword">class</span>)</span>; </span><br><span class="line">    System.out.println(myBlog); &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就直接拿到了一个对象。 </p>
<p>如果在 config 文件里面注册，在创建对象的时候会被自动调用：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">objectFactory</span> <span class="attr">type</span>=<span class="string">"org.mybatis.example.GPObjectFactory"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 对象工厂注入的参数 --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"gupao"</span> <span class="attr">value</span>=<span class="string">"666"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">objectFactory</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，就可以让 MyBatis 的创建实体类的时候使用我们自己的对象工厂。 </p>
<p>应用场景举例： </p>
<p>比如有一个新锐手机品牌在一个电商平台上面卖货，为了让预约数量好看一点，只要有人预约，预约数量就自动乘以 3。这个时候就可以创建一个 ObjectFactory，只要是查询销量，就把它的预约数乘以 3 返回这个实体类。 被发现后，平台：是程序员干的。</p>
<p>附：</p>
<ol>
<li><p>什么时候调用了 objectFactory.create()？ </p>
<p>创建 DefaultResultSetHandler 的时候，和创建对象的时候。 </p>
</li>
<li><p>创建对象后，已有的属性为什么被覆盖了？ </p>
<p>在 DefaultResultSetHandler 类的 395 行 getRowValue()方法里面里面调用了applyPropertyMappings()。 </p>
</li>
<li><p>返回结果的时候，ObjectFactory 和 TypeHandler 哪个先工作？ </p>
<p>先是 ObjectFactory，再是 TypeHandler。肯定是先创建对象。 </p>
</li>
</ol>
<p>PS：step out 可以看到一步步调用的层级。 </p>
<h5 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a><strong>plugins</strong></h5><p>插件是 MyBatis 的一个很强大的机制，跟很多其他的框架一样，MyBatis 预留了插件的接口，让 MyBatis 更容易扩展。</p>
<p>根据官方的定义，插件可以拦截这四个对象的这些方法，我们把这四个对象称作MyBatis 的四大对象。我们会在带大家阅读源码，知道了这 4 大对象的作用之后，再来分析自定义插件的开发和插件运行的原理。 </p>
<p><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#plugins" target="_blank" rel="noopener">http://www.mybatis.org/mybatis-3/zh/configuration.html#plugins</a></p>
<table>
<thead>
<tr>
<th><strong>类（或接口）</strong></th>
<th><strong>方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Executor</td>
<td>update, query, flushStatements, commit, rollback, getTransaction, close, isClosed</td>
</tr>
<tr>
<td>ParameterHandler</td>
<td>getParameterObject, setParameters</td>
</tr>
<tr>
<td>ResultSetHandler</td>
<td>handleResultSets, handleOutputParameters</td>
</tr>
<tr>
<td>StatementHandler</td>
<td>prepare, parameterize, batch, update, query</td>
</tr>
</tbody></table>
<h5 id="environments、environment"><a href="#environments、environment" class="headerlink" title="environments、environment"></a><strong>environments、environment</strong></h5><p>environments 标签用来管理数据库的环境，比如我们可以有开发环境、测试环境、生产环境的数据库。可以在不同的环境中使用不同的数据库地址或者类型。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://127.0.0.1:3306/gp-mybatis?useUnicode=true"</span>/&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">environment</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一个 environment 标签就是一个数据源，代表一个数据库。这里面有两个关键的标 签，一个是事务管理器，一个是数据源。 </p>
<h5 id="transactionManager"><a href="#transactionManager" class="headerlink" title="transactionManager"></a><strong>transactionManager</strong></h5><p>如果配置的是 JDBC，则会使用 Connection 对象的 commit()、rollback()、close() 管理事务。</p>
<p>如果配置成 MANAGED，会把事务交给容器来管理，比如 JBOSS，Weblogic。因为我们跑的是本地程序，如果配置成 MANAGE 不会有任何事务。 </p>
<p>如 果 是 Spring + MyBatis ， 则 没 有 必 要 配 置 ， 因 为 我 们 会 直 接 在applicationContext.xml 里面配置数据源，覆盖 MyBatis 的配置。</p>
<h5 id="dataSource"><a href="#dataSource" class="headerlink" title="dataSource"></a><strong>dataSource</strong></h5><p>将在下一节（settings）详细分析。在跟 Spring 集成的时候，事务和数据源都会交给 Spring 来管理。</p>
<h5 id="mappers"><a href="#mappers" class="headerlink" title="mappers"></a><strong>mappers</strong></h5><p>&lt;mappers&gt;标签配置的是我们的映射器，也就是 Mapper.xml 的路径。这里配置的 </p>
<p>目的是让 MyBatis 在启动的时候去扫描这些映射器，创建映射关系。 </p>
<p>我们有四种指定 Mapper 文件的方式： </p>
<p><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#mappers" target="_blank" rel="noopener">http://www.mybatis.org/mybatis-3/zh/configuration.html#mappers</a> </p>
<ol>
<li><p>使用相对于类路径的资源引用（resource） </p>
</li>
<li><p>使用完全限定资源定位符（绝对路径）（URL） </p>
</li>
<li><p>使用映射器接口实现类的完全限定类名 </p>
</li>
<li><p>将包内的映射器接口实现全部注册为映射器（最常用） </p>
</li>
</ol>
<p>思考：</p>
<p>接口跟 statement 是怎么绑定起来的？——method 有方法全限定名，比如： com.gupaoedu.mapper.BlogMapper.selectBlogById ， 跟 namespace 里 面 的 statement ID 是相同的。 </p>
<p>在哪一步拿到 SQL 的？——ms 里面有 SQL。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultSqlSession. selectList() </span></span><br><span class="line">MappedStatement ms = configuration.getMappedStatement(statement);</span><br></pre></td></tr></table></figure>

<h5 id="settings"><a href="#settings" class="headerlink" title="settings"></a><strong>settings</strong></h5><p>最后 settings 我们来单独说一下，因为 MyBatis 的一些最关键的配置都在这个标签里面（只讲解一些主要的）。</p>
<table>
<thead>
<tr>
<th><strong>属性名</strong></th>
<th><strong>含义</strong></th>
<th><strong>简介</strong></th>
<th><strong>有效值</strong></th>
<th><strong>默认值</strong></th>
</tr>
</thead>
<tbody><tr>
<td>cacheEnabled</td>
<td>是否使用缓存</td>
<td>是整个工程中所有映射器配置缓存的 开关，即是一个全局缓存开关</td>
<td>true/false</td>
<td>true</td>
</tr>
<tr>
<td>lazyLoadingEnabled</td>
<td>是否开启延迟加载</td>
<td>控制全局是否使用延迟加载 （association、collection）。当有特殊关联关系需要单独配置时，可以使用 fetchType 属性来覆盖此配置</td>
<td>true/false</td>
<td>false</td>
</tr>
<tr>
<td>aggressiveLazyLoading</td>
<td>是否需要侵入式延迟加载</td>
<td>开启时，无论调用什么方法加载某个对 象，都会加载该对象的所有属性，关闭之后只会按需加载</td>
<td>true/false</td>
<td>false</td>
</tr>
<tr>
<td>defaultExecutorType</td>
<td>设置默认的执行器</td>
<td>有三种执行器：SIMPLE 为普通执行器； REUSE 执行器会重用与处理语句；BATCH 执行器将重用语句并执行批量更新</td>
<td>SIMPLE/REUSE/BATCH</td>
<td>SIMPLE</td>
</tr>
<tr>
<td>lazyLoadTriggerMeth ods</td>
<td>指定哪个对象的方 法触发一次延迟加载</td>
<td>配置需要触发延迟加载的方法的名字， 该方法就会触发一次延迟加载</td>
<td>一个逗号分隔的方 法名称列表</td>
<td>equals， clone，hashCode，toString</td>
</tr>
<tr>
<td>localCacheScope</td>
<td>MyBatis 利用本地 缓存机制（Local Cache）防止循环引 用（circular references）和加 速重复嵌套查询</td>
<td>默认值为 SESSION，这种情况下会缓存 一个会话中执行的所有查询。若设置值 为 STATEMENT，本地会话仅用在语句执 行上，对相同 SqlSession 的不同调用 将不会共享数据</td>
<td>SESSION/STATEMENT</td>
<td>SESSION</td>
</tr>
<tr>
<td>logImpl</td>
<td>日志实现</td>
<td>指定 MyBatis 所用日志的具体实现，未 指定时将自动查找</td>
<td>SLF4J、LOG4J、 LOG4J2、 JDK_LOGGING、 COMMONS_LOGGING、 STDOUT_LOGGING、 NO_LOGGING</td>
<td>无</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="Mapper-xml-映射配置文件【重点】"><a href="#Mapper-xml-映射配置文件【重点】" class="headerlink" title="Mapper.xml 映射配置文件【重点】"></a><strong>Mapper.xml 映射配置文件【重点】</strong></h5><p><a href="http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html" target="_blank" rel="noopener">http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html</a> </p>
<p>映射器里面最主要的是配置了 SQL 语句，也解决了我们的参数映射和结果集映射的 问题。</p>
<p>一共有 8 个标签： </p>
<p>cache – 给定命名空间的缓存配置（是否开启二级缓存）。 </p>
<p>cache-ref – 其他命名空间缓存配置的引用。这两个标签我们在讲解缓存的时候会详细讲到。</p>
<p>resultMap – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id=<span class="string">"BaseResultMap"</span> type=<span class="string">"Employee"</span>&gt; </span><br><span class="line">  &lt;id column=<span class="string">"emp_id"</span> jdbcType=<span class="string">"INTEGER"</span> property=<span class="string">"empId"</span>/&gt; </span><br><span class="line">  &lt;result column=<span class="string">"emp_name"</span> jdbcType=<span class="string">"VARCHAR"</span> property=<span class="string">"empName"</span>/&gt; </span><br><span class="line">  &lt;result column=<span class="string">"gender"</span> jdbcType=<span class="string">"CHAR"</span> property=<span class="string">"gender"</span>/&gt; </span><br><span class="line">  &lt;result column=<span class="string">"email"</span> jdbcType=<span class="string">"VARCHAR"</span> property=<span class="string">"email"</span>/&gt; </span><br><span class="line">  &lt;result column=<span class="string">"d_id"</span> jdbcType=<span class="string">"INTEGER"</span> property=<span class="string">"dId"</span>/&gt; </span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>

<p>sql – 可被其他语句引用的可重用语句块。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;sql id="Base_Column_List"&gt; emp_id, emp_name, gender, email, d_id &lt;/sql&gt;</span><br></pre></td></tr></table></figure>

<p>增删改查标签： </p>
<p>insert – 映射插入语句 </p>
<p>update – 映射更新语句 </p>
<p>delete – 映射删除语句 </p>
<p>select – 映射查询语句</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h5><p>最后我们来总结一下：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg1h99a6lqj31f00lwn5c.jpg" alt="image-20200622232033369"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg1h9gflm6j31eg0ci43q.jpg" alt="image-20200622232045602"></p>
<h2 id="3-MyBatis-最佳实践"><a href="#3-MyBatis-最佳实践" class="headerlink" title="3.MyBatis 最佳实践"></a><strong>3.MyBatis 最佳实践</strong></h2><p>以下是一些 MyBatis 的高级用法或者扩展方式，帮助我们更好地使用 MyBatis。 </p>
<h3 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a><strong>动态 SQL</strong></h3><h4 id="为什么需要动态-SQL？"><a href="#为什么需要动态-SQL？" class="headerlink" title="为什么需要动态 SQL？"></a><strong>为什么需要动态 SQL？</strong></h4><p>由于前台传入的查询参数不同，所以写了很多的 if else，还需要非常注意 SQL 语句里面的 and、空格、逗号和转移的单引号这些，拼接和调试 SQL 就是一件非常耗时的工作。</p>
<p>MyBaits 的动态 SQL 就帮助我们解决了这个问题，它是基于 OGNL 表达式的。</p>
<h4 id="动态标签有哪些？"><a href="#动态标签有哪些？" class="headerlink" title="动态标签有哪些？"></a><strong>动态标签有哪些？</strong></h4><p>按照官网的分类，MyBatis 的动态标签主要有四类：if，choose (when, otherwise)， trim (where, set)，foreach。</p>
<p>（案例在 spring-mybatis 工程中） </p>
<p>if —— 需要判断的时候，条件写在 test 中 </p>
<p>以下语句可以用&lt;where&gt;改写 </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectDept"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"com.gupaoedu.crud.bean.Department"</span>&gt;</span> </span><br><span class="line">  select * from tbl_dept where 1=1 </span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"deptId != null"</span>&gt;</span> </span><br><span class="line">    and dept_id = #&#123;deptId,jdbcType=INTEGER&#125; </span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>choose (when, otherwise) —— 需要选择一个条件的时候</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpList_choose"</span> <span class="attr">resultMap</span>=<span class="string">"empResultMap"</span> <span class="attr">parameterType</span>=<span class="string">"com.gupaoedu.crud.bean.Employee"</span>&gt;</span> </span><br><span class="line">  SELECT * FROM tbl_emp e </span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">choose</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"empId !=null"</span>&gt;</span> </span><br><span class="line">        e.emp_id = #&#123;emp_id, jdbcType=INTEGER&#125; </span><br><span class="line">      <span class="tag">&lt;/<span class="name">when</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"empName != null and empName != ''"</span>&gt;</span> </span><br><span class="line">        AND e.emp_name LIKE CONCAT(CONCAT('%', #&#123;emp_name, jdbcType=VARCHAR&#125;),'%') </span><br><span class="line">      <span class="tag">&lt;/<span class="name">when</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"email != null "</span>&gt;</span> AND e.email = #&#123;email, jdbcType=VARCHAR&#125; </span><br><span class="line">      <span class="tag">&lt;/<span class="name">when</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">choose</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>trim (where, set)——需要去掉 where、and、逗号之类的符号的时候。 </p>
<p>注意最后一个条件 dId 多了一个逗号，就是用 trim 去掉的：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateByPrimaryKeySelective"</span> <span class="attr">parameterType</span>=<span class="string">"com.gupaoedu.crud.bean.Employee"</span>&gt;</span> </span><br><span class="line">  update tbl_emp</span><br><span class="line">  <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"empName != null"</span>&gt;</span> </span><br><span class="line">      emp_name = #&#123;empName,jdbcType=VARCHAR&#125;, </span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gender != null"</span>&gt;</span> </span><br><span class="line">      gender = #&#123;gender,jdbcType=CHAR&#125;, </span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email != null"</span>&gt;</span> </span><br><span class="line">      email = #&#123;email,jdbcType=VARCHAR&#125;,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"dId != null"</span>&gt;</span> </span><br><span class="line">      d_id = #&#123;dId,jdbcType=INTEGER&#125;, </span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">set</span>&gt;</span> </span><br><span class="line">  where emp_id = #&#123;empId,jdbcType=INTEGER&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>trim 用来指定或者去掉前缀或者后缀：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertSelective"</span> <span class="attr">parameterType</span>=<span class="string">"com.gupaoedu.crud.bean.Employee"</span>&gt;</span> </span><br><span class="line">  insert into tbl_emp </span><br><span class="line">  <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"("</span> <span class="attr">suffix</span>=<span class="string">")"</span> <span class="attr">suffixOverrides</span>=<span class="string">","</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"empId != null"</span>&gt;</span> </span><br><span class="line">      emp_id, </span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"empName != null"</span>&gt;</span> </span><br><span class="line">      emp_name, </span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"dId != null"</span>&gt;</span> </span><br><span class="line">      d_id, </span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">trim</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"values ("</span> <span class="attr">suffix</span>=<span class="string">")"</span> <span class="attr">suffixOverrides</span>=<span class="string">","</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"empId != null"</span>&gt;</span> </span><br><span class="line">      #&#123;empId,jdbcType=INTEGER&#125;, </span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"empName != null"</span>&gt;</span> </span><br><span class="line">      #&#123;empName,jdbcType=VARCHAR&#125;, </span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"dId != null"</span>&gt;</span> </span><br><span class="line">      #&#123;dId,jdbcType=INTEGER&#125;, </span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">trim</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>foreach —— 需要遍历集合的时候：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteByList"</span> <span class="attr">parameterType</span>=<span class="string">"java.util.List"</span>&gt;</span> </span><br><span class="line">  delete from tbl_emp where emp_id in </span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">close</span>=<span class="string">")"</span>&gt;</span> </span><br><span class="line">    #&#123;item.empId,jdbcType=VARCHAR&#125; </span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>动态 SQL 主要是用来解决 SQL 语句生成的问题。</p>
<h3 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a><strong>批量操作</strong></h3><p>（spring-mybatis 工程单元测试目录，MapperTest 类） </p>
<p>我们在生产的项目中会有一些批量操作的场景，比如导入文件批量处理数据的情况 （批量新增商户、批量修改商户信息），当数据量非常大，比如超过几万条的时候，在 Java 代码中循环发送 SQL 到数据库执行肯定是不现实的，因为这个意味着要跟数据库创建几万次会话，即使我们使用了数据库连接池技术，对于数据库服务器来说也是不堪重 负的。</p>
<p>在 MyBatis 里面是支持批量的操作的，包括批量的插入、更新、删除。我们可以直接传入一个 List、Set、Map 或者数组，配合动态 SQL 的标签，MyBatis 会自动帮我们 生成语法正确的 SQL 语句。 </p>
<p>比如我们来看两个例子，批量插入和批量更新。 </p>
<h4 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a><strong>批量插入</strong></h4><p>批量插入的语法是这样的，只要在 values 后面增加插入的值就可以了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tbl_emp (emp_id, emp_name, gender,email, d_id) <span class="keyword">values</span> ( ?,?,?,?,? ) , ( ?,?,?,?,? ) , ( ?,?,?,?,? ) , ( ?,?,?,?,? ) , ( ?,?,?,?,? ) , ( ?,?,?,?,? ) , ( ?,?,?,?,? ) , ( ?,?,?,?,? ) , ( ?,?,?,?,? ) , ( ?,?,?,?,? )</span><br></pre></td></tr></table></figure>

<p>在 Mapper 文件里面，我们使用 foreach 标签拼接 values 部分的语句：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 批量插入 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"batchInsert"</span> <span class="attr">parameterType</span>=<span class="string">"java.util.List"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">resultType</span>=<span class="string">"long"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">order</span>=<span class="string">"AFTER"</span>&gt;</span> </span><br><span class="line">    SELECT LAST_INSERT_ID() </span><br><span class="line">  <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span> </span><br><span class="line">  insert into tbl_emp (emp_id, emp_name, gender,email, d_id) values </span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"emps"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span> </span><br><span class="line">    ( #&#123;emps.empId&#125;,#&#123;emps.empName&#125;,#&#123;emps.gender&#125;,#&#123;emps.email&#125;,#&#123;emps.dId&#125; ) </span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Java 代码里面，直接传入一个 List 类型的参数。 </p>
<p>我们来测试一下。效率要比循环发送 SQL 执行要高得多。最关键的地方就在于减少了跟数据库交互的次数，并且避免了开启和结束事务的时间消耗。 </p>
<h4 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a><strong>批量更新</strong></h4><p>批量更新的语法是这样的，通过 case when，来匹配 id 相关的字段值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tbl_emp </span><br><span class="line"><span class="keyword">set</span> </span><br><span class="line">emp_name = <span class="keyword">case</span> emp_id </span><br><span class="line"><span class="keyword">when</span> ? <span class="keyword">then</span> ? </span><br><span class="line"><span class="keyword">when</span> ? <span class="keyword">then</span> ? </span><br><span class="line"><span class="keyword">when</span> ? <span class="keyword">then</span> ? <span class="keyword">end</span> , </span><br><span class="line">gender =<span class="keyword">case</span> emp_id </span><br><span class="line"><span class="keyword">when</span> ? <span class="keyword">then</span> ? </span><br><span class="line"><span class="keyword">when</span> ? <span class="keyword">then</span> ? </span><br><span class="line"><span class="keyword">when</span> ? <span class="keyword">then</span> ? <span class="keyword">end</span> , </span><br><span class="line">email = <span class="keyword">case</span> emp_id </span><br><span class="line"><span class="keyword">when</span> ? <span class="keyword">then</span> ? </span><br><span class="line"><span class="keyword">when</span> ? <span class="keyword">then</span> ? </span><br><span class="line"><span class="keyword">when</span> ? <span class="keyword">then</span> ? <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">where</span> emp_id <span class="keyword">in</span> ( ? , ? , ? )</span><br></pre></td></tr></table></figure>

<p>所以在 Mapper 文件里面最关键的就是 case when 和 where 的配置。</p>
<p>需要注意一下 open 属性和 separator 属性。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateBatch"</span>&gt;</span> </span><br><span class="line">  update tbl_emp set emp_name = </span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"emps"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">separator</span>=<span class="string">" "</span> <span class="attr">open</span>=<span class="string">"case emp_id"</span> <span class="attr">close</span>=<span class="string">"end"</span>&gt;</span> </span><br><span class="line">    when #&#123;emps.empId&#125; then #&#123;emps.empName&#125; </span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span> </span><br><span class="line">  ,gender = </span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"emps"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">separator</span>=<span class="string">" "</span> <span class="attr">open</span>=<span class="string">"case emp_id"</span> <span class="attr">close</span>=<span class="string">"end"</span>&gt;</span> </span><br><span class="line">    when #&#123;emps.empId&#125; then #&#123;emps.gender&#125; </span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span> </span><br><span class="line">  ,email = </span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"emps"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">separator</span>=<span class="string">" "</span> <span class="attr">open</span>=<span class="string">"case emp_id"</span> <span class="attr">close</span>=<span class="string">"end"</span>&gt;</span> </span><br><span class="line">    when #&#123;emps.empId&#125; then #&#123;emps.email&#125; </span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span> </span><br><span class="line">  where emp_id in </span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"emps"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">close</span>=<span class="string">")"</span>&gt;</span></span><br><span class="line">    #&#123;emps.empId&#125; </span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>批量删除也是类似的。 </p>
<h4 id="Batch-Executor"><a href="#Batch-Executor" class="headerlink" title="Batch Executor"></a><strong>Batch Executor</strong></h4><p>当然 MyBatis 的动态标签的批量操作也是存在一定的缺点的，比如数据量特别大的时候，拼接出来的 SQL 语句过大。 </p>
<p>MySQL 的服务端对于接收的数据包有大小限制，max_allowed_packet 默认是4M，需要修改默认配置才可以解决这个问题。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.mysql.jdbc.PacketTooBigException: <span class="function">Packet <span class="keyword">for</span> query is too <span class="title">large</span> <span class="params">(<span class="number">7188967</span> &gt; <span class="number">4194304</span>)</span>. You can change <span class="keyword">this</span> value on the server by setting the max_allowed_packet' variable.</span></span><br></pre></td></tr></table></figure>

<p>在我们的全局配置文件中，可以配置默认的 Executor 的类型。其中有一种BatchExecutor。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultExecutorType"</span> <span class="attr">value</span>=<span class="string">"BATCH"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以在创建会话的时候指定执行器类型： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession(ExecutorType.BATCH);</span><br></pre></td></tr></table></figure>

<p>BatchExecutor 底层是对 JDBC ps.addBatch()的封装，原理是攒一批 SQL 以后再发 送（参考 standalone - 单元测试目录 JdbcTest.java – testJdbcBatch()）。 </p>
<p>问题：三种执行器的区别是什么？Simple、Reuse、Batch </p>
<h4 id="嵌套（关联）查询-N-1-延迟加载"><a href="#嵌套（关联）查询-N-1-延迟加载" class="headerlink" title="嵌套（关联）查询/ N+1 / 延迟加载"></a><strong>嵌套（关联）查询/ N+1 / 延迟加载</strong></h4><p>我们在查询业务数据的时候经常会遇到跨表关联查询的情况，比如查询员工就会关 联部门（一对一），查询成绩就会关联课程（一对一），查询订单就会关联商品（一对 多），等等。 </p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg1hw2a9v7j31b60qegv7.jpg" alt="image-20200622234226756"></p>
<p>我们映射结果有两个标签，一个是 resultType，一个是 resultMap。 </p>
<p>resultType 是 select 标签的一个属性，适用于返回 JDK 类型（比如 Integer、String 等等）和实体类。这种情况下结果集的列和实体类的属性可以直接映射。如果返回的字段无法直接映射，就要用 resultMap 来建立映射关系。 </p>
<p>对于关联查询的这种情况，通常不能用 resultType 来映射。用 resultMap 映射，要么就是修改 dto（Data Transfer Object），在里面增加字段，这个会导致增加很多无关 的字段。要么就是引用关联的对象，比如 Blog 里面包含了一个 Author 对象，这种情况下就要用到关联查询（association，或者嵌套查询），MyBatis 可以帮我们自动做结果 的映射。</p>
<p>一对一的关联查询有两种配置方式： </p>
<p>1、嵌套结果：</p>
<p>（mybatis-standalone - MyBatisTest - testSelectBlogWithAuthorResult ()）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 根据文章查询作者，一对一查询的结果，嵌套查询 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BlogWithAuthorResultMap"</span> <span class="attr">type</span>=<span class="string">"com.gupaoedu.domain.associate.BlogAndAuthor"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"bid"</span> <span class="attr">property</span>=<span class="string">"bid"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span>/&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span>/&gt;</span> </span><br><span class="line">  <span class="comment">&lt;!-- 联合查询，将 author 的属性映射到 ResultMap --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"author"</span> <span class="attr">javaType</span>=<span class="string">"com.gupaoedu.domain.Author"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"author_id"</span> <span class="attr">property</span>=<span class="string">"authorId"</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"author_name"</span> <span class="attr">property</span>=<span class="string">"authorName"</span>/&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">association</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、嵌套查询： </p>
<p>（mybatis-standalone - MyBatisTest - testSelectBlogWithAuthorQuery ()）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 另一种联合查询 (一对一)的实现，但是这种方式有“N+1”的问题 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BlogWithAuthorQueryMap"</span> <span class="attr">type</span>=<span class="string">"com.gupaoedu.domain.associate.BlogAndAuthor"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"bid"</span> <span class="attr">property</span>=<span class="string">"bid"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span>/&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span>/&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"author"</span> <span class="attr">javaType</span>=<span class="string">"com.gupaoedu.domain.Author"</span> <span class="attr">column</span>=<span class="string">"author_id"</span> <span class="attr">select</span>=<span class="string">"selectAuthor"</span>/&gt;</span> </span><br><span class="line">  <span class="comment">&lt;!-- selectAuthor 定义在下面--&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 嵌套查询 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectAuthor"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"com.gupaoedu.domain.Author"</span>&gt;</span> </span><br><span class="line">  select author_id authorId, author_name authorName from author where author_id = #&#123;authorId&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中第二种方式：嵌套查询，由于是分两次查询，当我们查询了员工信息之后，会再发送一条 SQL 到数据库查询部门信息。 </p>
<p>我们只执行了一次查询员工信息的 SQL（所谓的 1），如果返回了 N 条记录，就会再发送 N 条到数据库查询部门信息（所谓的 N），这个就是我们所说的 N+1 的问题。 </p>
<p>这样会白白地浪费我们的应用和数据库的性能。 </p>
<p>如果我们用了嵌套查询的方式，怎么解决这个问题？能不能等到使用部门信息的时 候再去查询？这个就是我们所说的延迟加载，或者叫懒加载。 </p>
<p>在 MyBatis 里面可以通过开启延迟加载的开关来解决这个问题。 </p>
<p>在 settings 标签里面可以配置： </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。默认 false --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--当开启时，任何方法的调用都会加载该对象的所有属性。默认 false，可通过 select 标签的 fetchType 来覆盖--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- Mybatis 创建具有延迟加载能力的对象所用到的代理工具，默认 JAVASSIST --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"proxyFactory"</span> <span class="attr">value</span>=<span class="string">"CGLIB"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>lazyLoadingEnabled 决定了是否延迟加载。 </p>
<p>aggressiveLazyLoading 决定了是不是对象的所有方法都会触发查询。 </p>
<p>先来测试一下（也可以改成查询列表）： </p>
<ol>
<li><p>没有开启延迟加载的开关，会连续发送两次查询； </p>
</li>
<li><p>开 启 了 延 迟 加 载 的 开 关 ， 调 用 blog.getAuthor() 以 及 默 认 的（equals,clone,hashCode,toString）时才会发起第二次查询，其他方法并不会触发查询，比如 blog.getName()；</p>
</li>
<li><p>如果开启了 aggressiveLazyLoading=true，其他方法也会触发查询，比如blog.getName()。 </p>
</li>
</ol>
<p>问题：为什么可以做到延迟加载？blog.getAuthor()，只是一个获取属性的方法，里面并没有连接数据库的代码，为什么会触发对数据库的查询呢？ </p>
<p>我怀疑：blog 根本不是 Blog 对象，而是被人动过了手脚！ </p>
<p>把这个对象打印出来看看： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(blog.getClass());</span><br></pre></td></tr></table></figure>

<p>果然不对： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">gupaoedu</span>.<span class="title">domain</span>.<span class="title">associate</span>.<span class="title">BlogAndAuthor_</span>$$<span class="title">_jvst70_0</span></span></span><br></pre></td></tr></table></figure>

<p>这个类的名字后面有 jvst，是 JAVASSIST 的缩写。原来到这里带延迟加载功能的对象 blog 已经变成了一个代理对象，那到底什么时候变成代理对象的？我们后面在看源码的时候再去分析，这个也先留一个作业给大家。 </p>
<p>【问题】当开启了延迟加载的开关，对象是怎么变成代理对象的？ </p>
<p>DefaultResultSetHandler.createResultObject() </p>
<p>既然是代理对象，那么必须要有一种创建代理对象的方法。我们有哪些实现动态代 理的方式？ </p>
<p>这个就是为什么 settings 里面提供了一个 ProxyFactory 属性。MyBatis 默认使用 JAVASSIST 创建代理对象。也可以改为 CGLIB，这时需要引入 CGLIB 的包。 </p>
<p>【问题】CGLIB 和 JAVASSIST 区别是什么？</p>
<p>测试一下，我们把默认的 JAVASSIST 修改为 CGLIB，再打印这个对象。 </p>
<p>【问题】 </p>
<p>1、resultType 和 resultMap 的区别？ </p>
<p>2、collection 和 association 的区别？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shoufengsfsf.github.io/2020/06/22/spring-di%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%8F%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shoufeng">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shoufengsfsf.github.io">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/22/spring-di%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%8F%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">spring-di运行时序解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-22 16:09:57 / 修改时间：17:31:21" itemprop="dateCreated datePublished" datetime="2020-06-22T16:09:57+08:00">2020-06-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">spring源码解读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="spring-di运行时序解析"><a href="#spring-di运行时序解析" class="headerlink" title="spring-di运行时序解析"></a>spring-di运行时序解析</h1><h2 id="Spring-自动装配之依赖注入"><a href="#Spring-自动装配之依赖注入" class="headerlink" title="Spring 自动装配之依赖注入"></a>Spring 自动装配之依赖注入</h2><h3 id="依赖注入发生的时间"><a href="#依赖注入发生的时间" class="headerlink" title="依赖注入发生的时间"></a><strong>依赖注入发生的时间</strong></h3><p>当 Spring IOC 容器完成了 Bean 定义资源的定位、载入和解析注册以后，IOC 容器中已经管理类 Bean 定义的相关数据，但是此时 IOC 容器还没有对所管理的 Bean 进行依赖注入，依赖注入在以下两种情况 发生:</p>
<ol>
<li><p>用户第一次调用 getBean()方法时，IOC 容器触发依赖注入。 </p>
</li>
<li><p>当用户在配置文件中将&lt;bean&gt;元素配置了 lazy-init=false 属性，即让容器在解析注册 Bean 定义 时进行预实例化，触发依赖注入。</p>
</li>
</ol>
<p>BeanFactory 接口定义了 Spring IOC 容器的基本功能规范，是 Spring IOC 容器所应遵守的最底层和 最基本的编程规范。BeanFactory 接口中定义了几个 getBean()方法，就是用户向 IOC 容器索取管理的 Bean 的方法，我们通过分析其子类的具体实现，理解 Spring IOC 容器在用户索取 Bean 时如何完成依 赖注入。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg158axzvlj31500tujv0.jpg" alt="image-20200622162427796"></p>
<p>在 BeanFactory 中我们可以看到 getBean(String…)方法，但它具体实现在 AbstractBeanFactory 中。</p>
<h3 id="寻找获取-Bean-的入口"><a href="#寻找获取-Bean-的入口" class="headerlink" title="寻找获取 Bean 的入口"></a><strong>寻找获取 Bean 的入口</strong></h3><p>AbstractBeanFactory 的 getBean()相关方法的源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取IOC容器中指定名称的Bean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="comment">//doGetBean才是真正向IoC容器获取被管理Bean的过程</span></span><br><span class="line">   <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取IOC容器中指定名称和类型的Bean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, @Nullable Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="comment">//doGetBean才是真正向IoC容器获取被管理Bean的过程</span></span><br><span class="line">   <span class="keyword">return</span> doGetBean(name, requiredType, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取IOC容器中指定名称和参数的Bean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="comment">//doGetBean才是真正向IoC容器获取被管理Bean的过程</span></span><br><span class="line">   <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, args, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> requiredType the required type of the bean to retrieve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment"> * (only applied when creating a new instance as opposed to retrieving an existing one)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//获取IOC容器中指定名称、类型和参数的Bean</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object... args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="comment">//doGetBean才是真正向IoC容器获取被管理Bean的过程</span></span><br><span class="line">   <span class="keyword">return</span> doGetBean(name, requiredType, args, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> requiredType the required type of the bean to retrieve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment"> * (only applied when creating a new instance as opposed to retrieving an existing one)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> typeCheckOnly whether the instance is obtained for a type check,</span></span><br><span class="line"><span class="comment"> * not for actual use</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="comment">//真正实现向IOC容器获取Bean的功能，也是触发依赖注入功能的地方</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//根据指定的名称获取被管理Bean的名称，剥离指定名称中对容器的相关依赖</span></span><br><span class="line">   <span class="comment">//如果指定的是别名，将别名转换为规范的Bean名称</span></span><br><span class="line">   <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">   Object bean;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">   <span class="comment">//先从缓存中取是否已经有被创建过的单态类型的Bean</span></span><br><span class="line">   <span class="comment">//对于单例模式的Bean整个IOC容器中只创建一次，不需要重复创建</span></span><br><span class="line">   Object sharedInstance = getSingleton(beanName);</span><br><span class="line">   <span class="comment">//IOC容器创建单例模式Bean实例对象</span></span><br><span class="line">   <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         <span class="comment">//如果指定名称的Bean在容器中已有单例模式的Bean被创建</span></span><br><span class="line">         <span class="comment">//直接返回已经创建的Bean</span></span><br><span class="line">         <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +</span><br><span class="line">                  <span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.debug(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//获取给定Bean的实例对象，主要是完成FactoryBean的相关处理</span></span><br><span class="line">      <span class="comment">//注意：BeanFactory是管理容器中Bean的工厂，而FactoryBean是</span></span><br><span class="line">      <span class="comment">//创建创建对象的工厂Bean，两者之间有区别</span></span><br><span class="line">      bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Fail if we're already creating this bean instance:</span></span><br><span class="line">      <span class="comment">// We're assumably within a circular reference.</span></span><br><span class="line">      <span class="comment">//缓存没有正在创建的单例模式Bean</span></span><br><span class="line">      <span class="comment">//缓存中已经有已经创建的原型模式Bean</span></span><br><span class="line">      <span class="comment">//但是由于循环引用的问题导致实例化对象失败</span></span><br><span class="line">      <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">      <span class="comment">//对IOC容器中是否存在指定名称的BeanDefinition进行检查，首先检查是否</span></span><br><span class="line">      <span class="comment">//能在当前的BeanFactory中获取的所需要的Bean，如果不能则委托当前容器</span></span><br><span class="line">      <span class="comment">//的父级容器去查找，如果还是找不到则沿着容器的继承体系向父级容器查找</span></span><br><span class="line">      BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">      <span class="comment">//当前容器的父级容器存在，且当前容器中不存在指定名称的Bean</span></span><br><span class="line">      <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">         <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">         <span class="comment">//解析指定Bean名称的原始名称</span></span><br><span class="line">         String nameToLookup = originalBeanName(name);</span><br><span class="line">         <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">                  nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">            <span class="comment">//委派父级容器根据指定名称和显式的参数查找</span></span><br><span class="line">            <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">            <span class="comment">//委派父级容器根据指定名称和类型查找</span></span><br><span class="line">            <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//创建的Bean是否需要进行类型验证，一般不需要</span></span><br><span class="line">      <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">         <span class="comment">//向容器标记指定的Bean已经被创建</span></span><br><span class="line">         markBeanAsCreated(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//根据指定Bean名称获取其父级的Bean定义</span></span><br><span class="line">         <span class="comment">//主要解决Bean继承时子类合并父类公共属性问题</span></span><br><span class="line">         <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">         checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">         <span class="comment">//获取当前Bean所有依赖Bean的名称</span></span><br><span class="line">         String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">         <span class="comment">//如果当前Bean有依赖Bean</span></span><br><span class="line">         <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">               <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//递归调用getBean方法，获取当前Bean的依赖Bean</span></span><br><span class="line">               registerDependentBean(dep, beanName);</span><br><span class="line">               <span class="comment">//把被依赖Bean注册给当前依赖的Bean</span></span><br><span class="line">               getBean(dep);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Create bean instance.</span></span><br><span class="line">         <span class="comment">//创建单例模式Bean的实例对象</span></span><br><span class="line">         <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            <span class="comment">//这里使用了一个匿名内部类，创建Bean实例对象，并且注册给所依赖的对象</span></span><br><span class="line">            sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">//创建一个指定Bean实例对象，如果有父级继承，则合并子类和父类的定义</span></span><br><span class="line">                  <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                  <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">                  <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">                  <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">                  <span class="comment">//显式地从容器单例模式Bean缓存中清除实例对象</span></span><br><span class="line">                  destroySingleton(beanName);</span><br><span class="line">                  <span class="keyword">throw</span> ex;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//获取给定Bean的实例对象</span></span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//IOC容器创建原型模式Bean实例对象</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">            <span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">            <span class="comment">//原型模式(Prototype)是每次都会创建一个新的对象</span></span><br><span class="line">            Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//回调beforePrototypeCreation方法，默认的功能是注册当前创建的原型对象</span></span><br><span class="line">               beforePrototypeCreation(beanName);</span><br><span class="line">               <span class="comment">//创建指定Bean对象实例</span></span><br><span class="line">               prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="comment">//回调afterPrototypeCreation方法，默认的功能告诉IOC容器指定Bean的原型对象不再创建</span></span><br><span class="line">               afterPrototypeCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取给定Bean的实例对象</span></span><br><span class="line">            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//要创建的Bean既不是单例模式，也不是原型模式，则根据Bean定义资源中</span></span><br><span class="line">         <span class="comment">//配置的生命周期范围，选择实例化Bean的合适方法，这种在Web应用程序中</span></span><br><span class="line">         <span class="comment">//比较常用，如：request、session、application等生命周期</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            String scopeName = mbd.getScope();</span><br><span class="line">            <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">            <span class="comment">//Bean定义资源中没有配置生命周期范围，则Bean定义不合法</span></span><br><span class="line">            <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//这里又使用了一个匿名内部类，获取一个指定生命周期范围的实例</span></span><br><span class="line">               Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">                  beforePrototypeCreation(beanName);</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                     <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">finally</span> &#123;</span><br><span class="line">                     afterPrototypeCreation(beanName);</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">               <span class="comment">//获取给定Bean的实例对象</span></span><br><span class="line">               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                     <span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line">                     <span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">                     ex);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">   <span class="comment">//对创建的Bean实例对象进行类型检查</span></span><br><span class="line">   <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">         <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> convertedBean;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> +</span><br><span class="line">                  ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面对向 IOC 容器获取 Bean 方法的分析，我们可以看到在 Spring 中，如果 Bean 定义的单例模 式(Singleton)，则容器在创建之前先从缓存中查找，以确保整个容器中只存在一个实例对象。如果 Bean 定义的是原型模式(Prototype)，则容器每次都会创建一个新的实例对象。除此之外，Bean 定义还可以 扩展为指定其生命周期范围。</p>
<p>上面的源码只是定义了根据 Bean 定义的模式，采取的不同创建 Bean 实例对象的策略，具体的 Bean 实例对象的创建过程由实现了 ObjectFactory 接口的匿名内部类的 createBean()方法完成，ObjectFactory 使用委派模式，具体的 Bean 实例创建过程交由其实现类 AbstractAutowireCapableBeanFactory 完成，我们继续分析 AbstractAutowireCapableBeanFactory 的 createBean()方法的源码，理解其创建 Bean 实例的具体实现过程。</p>
<h3 id="开始实例化"><a href="#开始实例化" class="headerlink" title="开始实例化"></a><strong>开始实例化</strong></h3><p>AbstractAutowireCapableBeanFactory 类实现了 ObjectFactory 接口，创建容器指定的 Bean 实例对 象，同时还对创建的 Bean 实例对象进行初始化处理。其创建 Bean 实例对象的方法源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Bean实例对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line">   <span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line">   <span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line">   <span class="comment">//判断需要创建的Bean是否可以实例化，即是否可以通过当前的类加载器加载</span></span><br><span class="line">   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">   <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">      mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Prepare method overrides.</span></span><br><span class="line">   <span class="comment">//校验和准备Bean中的方法覆盖</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      mbdToUse.prepareMethodOverrides();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">            beanName, <span class="string">"Validation of method overrides failed"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">      <span class="comment">//如果Bean配置了初始化前和初始化后的处理器，则试图返回一个需要创建Bean的代理对象</span></span><br><span class="line">      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">      <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> bean;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//创建Bean的入口</span></span><br><span class="line">      Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> beanInstance;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">      <span class="comment">// A previously detected exception with proper bean creation context already...</span></span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">      <span class="comment">// An IllegalStateException to be communicated up to DefaultSingletonBeanRegistry...</span></span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbdToUse.getResourceDescription(), beanName, <span class="string">"Unexpected exception during bean creation"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Actually create the specified bean. Pre-creation processing has already happened</span></span><br><span class="line"><span class="comment"> * at this point, e.g. checking &#123;<span class="doctag">@code</span> postProcessBeforeInstantiation&#125; callbacks.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Differentiates between default bean instantiation, use of a</span></span><br><span class="line"><span class="comment"> * factory method, and autowiring a constructor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the merged bean definition for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args explicit arguments to use for constructor or factory method invocation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new instance of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanCreationException if the bean could not be created</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateUsingFactoryMethod</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #autowireConstructor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//真正创建Bean的方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Instantiate the bean.</span></span><br><span class="line">   <span class="comment">//封装被创建的Bean对象</span></span><br><span class="line">   BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">      instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">      instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">   <span class="comment">//获取实例化对象的类型</span></span><br><span class="line">   Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">   <span class="keyword">if</span> (beanType != NullBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">      mbd.resolvedTargetType = beanType;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">   <span class="comment">//调用PostProcessor后置处理器</span></span><br><span class="line">   <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  <span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">   <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">   <span class="comment">//向容器中缓存单例模式的Bean对象，以防循环引用</span></span><br><span class="line">   <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">         isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">   <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">               <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//这里是一个匿名内部类，为了防止循环引用，尽早持有对象的引用</span></span><br><span class="line">      addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">   <span class="comment">//Bean对象的初始化，依赖注入在此触发</span></span><br><span class="line">   <span class="comment">//这个exposedObject在初始化完成之后返回作为依赖注入完成后的Bean</span></span><br><span class="line">   Object exposedObject = bean;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//将Bean实例对象封装，并且Bean定义中配置的属性值赋值给实例对象</span></span><br><span class="line">      populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">      <span class="comment">//初始化Bean对象</span></span><br><span class="line">      exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">         <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">               mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">      <span class="comment">//获取指定名称的已注册的单例模式Bean对象</span></span><br><span class="line">      Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">//根据名称获取的已注册的Bean和正在实例化的Bean是同一个</span></span><br><span class="line">         <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">            <span class="comment">//当前实例化的Bean初始化完成</span></span><br><span class="line">            exposedObject = earlySingletonReference;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//当前Bean依赖其他Bean，并且当发生循环引用时不允许新创建实例对象</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">            String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">            Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">            <span class="comment">//获取当前Bean所依赖的其他Bean</span></span><br><span class="line">            <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">               <span class="comment">//对依赖Bean进行类型检查</span></span><br><span class="line">               <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                  actualDependentBeans.add(dependentBean);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                     <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                     <span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">                     <span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">                     <span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">                     <span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register bean as disposable.</span></span><br><span class="line">   <span class="comment">//注册完成依赖注入的Bean</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的源码注释，我们看到具体的依赖注入实现其实就在以下两个方法中: </p>
<ol>
<li><p>createBeanInstance()方法，生成 Bean 所包含的 java 对象实例。 </p>
</li>
<li><p>populateBean()方法，对 Bean 属性的依赖注入进行处理。 下面继续分析这两个方法的代码实现。</p>
</li>
</ol>
<h3 id="选择-Bean-实例化策略"><a href="#选择-Bean-实例化策略" class="headerlink" title="选择 Bean 实例化策略"></a><strong>选择 Bean 实例化策略</strong></h3><p>在 createBeanInstance()方法中，根据指定的初始化策略，使用简单工厂、工厂方法或者容器的自动装 配特性生成 Java 实例对象，创建对象的源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Bean的实例对象</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">   <span class="comment">//检查确认Bean是可实例化的</span></span><br><span class="line">   Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//使用工厂方法对Bean进行实例化</span></span><br><span class="line">   <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">   <span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>)  &#123;</span><br><span class="line">      <span class="comment">//调用工厂方法实例化</span></span><br><span class="line">      <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Shortcut when re-creating the same bean...</span></span><br><span class="line">   <span class="comment">//使用容器的自动装配方法进行实例化</span></span><br><span class="line">   <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">         <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resolved = <span class="keyword">true</span>;</span><br><span class="line">            autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">      <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">         <span class="comment">//配置了自动装配属性，使用容器的自动装配实例化</span></span><br><span class="line">         <span class="comment">//容器的自动装配是根据参数类型匹配Bean的构造方法</span></span><br><span class="line">         <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//使用默认的无参构造方法实例化</span></span><br><span class="line">         <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Need to determine the constructor...</span></span><br><span class="line">   <span class="comment">//使用Bean的构造方法进行实例化</span></span><br><span class="line">   Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">   <span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line">      <span class="comment">//使用容器的自动装配特性，调用匹配的构造方法实例化</span></span><br><span class="line">      <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line">   <span class="comment">//使用默认的无参构造方法实例化</span></span><br><span class="line">   <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认的无参构造方法实例化Bean对象</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      Object beanInstance;</span><br><span class="line">      <span class="keyword">final</span> BeanFactory parent = <span class="keyword">this</span>;</span><br><span class="line">      <span class="comment">//获取系统的安全管理接口，JDK标准的安全管理API</span></span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">//这里是一个匿名内置类，根据实例化策略创建实例对象</span></span><br><span class="line">         beanInstance = AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;</span><br><span class="line">               getInstantiationStrategy().instantiate(mbd, beanName, parent),</span><br><span class="line">               getAccessControlContext());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//将实例化的对象封装起来</span></span><br><span class="line">         beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">      &#125;</span><br><span class="line">      BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">      initBeanWrapper(bw);</span><br><span class="line">      <span class="keyword">return</span> bw;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">"Instantiation of bean failed"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过对上面的代码分析，我们可以看出，对使用工厂方法和自动装配特性的 Bean 的实例化相当比较清 楚，调用相应的工厂方法或者参数匹配的构造方法即可完成实例化对象的工作，但是对于我们最常使用 的默认无参构造方法就需要使用相应的初始化策略(JDK 的反射机制或者 CGLib)来进行初始化了，在方 法 getInstantiationStrategy().instantiate()中就具体实现类使用初始策略实例化对象。</p>
<h3 id="执行-Bean-实例化"><a href="#执行-Bean-实例化" class="headerlink" title="执行 Bean 实例化"></a><strong>执行 Bean 实例化</strong></h3><p>在使用默认的无参构造方法创建 Bean 的实例化对象时，方法 getInstantiationStrategy().instantiate() 调用了 SimpleInstantiationStrategy 类中的实例化 Bean 的方法，其源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleInstantiationStrategy</span> <span class="keyword">implements</span> <span class="title">InstantiationStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Method&gt; currentlyInvokedFactoryMethod = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the factory method currently being invoked or &#123;<span class="doctag">@code</span> null&#125; if none.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Allows factory method implementations to determine whether the current</span></span><br><span class="line"><span class="comment">    * caller is the container itself as opposed to user code.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Method <span class="title">getCurrentlyInvokedFactoryMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> currentlyInvokedFactoryMethod.get();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//使用初始化策略实例化Bean对象</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Don't override the class with CGLIB if no overrides.</span></span><br><span class="line">      <span class="comment">//如果Bean定义中没有方法覆盖，则就不需要CGLIB父类类的方法</span></span><br><span class="line">      <span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">         Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">         <span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line">            <span class="comment">//获取对象的构造方法或工厂方法</span></span><br><span class="line">            constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">            <span class="comment">//如果没有构造方法且没有工厂方法</span></span><br><span class="line">            <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//使用JDK的反射机制，判断要实例化的Bean是否是接口</span></span><br><span class="line">               <span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line">               <span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"Specified class is an interface"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">//这里是一个匿名内置类，使用反射机制获取Bean的构造方法</span></span><br><span class="line">                     constructorToUse = AccessController.doPrivileged(</span><br><span class="line">                           (PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) () -&gt; clazz.getDeclaredConstructor());</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span> &#123;</span><br><span class="line">                     constructorToUse = clazz.getDeclaredConstructor();</span><br><span class="line">                  &#125;</span><br><span class="line">                  bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"No default constructor found"</span>, ex);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//使用BeanUtils实例化，通过反射机制调用”构造方法.newInstance(arg)”来进行实例化</span></span><br><span class="line">         <span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Must generate CGLIB subclass.</span></span><br><span class="line">         <span class="comment">//使用CGLIB来实例化对象</span></span><br><span class="line">         <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Subclasses can override this method, which is implemented to throw</span></span><br><span class="line"><span class="comment">    * UnsupportedOperationException, if they can instantiate an object with</span></span><br><span class="line"><span class="comment">    * the Method Injection specified in the given RootBeanDefinition.</span></span><br><span class="line"><span class="comment">    * Instantiation should use a no-arg constructor.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Object <span class="title">instantiateWithMethodInjection</span><span class="params">(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Method Injection not supported in SimpleInstantiationStrategy"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">final</span> Constructor&lt;?&gt; ctor, @Nullable Object... args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// use own privileged to change accessibility (when security is on)</span></span><br><span class="line">            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">               ReflectionUtils.makeAccessible(ctor);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> (args != <span class="keyword">null</span> ? BeanUtils.instantiateClass(ctor, args) : BeanUtils.instantiateClass(ctor));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner, ctor, args);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Subclasses can override this method, which is implemented to throw</span></span><br><span class="line"><span class="comment">    * UnsupportedOperationException, if they can instantiate an object with</span></span><br><span class="line"><span class="comment">    * the Method Injection specified in the given RootBeanDefinition.</span></span><br><span class="line"><span class="comment">    * Instantiation should use the given constructor and parameters.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Object <span class="title">instantiateWithMethodInjection</span><span class="params">(RootBeanDefinition bd, @Nullable String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">         BeanFactory owner, @Nullable Constructor&lt;?&gt; ctor, @Nullable Object... args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Method Injection not supported in SimpleInstantiationStrategy"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,</span></span></span><br><span class="line"><span class="function"><span class="params">         @Nullable Object factoryBean, <span class="keyword">final</span> Method factoryMethod, @Nullable Object... args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">               ReflectionUtils.makeAccessible(factoryMethod);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            ReflectionUtils.makeAccessible(factoryMethod);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         Method priorInvokedFactoryMethod = currentlyInvokedFactoryMethod.get();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            currentlyInvokedFactoryMethod.set(factoryMethod);</span><br><span class="line">            Object result = factoryMethod.invoke(factoryBean, args);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">               result = <span class="keyword">new</span> NullBean();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (priorInvokedFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">               currentlyInvokedFactoryMethod.set(priorInvokedFactoryMethod);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               currentlyInvokedFactoryMethod.remove();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(factoryMethod,</span><br><span class="line">               <span class="string">"Illegal arguments to factory method '"</span> + factoryMethod.getName() + <span class="string">"'; "</span> +</span><br><span class="line">               <span class="string">"args: "</span> + StringUtils.arrayToCommaDelimitedString(args), ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(factoryMethod,</span><br><span class="line">               <span class="string">"Cannot access factory method '"</span> + factoryMethod.getName() + <span class="string">"'; is it public?"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">         String msg = <span class="string">"Factory method '"</span> + factoryMethod.getName() + <span class="string">"' threw exception"</span>;</span><br><span class="line">         <span class="keyword">if</span> (bd.getFactoryBeanName() != <span class="keyword">null</span> &amp;&amp; owner <span class="keyword">instanceof</span> ConfigurableBeanFactory &amp;&amp;</span><br><span class="line">               ((ConfigurableBeanFactory) owner).isCurrentlyInCreation(bd.getFactoryBeanName())) &#123;</span><br><span class="line">            msg = <span class="string">"Circular reference involving containing bean '"</span> + bd.getFactoryBeanName() + <span class="string">"' - consider "</span> +</span><br><span class="line">                  <span class="string">"declaring the factory method as static for independence from its containing instance. "</span> + msg;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(factoryMethod, msg, ex.getTargetException());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码分析，我们看到了如果 Bean 有方法被覆盖了，则使用 JDK 的反射机制进行实例化，否 则，使用 CGLib 进行实例化。</p>
<p>instantiateWithMethodInjection() 方 法 调 用 SimpleInstantiationStrategy 的 子 类 CGLibSubclassingInstantiationStrategy 使用 CGLib 来进行初始化，其源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//使用CGLIB进行Bean对象实例化</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(@Nullable Constructor&lt;?&gt; ctor, @Nullable Object... args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//创建代理子类</span></span><br><span class="line">      Class&lt;?&gt; subclass = createEnhancedSubclass(<span class="keyword">this</span>.beanDefinition);</span><br><span class="line">      Object instance;</span><br><span class="line">      <span class="keyword">if</span> (ctor == <span class="keyword">null</span>) &#123;</span><br><span class="line">         instance = BeanUtils.instantiateClass(subclass);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;?&gt; enhancedSubclassConstructor = subclass.getConstructor(ctor.getParameterTypes());</span><br><span class="line">            instance = enhancedSubclassConstructor.newInstance(args);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(<span class="keyword">this</span>.beanDefinition.getBeanClass(),</span><br><span class="line">                  <span class="string">"Failed to invoke constructor for CGLIB enhanced subclass ["</span> + subclass.getName() + <span class="string">"]"</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// SPR-10785: set callbacks directly on the instance instead of in the</span></span><br><span class="line">      <span class="comment">// enhanced class (via the Enhancer) in order to avoid memory leaks.</span></span><br><span class="line">      Factory factory = (Factory) instance;</span><br><span class="line">      factory.setCallbacks(<span class="keyword">new</span> Callback[] &#123;NoOp.INSTANCE,</span><br><span class="line">            <span class="keyword">new</span> LookupOverrideMethodInterceptor(<span class="keyword">this</span>.beanDefinition, <span class="keyword">this</span>.owner),</span><br><span class="line">            <span class="keyword">new</span> ReplaceOverrideMethodInterceptor(<span class="keyword">this</span>.beanDefinition, <span class="keyword">this</span>.owner)&#125;);</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Create an enhanced subclass of the bean class for the provided bean</span></span><br><span class="line"><span class="comment">    * definition, using CGLIB.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> Class&lt;?&gt; createEnhancedSubclass(RootBeanDefinition beanDefinition) &#123;</span><br><span class="line">      <span class="comment">//CGLIB中的类</span></span><br><span class="line">      Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">      <span class="comment">//将Bean本身作为其基类</span></span><br><span class="line">      enhancer.setSuperclass(beanDefinition.getBeanClass());</span><br><span class="line">      enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.owner <span class="keyword">instanceof</span> ConfigurableBeanFactory) &#123;</span><br><span class="line">         ClassLoader cl = ((ConfigurableBeanFactory) <span class="keyword">this</span>.owner).getBeanClassLoader();</span><br><span class="line">         enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareGeneratorStrategy(cl));</span><br><span class="line">      &#125;</span><br><span class="line">      enhancer.setCallbackFilter(<span class="keyword">new</span> MethodOverrideCallbackFilter(beanDefinition));</span><br><span class="line">      enhancer.setCallbackTypes(CALLBACK_TYPES);</span><br><span class="line">      <span class="comment">//使用CGLIB的createClass方法生成实例对象</span></span><br><span class="line">      <span class="keyword">return</span> enhancer.createClass();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CGLib 是一个常用的字节码生成器的类库，它提供了一系列 API 实现 Java 字节码的生成和转换功能。 我们在学习 JDK 的动态代理时都知道，JDK 的动态代理只能针对接口，如果一个类没有实现任何接口， 要对其进行动态代理只能使用 CGLib。</p>
<h3 id="准备依赖注入"><a href="#准备依赖注入" class="headerlink" title="准备依赖注入"></a><strong>准备依赖注入</strong></h3><p>在前面的分析中我们已经了解到 Bean 的依赖注入主要分为两个步骤，首先调用 createBeanInstance() 方法生成 Bean 所包含的 Java 对象实例。然后，调用 populateBean()方法，对 Bean 属性的依赖注入 进行处理。</p>
<p>上面我们已经分析了容器初始化生成 Bean 所包含的 Java 实例对象的过程，现在我们继续分析生成对象 后，Spring IOC 容器是如何将 Bean 的属性依赖关系注入 Bean 实例对象中并设置好的，回到 AbstractAutowireCapableBeanFactory 的 populateBean()方法，对属性依赖注入的代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将Bean属性设置到生成的实例对象上</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">               mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span></span><br><span class="line">   <span class="comment">// state of the bean before properties are set. This can be used, for example,</span></span><br><span class="line">   <span class="comment">// to support styles of field injection.</span></span><br><span class="line">   <span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">               continueWithPropertyPopulation = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//获取容器在解析Bean定义资源时为BeanDefiniton中设置的属性值</span></span><br><span class="line">   PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//对依赖注入处理，首先处理autowiring自动装配的依赖注入</span></span><br><span class="line">   <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">      MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">      <span class="comment">//根据Bean名称进行autowiring自动装配处理</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">         autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">      <span class="comment">//根据Bean类型进行autowiring自动装配处理</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">         autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      pvs = newPvs;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//对非autowiring的属性进行依赖注入处理</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">   <span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">         pvs = mbd.getPropertyValues();</span><br><span class="line">      &#125;</span><br><span class="line">      PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">      <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">         <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">               InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">               pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">               <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">         checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//对属性进行注入</span></span><br><span class="line">      applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fill in any missing property values with references to</span></span><br><span class="line"><span class="comment"> * other beans in this factory if autowire is set to "byName".</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean we're wiring up.</span></span><br><span class="line"><span class="comment"> * Useful for debugging messages; not used functionally.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd bean definition to update through autowiring</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bw BeanWrapper from which we can obtain information about the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pvs the PropertyValues to register wired objects with</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//根据名称对属性进行自动依赖注入</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">autowireByName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//对Bean对象中非简单属性(不是简单继承的对象，如8中原始类型，字符串，URL等都是简单属性)进行处理</span></span><br><span class="line">   String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">   <span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line">      <span class="comment">//如果Spring IOC容器中包含指定名称的Bean</span></span><br><span class="line">      <span class="keyword">if</span> (containsBean(propertyName)) &#123;</span><br><span class="line">         <span class="comment">//调用getBean方法向IOC容器索取指定名称的Bean实例，迭代触发属性的初始化和依赖注入</span></span><br><span class="line">         Object bean = getBean(propertyName);</span><br><span class="line">         <span class="comment">//为指定名称的属性赋予属性值</span></span><br><span class="line">         pvs.add(propertyName, bean);</span><br><span class="line">         <span class="comment">//指定名称属性注册依赖Bean名称，进行属性依赖注入</span></span><br><span class="line">         registerDependentBean(propertyName, beanName);</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Added autowiring by name from bean name '"</span> + beanName +</span><br><span class="line">                  <span class="string">"' via property '"</span> + propertyName + <span class="string">"' to bean named '"</span> + propertyName + <span class="string">"'"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Not autowiring property '"</span> + propertyName + <span class="string">"' of bean '"</span> + beanName +</span><br><span class="line">                  <span class="string">"' by name: no matching bean found"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Abstract method defining "autowire by type" (bean properties by type) behavior.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is like PicoContainer default, in which there must be exactly one bean</span></span><br><span class="line"><span class="comment"> * of the property type in the bean factory. This makes bean factories simple to</span></span><br><span class="line"><span class="comment"> * configure for small namespaces, but doesn't work as well as standard Spring</span></span><br><span class="line"><span class="comment"> * behavior for bigger applications.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean to autowire by type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the merged bean definition to update through autowiring</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bw BeanWrapper from which we can obtain information about the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pvs the PropertyValues to register wired objects with</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//根据类型对属性进行自动依赖注入</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">autowireByType</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取用户定义的类型转换器</span></span><br><span class="line">   TypeConverter converter = getCustomTypeConverter();</span><br><span class="line">   <span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">      converter = bw;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//存放解析的要注入的属性</span></span><br><span class="line">   Set&lt;String&gt; autowiredBeanNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">   <span class="comment">//对Bean对象中非简单属性(不是简单继承的对象，如8中原始类型，字符</span></span><br><span class="line">   <span class="comment">//URL等都是简单属性)进行处理</span></span><br><span class="line">   String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">   <span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//获取指定属性名称的属性描述器</span></span><br><span class="line">         PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);</span><br><span class="line">         <span class="comment">// Don't try autowiring by type for type Object: never makes sense,</span></span><br><span class="line">         <span class="comment">// even if it technically is a unsatisfied, non-simple property.</span></span><br><span class="line">         <span class="comment">//不对Object类型的属性进行autowiring自动依赖注入</span></span><br><span class="line">         <span class="keyword">if</span> (Object<span class="class">.<span class="keyword">class</span> !</span>= pd.getPropertyType()) &#123;</span><br><span class="line">            <span class="comment">//获取属性的setter方法</span></span><br><span class="line">            MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);</span><br><span class="line">            <span class="comment">// Do not allow eager init for type matching in case of a prioritized post-processor.</span></span><br><span class="line">            <span class="comment">//检查指定类型是否可以被转换为目标对象的类型</span></span><br><span class="line">            <span class="keyword">boolean</span> eager = !PriorityOrdered<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">bw</span>.<span class="title">getWrappedInstance</span>())</span>;</span><br><span class="line">            <span class="comment">//创建一个要被注入的依赖描述</span></span><br><span class="line">            DependencyDescriptor desc = <span class="keyword">new</span> AutowireByTypeDependencyDescriptor(methodParam, eager);</span><br><span class="line">            <span class="comment">//根据容器的Bean定义解析依赖关系，返回所有要被注入的Bean对象</span></span><br><span class="line">            Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);</span><br><span class="line">            <span class="keyword">if</span> (autowiredArgument != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//为属性赋值所引用的对象</span></span><br><span class="line">               pvs.add(propertyName, autowiredArgument);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (String autowiredBeanName : autowiredBeanNames) &#123;</span><br><span class="line">               <span class="comment">//指定名称属性注册依赖Bean名称，进行属性依赖注入</span></span><br><span class="line">               registerDependentBean(autowiredBeanName, beanName);</span><br><span class="line">               <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                  logger.debug(<span class="string">"Autowiring by type from bean name '"</span> + beanName + <span class="string">"' via property '"</span> +</span><br><span class="line">                        propertyName + <span class="string">"' to bean named '"</span> + autowiredBeanName + <span class="string">"'"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//释放已自动注入的属性</span></span><br><span class="line">            autowiredBeanNames.clear();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Apply the given property values, resolving any runtime references</span></span><br><span class="line"><span class="comment">	 * to other beans in this bean factory. Must use deep copy, so we</span></span><br><span class="line"><span class="comment">	 * don't permanently modify this property.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the bean name passed for better exception information</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> mbd the merged bean definition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bw the BeanWrapper wrapping the target object</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> pvs the new property values</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//解析并注入依赖属性的过程</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (pvs.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//封装属性值</span></span><br><span class="line">		MutablePropertyValues mpvs = <span class="keyword">null</span>;</span><br><span class="line">		List&lt;PropertyValue&gt; original;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (bw <span class="keyword">instanceof</span> BeanWrapperImpl) &#123;</span><br><span class="line">				<span class="comment">//设置安全上下文，JDK安全机制</span></span><br><span class="line">				((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;</span><br><span class="line">			mpvs = (MutablePropertyValues) pvs;</span><br><span class="line">			<span class="comment">//属性值已经转换</span></span><br><span class="line">			<span class="keyword">if</span> (mpvs.isConverted()) &#123;</span><br><span class="line">				<span class="comment">// Shortcut: use the pre-converted values as-is.</span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="comment">//为实例化对象设置属性值</span></span><br><span class="line">					bw.setPropertyValues(mpvs);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">							mbd.getResourceDescription(), beanName, <span class="string">"Error setting property values"</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//获取属性值对象的原始类型值</span></span><br><span class="line">			original = mpvs.getPropertyValueList();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			original = Arrays.asList(pvs.getPropertyValues());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//获取用户自定义的类型转换</span></span><br><span class="line">		TypeConverter converter = getCustomTypeConverter();</span><br><span class="line">		<span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">			converter = bw;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//创建一个Bean定义属性值解析器，将Bean定义中的属性值解析为Bean实例对象的实际值</span></span><br><span class="line">		BeanDefinitionValueResolver valueResolver = <span class="keyword">new</span> BeanDefinitionValueResolver(<span class="keyword">this</span>, beanName, mbd, converter);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create a deep copy, resolving any references for values.</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//为属性的解析值创建一个拷贝，将拷贝的数据注入到实例对象中</span></span><br><span class="line">		List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> ArrayList&lt;&gt;(original.size());</span><br><span class="line">		<span class="keyword">boolean</span> resolveNecessary = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (PropertyValue pv : original) &#123;</span><br><span class="line">			<span class="comment">//属性值不需要转换</span></span><br><span class="line">			<span class="keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line">				deepCopy.add(pv);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//属性值需要转换</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				String propertyName = pv.getName();</span><br><span class="line">				<span class="comment">//原始的属性值，即转换之前的属性值</span></span><br><span class="line">				Object originalValue = pv.getValue();</span><br><span class="line">				<span class="comment">//转换属性值，例如将引用转换为IOC容器中实例化对象引用</span></span><br><span class="line">				Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">				<span class="comment">//转换之后的属性值</span></span><br><span class="line">				Object convertedValue = resolvedValue;</span><br><span class="line">				<span class="comment">//属性值是否可以转换</span></span><br><span class="line">				<span class="keyword">boolean</span> convertible = bw.isWritableProperty(propertyName) &amp;&amp;</span><br><span class="line">						!PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);</span><br><span class="line">				<span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">					<span class="comment">//使用用户自定义的类型转换器转换属性值</span></span><br><span class="line">					convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Possibly store converted value in merged bean definition,</span></span><br><span class="line">				<span class="comment">// in order to avoid re-conversion for every created bean instance.</span></span><br><span class="line">				<span class="comment">//存储转换后的属性值，避免每次属性注入时的转换工作</span></span><br><span class="line">				<span class="keyword">if</span> (resolvedValue == originalValue) &#123;</span><br><span class="line">					<span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">						<span class="comment">//设置属性转换之后的值</span></span><br><span class="line">						pv.setConvertedValue(convertedValue);</span><br><span class="line">					&#125;</span><br><span class="line">					deepCopy.add(pv);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//属性是可转换的，且属性原始值是字符串类型，且属性的原始类型值不是</span></span><br><span class="line">				<span class="comment">//动态生成的字符串，且属性的原始值不是集合或者数组类型</span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (convertible &amp;&amp; originalValue <span class="keyword">instanceof</span> TypedStringValue &amp;&amp;</span><br><span class="line">						!((TypedStringValue) originalValue).isDynamic() &amp;&amp;</span><br><span class="line">						!(convertedValue <span class="keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) &#123;</span><br><span class="line">					pv.setConvertedValue(convertedValue);</span><br><span class="line">					<span class="comment">//重新封装属性的值</span></span><br><span class="line">					deepCopy.add(pv);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					resolveNecessary = <span class="keyword">true</span>;</span><br><span class="line">					deepCopy.add(<span class="keyword">new</span> PropertyValue(pv, convertedValue));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (mpvs != <span class="keyword">null</span> &amp;&amp; !resolveNecessary) &#123;</span><br><span class="line">			<span class="comment">//标记属性值已经转换过</span></span><br><span class="line">			mpvs.setConverted();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Set our (possibly massaged) deep copy.</span></span><br><span class="line">		<span class="comment">//进行属性依赖注入</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			bw.setPropertyValues(<span class="keyword">new</span> MutablePropertyValues(deepCopy));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">					mbd.getResourceDescription(), beanName, <span class="string">"Error setting property values"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>分析上述代码，我们可以看出，对属性的注入过程分以下两种情况:</p>
<ol>
<li><p>属性值类型不需要强制转换时，不需要解析属性值，直接准备进行依赖注入。 </p>
</li>
<li><p>属性值需要进行类型强制转换时，如对其他对象的引用等，首先需要解析属性值，然后对解析后的 属性值进行依赖注入。</p>
</li>
</ol>
<p>对属性值的解析是在 BeanDefinitionValueResolver 类中的 resolveValueIfNecessary()方法中进行的， 对属性值的依赖注入是通过 bw.setPropertyValues()方法实现的，在分析属性值的依赖注入之前，我们 先分析一下对属性值的解析过程。</p>
<h3 id="解析属性注入规则"><a href="#解析属性注入规则" class="headerlink" title="解析属性注入规则"></a><strong>解析属性注入规则</strong></h3><p>当容器在对属性进行依赖注入时，如果发现属性值需要进行类型转换，如属性值是容器中另一个 Bean 实例对象的引用，则容器首先需要根据属性值解析出所引用的对象，然后才能将该引用对象注入到目标 实例对象的属性上去，对属性进行解析的由 resolveValueIfNecessary()方法实现，其源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解析属性值，对注入类型进行转换</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveValueIfNecessary</span><span class="params">(Object argName, @Nullable Object value)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// We must check each value to see whether it requires a runtime reference</span></span><br><span class="line">   <span class="comment">// to another bean to be resolved.</span></span><br><span class="line">   <span class="comment">//对引用类型的属性进行解析</span></span><br><span class="line">   <span class="keyword">if</span> (value <span class="keyword">instanceof</span> RuntimeBeanReference) &#123;</span><br><span class="line">      RuntimeBeanReference ref = (RuntimeBeanReference) value;</span><br><span class="line">      <span class="comment">//调用引用类型属性的解析方法</span></span><br><span class="line">      <span class="keyword">return</span> resolveReference(argName, ref);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//对属性值是引用容器中另一个Bean名称的解析</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> RuntimeBeanNameReference) &#123;</span><br><span class="line">      String refName = ((RuntimeBeanNameReference) value).getBeanName();</span><br><span class="line">      refName = String.valueOf(doEvaluate(refName));</span><br><span class="line">      <span class="comment">//从容器中获取指定名称的Bean</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.beanFactory.containsBean(refName)) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">               <span class="string">"Invalid bean name '"</span> + refName + <span class="string">"' in bean reference for "</span> + argName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> refName;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//对Bean类型属性的解析，主要是Bean中的内部类</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> BeanDefinitionHolder) &#123;</span><br><span class="line">      <span class="comment">// Resolve BeanDefinitionHolder: contains BeanDefinition with name and aliases.</span></span><br><span class="line">      BeanDefinitionHolder bdHolder = (BeanDefinitionHolder) value;</span><br><span class="line">      <span class="keyword">return</span> resolveInnerBean(argName, bdHolder.getBeanName(), bdHolder.getBeanDefinition());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> BeanDefinition) &#123;</span><br><span class="line">      <span class="comment">// Resolve plain BeanDefinition, without contained name: use dummy name.</span></span><br><span class="line">      BeanDefinition bd = (BeanDefinition) value;</span><br><span class="line">      String innerBeanName = <span class="string">"(inner bean)"</span> + BeanFactoryUtils.GENERATED_BEAN_NAME_SEPARATOR +</span><br><span class="line">            ObjectUtils.getIdentityHexString(bd);</span><br><span class="line">      <span class="keyword">return</span> resolveInnerBean(argName, innerBeanName, bd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//对集合数组类型的属性解析</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedArray) &#123;</span><br><span class="line">      <span class="comment">// May need to resolve contained runtime references.</span></span><br><span class="line">      ManagedArray array = (ManagedArray) value;</span><br><span class="line">      <span class="comment">//获取数组的类型</span></span><br><span class="line">      Class&lt;?&gt; elementType = array.resolvedElementType;</span><br><span class="line">      <span class="keyword">if</span> (elementType == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">//获取数组元素的类型</span></span><br><span class="line">         String elementTypeName = array.getElementTypeName();</span><br><span class="line">         <span class="keyword">if</span> (StringUtils.hasText(elementTypeName)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//使用反射机制创建指定类型的对象</span></span><br><span class="line">               elementType = ClassUtils.forName(elementTypeName, <span class="keyword">this</span>.beanFactory.getBeanClassLoader());</span><br><span class="line">               array.resolvedElementType = elementType;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">               <span class="comment">// Improve the message by showing the context.</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                     <span class="keyword">this</span>.beanDefinition.getResourceDescription(), <span class="keyword">this</span>.beanName,</span><br><span class="line">                     <span class="string">"Error resolving array type for "</span> + argName, ex);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//没有获取到数组的类型，也没有获取到数组元素的类型</span></span><br><span class="line">         <span class="comment">//则直接设置数组的类型为Object</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            elementType = Object<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//创建指定类型的数组</span></span><br><span class="line">      <span class="keyword">return</span> resolveManagedArray(argName, (List&lt;?&gt;) value, elementType);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//解析list类型的属性值</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedList) &#123;</span><br><span class="line">      <span class="comment">// May need to resolve contained runtime references.</span></span><br><span class="line">      <span class="keyword">return</span> resolveManagedList(argName, (List&lt;?&gt;) value);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//解析set类型的属性值</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedSet) &#123;</span><br><span class="line">      <span class="comment">// May need to resolve contained runtime references.</span></span><br><span class="line">      <span class="keyword">return</span> resolveManagedSet(argName, (Set&lt;?&gt;) value);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//解析map类型的属性值</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedMap) &#123;</span><br><span class="line">      <span class="comment">// May need to resolve contained runtime references.</span></span><br><span class="line">      <span class="keyword">return</span> resolveManagedMap(argName, (Map&lt;?, ?&gt;) value);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//解析props类型的属性值，props其实就是key和value均为字符串的map</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedProperties) &#123;</span><br><span class="line">      Properties original = (Properties) value;</span><br><span class="line">      <span class="comment">//创建一个拷贝，用于作为解析后的返回值</span></span><br><span class="line">      Properties copy = <span class="keyword">new</span> Properties();</span><br><span class="line">      original.forEach((propKey, propValue) -&gt; &#123;</span><br><span class="line">         <span class="keyword">if</span> (propKey <span class="keyword">instanceof</span> TypedStringValue) &#123;</span><br><span class="line">            propKey = evaluate((TypedStringValue) propKey);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (propValue <span class="keyword">instanceof</span> TypedStringValue) &#123;</span><br><span class="line">            propValue = evaluate((TypedStringValue) propValue);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (propKey == <span class="keyword">null</span> || propValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                  <span class="keyword">this</span>.beanDefinition.getResourceDescription(), <span class="keyword">this</span>.beanName,</span><br><span class="line">                  <span class="string">"Error converting Properties key/value pair for "</span> + argName + <span class="string">": resolved to null"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         copy.put(propKey, propValue);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> copy;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//解析字符串类型的属性值</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> TypedStringValue) &#123;</span><br><span class="line">      <span class="comment">// Convert value to target type here.</span></span><br><span class="line">      TypedStringValue typedStringValue = (TypedStringValue) value;</span><br><span class="line">      Object valueObject = evaluate(typedStringValue);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//获取属性的目标类型</span></span><br><span class="line">         Class&lt;?&gt; resolvedTargetType = resolveTargetType(typedStringValue);</span><br><span class="line">         <span class="keyword">if</span> (resolvedTargetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//对目标类型的属性进行解析，递归调用</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.typeConverter.convertIfNecessary(valueObject, resolvedTargetType);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//没有获取到属性的目标对象，则按Object类型返回</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> valueObject;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">         <span class="comment">// Improve the message by showing the context.</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">               <span class="keyword">this</span>.beanDefinition.getResourceDescription(), <span class="keyword">this</span>.beanName,</span><br><span class="line">               <span class="string">"Error converting typed String value for "</span> + argName, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> evaluate(value);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resolve a reference to another bean in the factory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//解析引用类型的属性值</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">resolveReference</span><span class="params">(Object argName, RuntimeBeanReference ref)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      Object bean;</span><br><span class="line">      <span class="comment">//获取引用的Bean名称</span></span><br><span class="line">      String refName = ref.getBeanName();</span><br><span class="line">      refName = String.valueOf(doEvaluate(refName));</span><br><span class="line">      <span class="comment">//如果引用的对象在父类容器中，则从父类容器中获取指定的引用对象</span></span><br><span class="line">      <span class="keyword">if</span> (ref.isToParent()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.getParentBeanFactory() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                  <span class="keyword">this</span>.beanDefinition.getResourceDescription(), <span class="keyword">this</span>.beanName,</span><br><span class="line">                  <span class="string">"Can't resolve reference to bean '"</span> + refName +</span><br><span class="line">                  <span class="string">"' in parent factory: no parent factory available"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         bean = <span class="keyword">this</span>.beanFactory.getParentBeanFactory().getBean(refName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//从当前的容器中获取指定的引用Bean对象，如果指定的Bean没有被实例化</span></span><br><span class="line">      <span class="comment">//则会递归触发引用Bean的初始化和依赖注入</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         bean = <span class="keyword">this</span>.beanFactory.getBean(refName);</span><br><span class="line">         <span class="comment">//将当前实例化对象的依赖引用对象</span></span><br><span class="line">         <span class="keyword">this</span>.beanFactory.registerDependentBean(refName, <span class="keyword">this</span>.beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">         bean = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            <span class="keyword">this</span>.beanDefinition.getResourceDescription(), <span class="keyword">this</span>.beanName,</span><br><span class="line">            <span class="string">"Cannot resolve reference to bean '"</span> + ref.getBeanName() + <span class="string">"' while setting "</span> + argName, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * For each element in the managed array, resolve reference if necessary.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//解析array类型的属性</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">resolveManagedArray</span><span class="params">(Object argName, List&lt;?&gt; ml, Class&lt;?&gt; elementType)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//创建一个指定类型的数组，用于存放和返回解析后的数组</span></span><br><span class="line">   Object resolved = Array.newInstance(elementType, ml.size());</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ml.size(); i++) &#123;</span><br><span class="line">      <span class="comment">//递归解析array的每一个元素，并将解析后的值设置到resolved数组中，索引为i</span></span><br><span class="line">      Array.set(resolved, i,</span><br><span class="line">            resolveValueIfNecessary(<span class="keyword">new</span> KeyedArgName(argName, i), ml.get(i)));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> resolved;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * For each element in the managed list, resolve reference if necessary.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//解析list类型的属性</span></span><br><span class="line"><span class="keyword">private</span> List&lt;?&gt; resolveManagedList(Object argName, List&lt;?&gt; ml) &#123;</span><br><span class="line">   List&lt;Object&gt; resolved = <span class="keyword">new</span> ArrayList&lt;&gt;(ml.size());</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ml.size(); i++) &#123;</span><br><span class="line">      <span class="comment">//递归解析list的每一个元素</span></span><br><span class="line">      resolved.add(</span><br><span class="line">            resolveValueIfNecessary(<span class="keyword">new</span> KeyedArgName(argName, i), ml.get(i)));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> resolved;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * For each element in the managed set, resolve reference if necessary.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//解析set类型的属性</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;?&gt; resolveManagedSet(Object argName, Set&lt;?&gt; ms) &#123;</span><br><span class="line">   Set&lt;Object&gt; resolved = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(ms.size());</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">//递归解析set的每一个元素</span></span><br><span class="line">   <span class="keyword">for</span> (Object m : ms) &#123;</span><br><span class="line">      resolved.add(resolveValueIfNecessary(<span class="keyword">new</span> KeyedArgName(argName, i), m));</span><br><span class="line">      i++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> resolved;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * For each element in the managed map, resolve reference if necessary.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//解析map类型的属性</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;?, ?&gt; resolveManagedMap(Object argName, Map&lt;?, ?&gt; mm) &#123;</span><br><span class="line">   Map&lt;Object, Object&gt; resolved = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(mm.size());</span><br><span class="line">   <span class="comment">//递归解析map中每一个元素的key和value</span></span><br><span class="line">   <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : mm.entrySet()) &#123;</span><br><span class="line">      Object resolvedKey = resolveValueIfNecessary(argName, entry.getKey());</span><br><span class="line">      Object resolvedValue = resolveValueIfNecessary(</span><br><span class="line">            <span class="keyword">new</span> KeyedArgName(argName, entry.getKey()), entry.getValue());</span><br><span class="line">      resolved.put(resolvedKey, resolvedValue);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> resolved;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码分析，我们明白了 Spring 是如何将引用类型，内部类以及集合类型等属性进行解析的， 属性值解析完成后就可以进行依赖注入了，依赖注入的过程就是 Bean 对象实例设置到它所依赖的 Bean 对象属性上去。而真正的依赖注入是通过 bw.setPropertyValues()方法实现的，该方法也使用了委托模 式，在 BeanWrapper 接口中至少定义了方法声明，依赖注入的具体实现交由其实现类 BeanWrapperImpl 来完成，下面我们就分析依 BeanWrapperImpl 中赖注入相关的源码。</p>
<h3 id="注入赋值"><a href="#注入赋值" class="headerlink" title="注入赋值"></a><strong>注入赋值</strong></h3><p>BeanWrapperImpl 类主要是对容器中完成初始化的 Bean 实例对象进行属性的依赖注入，即把 Bean 对象设置到它所依赖的另一个 Bean 的属性中去。然而，BeanWrapperImpl 中的注入方法实际上由 AbstractNestablePropertyAccessor 来实现的，其相关源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现属性依赖注入功能</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setPropertyValue</span><span class="params">(PropertyTokenHolder tokens, PropertyValue pv)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (tokens.keys != <span class="keyword">null</span>) &#123;</span><br><span class="line">      processKeyedProperty(tokens, pv);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      processLocalProperty(tokens, pv);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现属性依赖注入功能</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processKeyedProperty</span><span class="params">(PropertyTokenHolder tokens, PropertyValue pv)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//调用属性的getter方法，获取属性的值</span></span><br><span class="line">   Object propValue = getPropertyHoldingValue(tokens);</span><br><span class="line">   PropertyHandler ph = getLocalPropertyHandler(tokens.actualName);</span><br><span class="line">   <span class="keyword">if</span> (ph == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InvalidPropertyException(</span><br><span class="line">            getRootClass(), <span class="keyword">this</span>.nestedPath + tokens.actualName, <span class="string">"No property handler found"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   Assert.state(tokens.keys != <span class="keyword">null</span>, <span class="string">"No token keys"</span>);</span><br><span class="line">   String lastKey = tokens.keys[tokens.keys.length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">   <span class="comment">//注入array类型的属性值</span></span><br><span class="line">   <span class="keyword">if</span> (propValue.getClass().isArray()) &#123;</span><br><span class="line">      Class&lt;?&gt; requiredType = propValue.getClass().getComponentType();</span><br><span class="line">      <span class="keyword">int</span> arrayIndex = Integer.parseInt(lastKey);</span><br><span class="line">      Object oldValue = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (isExtractOldValueForEditor() &amp;&amp; arrayIndex &lt; Array.getLength(propValue)) &#123;</span><br><span class="line">            oldValue = Array.get(propValue, arrayIndex);</span><br><span class="line">         &#125;</span><br><span class="line">         Object convertedValue = convertIfNecessary(tokens.canonicalName, oldValue, pv.getValue(),</span><br><span class="line">               requiredType, ph.nested(tokens.keys.length));</span><br><span class="line">         <span class="comment">//获取集合类型属性的长度</span></span><br><span class="line">         <span class="keyword">int</span> length = Array.getLength(propValue);</span><br><span class="line">         <span class="keyword">if</span> (arrayIndex &gt;= length &amp;&amp; arrayIndex &lt; <span class="keyword">this</span>.autoGrowCollectionLimit) &#123;</span><br><span class="line">            Class&lt;?&gt; componentType = propValue.getClass().getComponentType();</span><br><span class="line">            Object newArray = Array.newInstance(componentType, arrayIndex + <span class="number">1</span>);</span><br><span class="line">            System.arraycopy(propValue, <span class="number">0</span>, newArray, <span class="number">0</span>, length);</span><br><span class="line">            setPropertyValue(tokens.actualName, newArray);</span><br><span class="line">            <span class="comment">//调用属性的getter方法，获取属性的值</span></span><br><span class="line">            propValue = getPropertyValue(tokens.actualName);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//将属性的值赋值给数组中的元素</span></span><br><span class="line">         Array.set(propValue, arrayIndex, convertedValue);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> InvalidPropertyException(getRootClass(), <span class="keyword">this</span>.nestedPath + tokens.canonicalName,</span><br><span class="line">               <span class="string">"Invalid array index in property path '"</span> + tokens.canonicalName + <span class="string">"'"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//注入list类型的属性值</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (propValue <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">      <span class="comment">//获取list集合的类型</span></span><br><span class="line">      Class&lt;?&gt; requiredType = ph.getCollectionType(tokens.keys.length);</span><br><span class="line">      List&lt;Object&gt; list = (List&lt;Object&gt;) propValue;</span><br><span class="line">      <span class="comment">//获取list集合的size</span></span><br><span class="line">      <span class="keyword">int</span> index = Integer.parseInt(lastKey);</span><br><span class="line">      Object oldValue = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (isExtractOldValueForEditor() &amp;&amp; index &lt; list.size()) &#123;</span><br><span class="line">         oldValue = list.get(index);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//获取list解析后的属性值</span></span><br><span class="line">      Object convertedValue = convertIfNecessary(tokens.canonicalName, oldValue, pv.getValue(),</span><br><span class="line">            requiredType, ph.nested(tokens.keys.length));</span><br><span class="line">      <span class="keyword">int</span> size = list.size();</span><br><span class="line">      <span class="comment">//如果list的长度大于属性值的长度，则多余的元素赋值为null</span></span><br><span class="line">      <span class="keyword">if</span> (index &gt;= size &amp;&amp; index &lt; <span class="keyword">this</span>.autoGrowCollectionLimit) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &lt; index; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               list.add(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (NullPointerException ex) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> InvalidPropertyException(getRootClass(), <span class="keyword">this</span>.nestedPath + tokens.canonicalName,</span><br><span class="line">                     <span class="string">"Cannot set element with index "</span> + index + <span class="string">" in List of size "</span> +</span><br><span class="line">                     size + <span class="string">", accessed using property path '"</span> + tokens.canonicalName +</span><br><span class="line">                     <span class="string">"': List does not support filling up gaps with null elements"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         list.add(convertedValue);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将值添加到list中</span></span><br><span class="line">            list.set(index, convertedValue);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidPropertyException(getRootClass(), <span class="keyword">this</span>.nestedPath + tokens.canonicalName,</span><br><span class="line">                  <span class="string">"Invalid list index in property path '"</span> + tokens.canonicalName + <span class="string">"'"</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//注入map类型的属性值</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (propValue <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">      <span class="comment">//获取map集合key的类型</span></span><br><span class="line">      Class&lt;?&gt; mapKeyType = ph.getMapKeyType(tokens.keys.length);</span><br><span class="line">      <span class="comment">//获取map集合value的类型</span></span><br><span class="line">      Class&lt;?&gt; mapValueType = ph.getMapValueType(tokens.keys.length);</span><br><span class="line">      Map&lt;Object, Object&gt; map = (Map&lt;Object, Object&gt;) propValue;</span><br><span class="line">      <span class="comment">// IMPORTANT: Do not pass full property name in here - property editors</span></span><br><span class="line">      <span class="comment">// must not kick in for map keys but rather only for map values.</span></span><br><span class="line">      TypeDescriptor typeDescriptor = TypeDescriptor.valueOf(mapKeyType);</span><br><span class="line">      <span class="comment">//解析map类型属性key值</span></span><br><span class="line">      Object convertedMapKey = convertIfNecessary(<span class="keyword">null</span>, <span class="keyword">null</span>, lastKey, mapKeyType, typeDescriptor);</span><br><span class="line">      Object oldValue = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (isExtractOldValueForEditor()) &#123;</span><br><span class="line">         oldValue = map.get(convertedMapKey);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Pass full property name and old value in here, since we want full</span></span><br><span class="line">      <span class="comment">// conversion ability for map values.</span></span><br><span class="line">      <span class="comment">//解析map类型属性value值</span></span><br><span class="line">      Object convertedMapValue = convertIfNecessary(tokens.canonicalName, oldValue, pv.getValue(),</span><br><span class="line">            mapValueType, ph.nested(tokens.keys.length));</span><br><span class="line">      <span class="comment">//将解析后的key和value值赋值给map集合属性</span></span><br><span class="line">      map.put(convertedMapKey, convertedMapValue);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InvalidPropertyException(getRootClass(), <span class="keyword">this</span>.nestedPath + tokens.canonicalName,</span><br><span class="line">            <span class="string">"Property referenced in indexed property path '"</span> + tokens.canonicalName +</span><br><span class="line">            <span class="string">"' is neither an array nor a List nor a Map; returned value was ["</span> + propValue + <span class="string">"]"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getPropertyHoldingValue</span><span class="params">(PropertyTokenHolder tokens)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Apply indexes and map keys: fetch value for all keys but the last one.</span></span><br><span class="line">   Assert.state(tokens.keys != <span class="keyword">null</span>, <span class="string">"No token keys"</span>);</span><br><span class="line">   PropertyTokenHolder getterTokens = <span class="keyword">new</span> PropertyTokenHolder(tokens.actualName);</span><br><span class="line">   getterTokens.canonicalName = tokens.canonicalName;</span><br><span class="line">   getterTokens.keys = <span class="keyword">new</span> String[tokens.keys.length - <span class="number">1</span>];</span><br><span class="line">   System.arraycopy(tokens.keys, <span class="number">0</span>, getterTokens.keys, <span class="number">0</span>, tokens.keys.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   Object propValue;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//获取属性值</span></span><br><span class="line">      propValue = getPropertyValue(getterTokens);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (NotReadablePropertyException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NotWritablePropertyException(getRootClass(), <span class="keyword">this</span>.nestedPath + tokens.canonicalName,</span><br><span class="line">            <span class="string">"Cannot access indexed value in property referenced "</span> +</span><br><span class="line">            <span class="string">"in indexed property path '"</span> + tokens.canonicalName + <span class="string">"'"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (propValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// null map value case</span></span><br><span class="line">      <span class="keyword">if</span> (isAutoGrowNestedPaths()) &#123;</span><br><span class="line">         <span class="keyword">int</span> lastKeyIndex = tokens.canonicalName.lastIndexOf(<span class="string">'['</span>);</span><br><span class="line">         getterTokens.canonicalName = tokens.canonicalName.substring(<span class="number">0</span>, lastKeyIndex);</span><br><span class="line">         propValue = setDefaultValue(getterTokens);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullValueInNestedPathException(getRootClass(), <span class="keyword">this</span>.nestedPath + tokens.canonicalName,</span><br><span class="line">               <span class="string">"Cannot access indexed value in property referenced "</span> +</span><br><span class="line">               <span class="string">"in indexed property path '"</span> + tokens.canonicalName + <span class="string">"': returned null"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> propValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过对上面注入依赖代码的分析，我们已经明白了 Spring IOC 容器是如何将属性的值注入到 Bean 实 例对象中去的:</p>
<ol>
<li><p>对于集合类型的属性，将其属性值解析为目标类型的集合后直接赋值给属性。 </p>
</li>
<li><p>对于非集合类型的属性，大量使用了 JDK 的反射机制，通过属性的 getter()方法获取指定属性注入 以前的值，同时调用属性的 setter()方法为属性设置注入后的值。看到这里相信很多人都明白了 Spring 的 setter()注入原理。</p>
</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg16cposzgj31hy0ll0ua.jpg" alt="一步一步手绘Spring DI运行时序图"></p>
<p>至此 Spring IOC 容器对 Bean 定义资源文件的定位，载入、解析和依赖注入已经全部分析完毕，现在 Spring IOC 容器中管理了一系列靠依赖关系联系起来的 Bean，程序不需要应用自己手动创建所需的对 象，Spring IOC 容器会在我们使用的时候自动为我们创建，并且为我们注入好相关的依赖，这就是 Spring 核心功能的控制反转和依赖注入的相关功能。</p>
<h2 id="IOC-容器中那些鲜为人知的细节"><a href="#IOC-容器中那些鲜为人知的细节" class="headerlink" title="IOC 容器中那些鲜为人知的细节"></a>IOC 容器中那些鲜为人知的细节</h2><p>通过前面章节中对 Spring IOC 容器的源码分析，我们已经基本上了解了 Spring IOC 容器对 Bean 定义 资源的定位、载入和注册过程，同时也清楚了当用户通过 getBean()方法向 IOC 容器获取被管理的 Bean 时，IOC 容器对 Bean 进行的初始化和依赖注入过程，这些是 Spring IOC 容器的基本功能特性。 Spring IOC 容器还有一些高级特性，如使用 lazy-init 属性对 Bean 预初始化、FactoryBean 产生或者 修饰 Bean 对象的生成、IOC 容器初始化 Bean 过程中使用 BeanPostProcessor 后置处理器对 Bean 声 明周期事件管理等。</p>
<h3 id="关于延时加载"><a href="#关于延时加载" class="headerlink" title="关于延时加载"></a><strong>关于延时加载</strong></h3><p>通过前面我们对 IOC 容器的实现和工作原理分析，我们已经知道 IOC 容器的初始化过程就是对 Bean 定义资源的定位、载入和注册，此时容器对 Bean 的依赖注入并没有发生，依赖注入主要是在应用程序 第一次向容器索取 Bean 时，通过 getBean()方法的调用完成。<br> 当 Bean 定义资源的&lt;Bean&gt;元素中配置了 lazy-init=false 属性时，容器将会在初始化的时候对所配置 的 Bean 进行预实例化，Bean 的依赖注入在容器初始化的时候就已经完成。这样，当应用程序第一次 向容器索取被管理的 Bean 时，就不用再初始化和对 Bean 进行依赖注入了，直接从容器中获取已经完 成依赖注入的现成 Bean，可以提高应用第一次向容器获取 Bean 的性能。</p>
<p><strong>1、refresh()方法</strong></p>
<p>先从 IOC 容器的初始化过程开始，我们知道 IOC 容器读入已经定位的 Bean 定义资源是从 refresh()方 法开始的，我们首先从 AbstractApplicationContext 类的 refresh()方法入手分析，源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">      <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">      <span class="comment">//1、调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">      <span class="comment">//2、告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从</span></span><br><span class="line">      <span class="comment">//子类的refreshBeanFactory()方法启动</span></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">      <span class="comment">//3、为BeanFactory配置容器特性，例如类加载器、事件处理器等</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">         <span class="comment">//4、为容器的某些子类指定特殊的BeanPost事件处理器</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">         <span class="comment">//5、调用所有注册的BeanFactoryPostProcessor的Bean</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">         <span class="comment">//6、为BeanFactory注册BeanPost事件处理器.</span></span><br><span class="line">         <span class="comment">//BeanPostProcessor是Bean后置处理器，用于监听容器触发的事件</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">         <span class="comment">//7、初始化信息源，和国际化相关.</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">         <span class="comment">//8、初始化容器事件传播器.</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">         <span class="comment">//9、调用子类的某些特殊Bean初始化方法</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">         <span class="comment">//10、为事件传播器注册事件监听器.</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">         <span class="comment">//11、初始化所有剩余的单例Bean</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">         <span class="comment">//12、初始化容器的生命周期事件处理器，并发布容器的生命周期事件</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                  <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         <span class="comment">//13、销毁已创建的Bean</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">         <span class="comment">//14、取消refresh操作，重置容器的同步标识。</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         <span class="comment">//15、重设公共缓存</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 refresh()方法中 ConfigurableListableBeanFactorybeanFactory = obtainFreshBeanFactory();启动了 Bean 定义资源的载入、注册过程，而 finishBeanFactoryInitialization 方法是对注册后的 Bean定义中的预实例化(lazy-init=false,Spring 默认就是预实例化,即为 true)的 Bean 进行处理的地方。</p>
<p><strong>2、finishBeanFactoryInitialization 处理预实例化 Bean</strong></p>
<p>当 Bean 定义资源被载入 IOC 容器之后，容器将 Bean 定义资源解析为容器内部的数据结构 BeanDefinition 注册到容器中，AbstractApplicationContext 类中的 finishBeanFactoryInitialization() 方法对配置了预实例化属性的 Bean 进行预初始化过程，源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对配置了lazy-init属性的Bean进行预实例化处理</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">   <span class="comment">//这是Spring3以后新加的代码，为容器指定一个转换服务(ConversionService)</span></span><br><span class="line">   <span class="comment">//在对某些Bean属性进行转换时使用</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">      beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">   <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">   <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">      beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">   <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">      getBean(weaverAwareName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">   <span class="comment">//为了类型匹配，停止使用临时的类加载器</span></span><br><span class="line">   beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">   <span class="comment">//缓存容器中所有注册的BeanDefinition元数据，以防被修改</span></span><br><span class="line">   beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">   <span class="comment">//对配置了lazy-init属性的单态模式Bean进行预实例化处理</span></span><br><span class="line">   beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConfigurableListableBeanFactory 是 一 个 接 口 ， 其 preInstantiateSingletons() 方 法 由 其 子 类 DefaultListableBeanFactory 提供。</p>
<p><strong>3、DefaultListableBeanFactory 对配置 lazy-init 属性单态 Bean 的预实例化</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对配置lazy-init属性单态Bean的预实例化</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.logger.debug(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">   <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">   List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">      <span class="comment">//获取指定名称的Bean定义</span></span><br><span class="line">      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">      <span class="comment">//Bean不是抽象的，是单态模式的，且lazy-init属性配置为false</span></span><br><span class="line">      <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">         <span class="comment">//如果指定名称的bean是创建容器的Bean</span></span><br><span class="line">         <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">            <span class="comment">//FACTORY_BEAN_PREFIX=”&amp;”，当Bean名称前面加”&amp;”符号</span></span><br><span class="line">            <span class="comment">//时，获取的是产生容器对象本身，而不是容器产生的Bean.</span></span><br><span class="line">            <span class="comment">//调用getBean方法，触发容器对Bean实例化和依赖注入过程</span></span><br><span class="line">            <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">            <span class="comment">//标识是否需要预实例化</span></span><br><span class="line">            <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">               <span class="comment">//一个匿名内部类</span></span><br><span class="line">               isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt;</span><br><span class="line">                     ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit(),</span><br><span class="line">                     getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                     ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">               <span class="comment">//调用getBean方法，触发容器对Bean实例化和依赖注入过程</span></span><br><span class="line">               getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            getBean(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">      Object singletonInstance = getSingleton(beanName);</span><br><span class="line">      <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">         <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">         <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">               smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过对 lazy-init 处理源码的分析，我们可以看出，如果设置了 lazy-init 属性，则容器在完成 Bean 定 义的注册之后，会通过 getBean 方法，触发对指定 Bean 的初始化和依赖注入过程，这样当应用第一次向容器索取所需的 Bean 时，容器不再需要对 Bean 进行初始化和依赖注入，直接从已经完成实例化和依赖注入的 Bean 中取一个现成的 Bean，这样就提高了第一次获取 Bean 的性能。</p>
<h3 id="关于-FactoryBean-和-BeanFactory"><a href="#关于-FactoryBean-和-BeanFactory" class="headerlink" title="关于 FactoryBean 和 BeanFactory"></a><strong>关于 FactoryBean 和 BeanFactory</strong></h3><p>在 Spring 中，有两个很容易混淆的类:BeanFactory 和 FactoryBean。<br> BeanFactory:Bean 工厂，是一个工厂(Factory)，我们 Spring IOC 容器的最顶层接口就是这个 BeanFactory，它的作用是管理 Bean，即实例化、定位、配置应用程序中的对象及建立这些对象间的 依赖。<br> FactoryBean:工厂 Bean，是一个 Bean，作用是产生其他 bean 实例。通常情况下，这种 Bean 没有 什么特别的要求，仅需要提供一个工厂方法，该方法用来返回其他 Bean 实例。通常情况下，Bean 无 须自己实现工厂模式，Spring 容器担任工厂角色;但少数情况下，容器中的 Bean 本身就是工厂，其作 用是产生其它 Bean 实例。<br> 当用户使用容器本身时，可以使用转义字符”&amp;”来得到 FactoryBean 本身，以区别通过 FactoryBean 产生的实例对象和 FactoryBean 对象本身。在 BeanFactory 中通过如下代码定义了该转义字符: String FACTORY_BEAN_PREFIX = “&amp;”;<br> 如果 myJndiObject 是一个 FactoryBean，则使用&amp;myJndiObject 得到的是 myJndiObject 对象，而 不是 myJndiObject 产生出来的对象。<br> <strong>1、FactoryBean 源码:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工厂Bean，用于产生其他对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return an instance (possibly shared or independent) of the object</span></span><br><span class="line"><span class="comment">    * managed by this factory.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;As with a &#123;<span class="doctag">@link</span> BeanFactory&#125;, this allows support for both the</span></span><br><span class="line"><span class="comment">    * Singleton and Prototype design pattern.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;If this FactoryBean is not fully initialized yet at the time of</span></span><br><span class="line"><span class="comment">    * the call (for example because it is involved in a circular reference),</span></span><br><span class="line"><span class="comment">    * throw a corresponding &#123;<span class="doctag">@link</span> FactoryBeanNotInitializedException&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;As of Spring 2.0, FactoryBeans are allowed to return &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">    * objects. The factory will consider this as normal value to be used; it</span></span><br><span class="line"><span class="comment">    * will not throw a FactoryBeanNotInitializedException in this case anymore.</span></span><br><span class="line"><span class="comment">    * FactoryBean implementations are encouraged to throw</span></span><br><span class="line"><span class="comment">    * FactoryBeanNotInitializedException themselves now, as appropriate.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> an instance of the bean (can be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception in case of creation errors</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> FactoryBeanNotInitializedException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//获取容器管理的对象实例</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the type of object that this FactoryBean creates,</span></span><br><span class="line"><span class="comment">    * or &#123;<span class="doctag">@code</span> null&#125; if not known in advance.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;This allows one to check for specific types of beans without</span></span><br><span class="line"><span class="comment">    * instantiating objects, for example on autowiring.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;In the case of implementations that are creating a singleton object,</span></span><br><span class="line"><span class="comment">    * this method should try to avoid singleton creation as far as possible;</span></span><br><span class="line"><span class="comment">    * it should rather estimate the type in advance.</span></span><br><span class="line"><span class="comment">    * For prototypes, returning a meaningful type here is advisable too.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;This method can be called &lt;i&gt;before&lt;/i&gt; this FactoryBean has</span></span><br><span class="line"><span class="comment">    * been fully initialized. It must not rely on state created during</span></span><br><span class="line"><span class="comment">    * initialization; of course, it can still use such state if available.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; Autowiring will simply ignore FactoryBeans that return</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> null&#125; here. Therefore it is highly recommended to implement</span></span><br><span class="line"><span class="comment">    * this method properly, using the current state of the FactoryBean.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the type of object that this FactoryBean creates,</span></span><br><span class="line"><span class="comment">    * or &#123;<span class="doctag">@code</span> null&#125; if not known at the time of the call</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> ListableBeanFactory#getBeansOfType</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//获取Bean工厂创建的对象的类型</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Is the object managed by this factory a singleton? That is,</span></span><br><span class="line"><span class="comment">    * will &#123;<span class="doctag">@link</span> #getObject()&#125; always return the same object</span></span><br><span class="line"><span class="comment">    * (a reference that can be cached)?</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; If a FactoryBean indicates to hold a singleton object,</span></span><br><span class="line"><span class="comment">    * the object returned from &#123;<span class="doctag">@code</span> getObject()&#125; might get cached</span></span><br><span class="line"><span class="comment">    * by the owning BeanFactory. Hence, do not return &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">    * unless the FactoryBean always exposes the same reference.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;The singleton status of the FactoryBean itself will generally</span></span><br><span class="line"><span class="comment">    * be provided by the owning BeanFactory; usually, it has to be</span></span><br><span class="line"><span class="comment">    * defined as singleton there.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; This method returning &#123;<span class="doctag">@code</span> false&#125; does not</span></span><br><span class="line"><span class="comment">    * necessarily indicate that returned objects are independent instances.</span></span><br><span class="line"><span class="comment">    * An implementation of the extended &#123;<span class="doctag">@link</span> SmartFactoryBean&#125; interface</span></span><br><span class="line"><span class="comment">    * may explicitly indicate independent instances through its</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> SmartFactoryBean#isPrototype()&#125; method. Plain &#123;<span class="doctag">@link</span> FactoryBean&#125;</span></span><br><span class="line"><span class="comment">    * implementations which do not implement this extended interface are</span></span><br><span class="line"><span class="comment">    * simply assumed to always return independent instances if the</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> isSingleton()&#125; implementation returns &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;The default implementation returns &#123;<span class="doctag">@code</span> true&#125;, since a</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> FactoryBean&#125; typically manages a singleton instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> whether the exposed object is a singleton</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getObject()</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> SmartFactoryBean#isPrototype()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//Bean工厂创建的对象是否是单态模式，如果是单态模式，则整个容器中只有一个实例</span></span><br><span class="line">   <span class="comment">//对象，每次请求都返回同一个实例对象</span></span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、AbstractBeanFactory 的 getBean()方法调用 FactoryBean:</strong></p>
<p>在前面我们分析 Spring IOC 容器实例化 Bean 并进行依赖注入过程的源码时，提到在 getBean()方法 触发容器实例化 Bean 的时候会调用 AbstractBeanFactory 的 doGetBean()方法来进行实例化的过程， 源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//真正实现向IOC容器获取Bean的功能，也是触发依赖注入功能的地方</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//根据指定的名称获取被管理Bean的名称，剥离指定名称中对容器的相关依赖</span></span><br><span class="line">   <span class="comment">//如果指定的是别名，将别名转换为规范的Bean名称</span></span><br><span class="line">   <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">   Object bean;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">   <span class="comment">//先从缓存中取是否已经有被创建过的单态类型的Bean</span></span><br><span class="line">   <span class="comment">//对于单例模式的Bean整个IOC容器中只创建一次，不需要重复创建</span></span><br><span class="line">   Object sharedInstance = getSingleton(beanName);</span><br><span class="line">   <span class="comment">//IOC容器创建单例模式Bean实例对象</span></span><br><span class="line">   <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         <span class="comment">//如果指定名称的Bean在容器中已有单例模式的Bean被创建</span></span><br><span class="line">         <span class="comment">//直接返回已经创建的Bean</span></span><br><span class="line">         <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +</span><br><span class="line">                  <span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.debug(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//获取给定Bean的实例对象，主要是完成FactoryBean的相关处理</span></span><br><span class="line">      <span class="comment">//注意：BeanFactory是管理容器中Bean的工厂，而FactoryBean是</span></span><br><span class="line">      <span class="comment">//创建创建对象的工厂Bean，两者之间有区别</span></span><br><span class="line">      bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Fail if we're already creating this bean instance:</span></span><br><span class="line">      <span class="comment">// We're assumably within a circular reference.</span></span><br><span class="line">      <span class="comment">//缓存没有正在创建的单例模式Bean</span></span><br><span class="line">      <span class="comment">//缓存中已经有已经创建的原型模式Bean</span></span><br><span class="line">      <span class="comment">//但是由于循环引用的问题导致实例化对象失败</span></span><br><span class="line">      <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">      <span class="comment">//对IOC容器中是否存在指定名称的BeanDefinition进行检查，首先检查是否</span></span><br><span class="line">      <span class="comment">//能在当前的BeanFactory中获取的所需要的Bean，如果不能则委托当前容器</span></span><br><span class="line">      <span class="comment">//的父级容器去查找，如果还是找不到则沿着容器的继承体系向父级容器查找</span></span><br><span class="line">      BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">      <span class="comment">//当前容器的父级容器存在，且当前容器中不存在指定名称的Bean</span></span><br><span class="line">      <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">         <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">         <span class="comment">//解析指定Bean名称的原始名称</span></span><br><span class="line">         String nameToLookup = originalBeanName(name);</span><br><span class="line">         <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">                  nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">            <span class="comment">//委派父级容器根据指定名称和显式的参数查找</span></span><br><span class="line">            <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">            <span class="comment">//委派父级容器根据指定名称和类型查找</span></span><br><span class="line">            <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//创建的Bean是否需要进行类型验证，一般不需要</span></span><br><span class="line">      <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">         <span class="comment">//向容器标记指定的Bean已经被创建</span></span><br><span class="line">         markBeanAsCreated(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//根据指定Bean名称获取其父级的Bean定义</span></span><br><span class="line">         <span class="comment">//主要解决Bean继承时子类合并父类公共属性问题</span></span><br><span class="line">         <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">         checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">         <span class="comment">//获取当前Bean所有依赖Bean的名称</span></span><br><span class="line">         String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">         <span class="comment">//如果当前Bean有依赖Bean</span></span><br><span class="line">         <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">               <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//递归调用getBean方法，获取当前Bean的依赖Bean</span></span><br><span class="line">               registerDependentBean(dep, beanName);</span><br><span class="line">               <span class="comment">//把被依赖Bean注册给当前依赖的Bean</span></span><br><span class="line">               getBean(dep);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Create bean instance.</span></span><br><span class="line">         <span class="comment">//创建单例模式Bean的实例对象</span></span><br><span class="line">         <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            <span class="comment">//这里使用了一个匿名内部类，创建Bean实例对象，并且注册给所依赖的对象</span></span><br><span class="line">            sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">//创建一个指定Bean实例对象，如果有父级继承，则合并子类和父类的定义</span></span><br><span class="line">                  <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                  <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">                  <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">                  <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">                  <span class="comment">//显式地从容器单例模式Bean缓存中清除实例对象</span></span><br><span class="line">                  destroySingleton(beanName);</span><br><span class="line">                  <span class="keyword">throw</span> ex;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//获取给定Bean的实例对象</span></span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//IOC容器创建原型模式Bean实例对象</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">            <span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">            <span class="comment">//原型模式(Prototype)是每次都会创建一个新的对象</span></span><br><span class="line">            Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//回调beforePrototypeCreation方法，默认的功能是注册当前创建的原型对象</span></span><br><span class="line">               beforePrototypeCreation(beanName);</span><br><span class="line">               <span class="comment">//创建指定Bean对象实例</span></span><br><span class="line">               prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="comment">//回调afterPrototypeCreation方法，默认的功能告诉IOC容器指定Bean的原型对象不再创建</span></span><br><span class="line">               afterPrototypeCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取给定Bean的实例对象</span></span><br><span class="line">            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//要创建的Bean既不是单例模式，也不是原型模式，则根据Bean定义资源中</span></span><br><span class="line">         <span class="comment">//配置的生命周期范围，选择实例化Bean的合适方法，这种在Web应用程序中</span></span><br><span class="line">         <span class="comment">//比较常用，如：request、session、application等生命周期</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            String scopeName = mbd.getScope();</span><br><span class="line">            <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">            <span class="comment">//Bean定义资源中没有配置生命周期范围，则Bean定义不合法</span></span><br><span class="line">            <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//这里又使用了一个匿名内部类，获取一个指定生命周期范围的实例</span></span><br><span class="line">               Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">                  beforePrototypeCreation(beanName);</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                     <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">finally</span> &#123;</span><br><span class="line">                     afterPrototypeCreation(beanName);</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">               <span class="comment">//获取给定Bean的实例对象</span></span><br><span class="line">               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                     <span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line">                     <span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">                     ex);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">   <span class="comment">//对创建的Bean实例对象进行类型检查</span></span><br><span class="line">   <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">         <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> convertedBean;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> +</span><br><span class="line">                  ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取给定Bean的实例对象，主要是完成FactoryBean的相关处理</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Don't let calling code try to dereference the factory if the bean isn't a factory.</span></span><br><span class="line">   <span class="comment">//容器已经得到了Bean实例对象，这个实例对象可能是一个普通的Bean，</span></span><br><span class="line">   <span class="comment">//也可能是一个工厂Bean，如果是一个工厂Bean，则使用它创建一个Bean实例对象，</span></span><br><span class="line">   <span class="comment">//如果调用本身就想获得一个容器的引用，则指定返回这个工厂Bean实例对象</span></span><br><span class="line">   <span class="comment">//如果指定的名称是容器的解引用(dereference，即是对象本身而非内存地址)，</span></span><br><span class="line">   <span class="comment">//且Bean实例也不是创建Bean实例对象的工厂Bean</span></span><br><span class="line">   <span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Now we have the bean instance, which may be a normal bean or a FactoryBean.</span></span><br><span class="line">   <span class="comment">// If it's a FactoryBean, we use it to create a bean instance, unless the</span></span><br><span class="line">   <span class="comment">// caller actually wants a reference to the factory.</span></span><br><span class="line">   <span class="comment">//如果Bean实例不是工厂Bean，或者指定名称是容器的解引用，</span></span><br><span class="line">   <span class="comment">//调用者向获取对容器的引用，则直接返回当前的Bean实例</span></span><br><span class="line">   <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> beanInstance;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//处理指定名称不是容器的解引用，或者根据名称获取的Bean实例对象是一个工厂Bean</span></span><br><span class="line">   <span class="comment">//使用工厂Bean创建一个Bean的实例对象</span></span><br><span class="line">   Object object = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (mbd == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//从Bean工厂缓存中获取给定名称的Bean实例对象</span></span><br><span class="line">      object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//让Bean工厂生产给定名称的Bean对象实例</span></span><br><span class="line">   <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Return bean instance from factory.</span></span><br><span class="line">      FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">      <span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line">      <span class="comment">//如果从Bean工厂生产的Bean是单态模式的，则缓存</span></span><br><span class="line">      <span class="keyword">if</span> (mbd == <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">         <span class="comment">//从容器中获取指定名称的Bean定义，如果继承基类，则合并基类相关属性</span></span><br><span class="line">         mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果从容器得到Bean定义信息，并且Bean定义信息不是虚构的，</span></span><br><span class="line">      <span class="comment">//则让工厂Bean生产Bean实例对象</span></span><br><span class="line">      <span class="keyword">boolean</span> synthetic = (mbd != <span class="keyword">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">      <span class="comment">//调用FactoryBeanRegistrySupport类的getObjectFromFactoryBean方法，</span></span><br><span class="line">      <span class="comment">//实现工厂Bean生产Bean对象实例的过程</span></span><br><span class="line">      object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面获取给定 Bean 的实例对象的 getObjectForBeanInstance()方法中，会调用 FactoryBeanRegistrySupport 类的 getObjectFromFactoryBean()方法，该方法实现了 Bean 工厂生 产 Bean 实例对象。</p>
<p>Dereference(解引用):一个在 C/C++中应用比较多的术语，在 C++中，”*”是解引用符号，而”&amp;” 是引用符号，解引用是指变量指向的是所引用对象的本身数据，而不是引用对象的内存地址。</p>
<p><strong>3、AbstractBeanFactory 生产 Bean 实例对象</strong></p>
<p>AbstractBeanFactory 类中生产 Bean 实例对象的主要源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Bean工厂生产Bean实例对象</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectFromFactoryBean</span><span class="params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="keyword">boolean</span> shouldPostProcess)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//Bean工厂是单态模式，并且Bean工厂缓存中存在指定名称的Bean实例对象</span></span><br><span class="line">   <span class="keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line">      <span class="comment">//多线程同步，以防止数据不一致</span></span><br><span class="line">      <span class="keyword">synchronized</span> (getSingletonMutex()) &#123;</span><br><span class="line">         <span class="comment">//直接从Bean工厂缓存中获取指定名称的Bean实例对象</span></span><br><span class="line">         Object object = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">         <span class="comment">//Bean工厂缓存中没有指定名称的实例对象，则生产该实例对象</span></span><br><span class="line">         <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//调用Bean工厂的getObject方法生产指定Bean的实例对象</span></span><br><span class="line">            object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">            <span class="comment">// Only post-process and store if not put there already during getObject() call above</span></span><br><span class="line">            <span class="comment">// (e.g. because of circular reference processing triggered by custom getBean calls)</span></span><br><span class="line">            Object alreadyThere = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (alreadyThere != <span class="keyword">null</span>) &#123;</span><br><span class="line">               object = alreadyThere;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                     object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                     <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                           <span class="string">"Post-processing of FactoryBean's singleton object failed"</span>, ex);</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//将生产的实例对象添加到Bean工厂缓存中</span></span><br><span class="line">               <span class="keyword">this</span>.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> object;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//调用Bean工厂的getObject方法生产指定Bean的实例对象</span></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      Object object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">      <span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Post-processing of FactoryBean's object failed"</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> object;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtain an object to expose from the given FactoryBean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factory the FactoryBean instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the object obtained from the FactoryBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanCreationException if FactoryBean object creation failed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.FactoryBean#getObject()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//调用Bean工厂的getObject方法生产指定Bean的实例对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">doGetObjectFromFactoryBean</span><span class="params">(<span class="keyword">final</span> FactoryBean&lt;?&gt; factory, <span class="keyword">final</span> String beanName)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">   Object object;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">         AccessControlContext acc = getAccessControlContext();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//实现PrivilegedExceptionAction接口的匿名内置类</span></span><br><span class="line">            <span class="comment">//根据JVM检查权限，然后决定BeanFactory创建实例对象</span></span><br><span class="line">            object = AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt;</span><br><span class="line">                  factory.getObject(), acc);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">            <span class="keyword">throw</span> pae.getException();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//调用BeanFactory接口实现类的创建对象方法</span></span><br><span class="line">         object = factory.getObject();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (FactoryBeanNotInitializedException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName, ex.toString());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"FactoryBean threw exception on object creation"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Do not accept a null value for a FactoryBean that's not fully</span></span><br><span class="line">   <span class="comment">// initialized yet: Many FactoryBeans just return null then.</span></span><br><span class="line">   <span class="comment">//创建出来的实例对象为null，或者因为单态对象正在创建而返回null</span></span><br><span class="line">   <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(</span><br><span class="line">               beanName, <span class="string">"FactoryBean which is currently in creation returned null from getObject"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      object = <span class="keyword">new</span> NullBean();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的源码分析中，我们可以看出，BeanFactory 接口调用其实现类的 getObject 方法来实现创建 Bean 实例对象的功能。</p>
<p><strong>4、工厂 Bean 的实现类 getObject 方法创建 Bean 实例对象</strong></p>
<p>FactoryBean 的实现类有非常多，比如:Proxy、RMI、JNDI、ServletContextFactoryBean 等等， FactoryBean 接口为 Spring 容器提供了一个很好的封装机制，具体的 getObject()有不同的实现类根 据不同的实现策略来具体提供，我们分析一个最简单的 AnnotationTestFactoryBean 的实现源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTestBeanFactory</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">FactoryCreatedAnnotationTestBean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> FactoryCreatedAnnotationTestBean instance = <span class="keyword">new</span> FactoryCreatedAnnotationTestBean();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AnnotationTestBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.instance.setName(<span class="string">"FACTORY"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> FactoryCreatedAnnotationTestBean <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.instance;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//AnnotationTestBeanFactory产生Bean实例对象的实现</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Class&lt;? extends IJmxTestBean&gt; getObjectType() &#123;</span><br><span class="line">      <span class="keyword">return</span> FactoryCreatedAnnotationTestBean<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他的 Proxy，RMI，JNDI 等等，都是根据相应的策略提供 getObject()的实现。这里不做一一分析，这已经不是 Spring 的核心功能，感兴趣的小伙可以再去深入研究。</p>
<h3 id="再述-autowiring"><a href="#再述-autowiring" class="headerlink" title="再述 autowiring"></a><strong>再述 autowiring</strong></h3><p>Spring IOC 容器提供了两种管理 Bean 依赖关系的方式:</p>
<ol>
<li><p>显式管理:通过 BeanDefinition 的属性值和构造方法实现 Bean 依赖关系管理。</p>
</li>
<li><p>autowiring:Spring IOC 容器的依赖自动装配功能，不需要对 Bean 属性的依赖关系做显式的声明，只需要在配置好 autowiring 属性，IOC 容器会自动使用反射查找属性的类型和名称，然后基于属性的类型或者名称来自动匹配容器中管理的 Bean，从而自动地完成依赖注入。</p>
</li>
</ol>
<p>通过对 autowiring 自动装配特性的理解，我们知道容器对 Bean 的自动装配发生在容器对 Bean 依赖注入的过程中。在前面对 Spring IOC 容器的依赖注入过程源码分析中，我们已经知道了容器对 Bean 实例对象的属性注入的处理发生在AbstractAutoWireCapableBeanFactory 类中的 populateBean()方法中，我们通过程序流程分析 autowiring 的实现原理:</p>
<p><strong>1、AbstractAutoWireCapableBeanFactory 对 Bean 实例进行属性依赖注入</strong></p>
<p>应用第一次通过 getBean()方法(配置了 lazy-init 预实例化属性的除外)向 IOC 容器索取 Bean 时，容器 创 建 Bean 实 例 对 象 ， 并 且 对 Bean 实 例 对 象 进 行 属 性 依 赖 注 入 ， AbstractAutoWireCapableBeanFactory 的 populateBean()方法就是实现 Bean 属性依赖注入的功 能，其主要源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将Bean属性设置到生成的实例对象上</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">               mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span></span><br><span class="line">   <span class="comment">// state of the bean before properties are set. This can be used, for example,</span></span><br><span class="line">   <span class="comment">// to support styles of field injection.</span></span><br><span class="line">   <span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">               continueWithPropertyPopulation = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//获取容器在解析Bean定义资源时为BeanDefiniton中设置的属性值</span></span><br><span class="line">   PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//对依赖注入处理，首先处理autowiring自动装配的依赖注入</span></span><br><span class="line">   <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">      MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">      <span class="comment">//根据Bean名称进行autowiring自动装配处理</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">         autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">      <span class="comment">//根据Bean类型进行autowiring自动装配处理</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">         autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      pvs = newPvs;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//对非autowiring的属性进行依赖注入处理</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">   <span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">         pvs = mbd.getPropertyValues();</span><br><span class="line">      &#125;</span><br><span class="line">      PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">      <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">         <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">               InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">               pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">               <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">         checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//对属性进行注入</span></span><br><span class="line">      applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、Spring IOC 容器根据 Bean 名称或者类型进行 autowiring 自动依赖注入</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据名称对属性进行自动依赖注入</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">autowireByName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//对Bean对象中非简单属性(不是简单继承的对象，如8中原始类型，字符串，URL等都是简单属性)进行处理</span></span><br><span class="line">   String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">   <span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line">      <span class="comment">//如果Spring IOC容器中包含指定名称的Bean</span></span><br><span class="line">      <span class="keyword">if</span> (containsBean(propertyName)) &#123;</span><br><span class="line">         <span class="comment">//调用getBean方法向IOC容器索取指定名称的Bean实例，迭代触发属性的初始化和依赖注入</span></span><br><span class="line">         Object bean = getBean(propertyName);</span><br><span class="line">         <span class="comment">//为指定名称的属性赋予属性值</span></span><br><span class="line">         pvs.add(propertyName, bean);</span><br><span class="line">         <span class="comment">//指定名称属性注册依赖Bean名称，进行属性依赖注入</span></span><br><span class="line">         registerDependentBean(propertyName, beanName);</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Added autowiring by name from bean name '"</span> + beanName +</span><br><span class="line">                  <span class="string">"' via property '"</span> + propertyName + <span class="string">"' to bean named '"</span> + propertyName + <span class="string">"'"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Not autowiring property '"</span> + propertyName + <span class="string">"' of bean '"</span> + beanName +</span><br><span class="line">                  <span class="string">"' by name: no matching bean found"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Abstract method defining "autowire by type" (bean properties by type) behavior.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is like PicoContainer default, in which there must be exactly one bean</span></span><br><span class="line"><span class="comment"> * of the property type in the bean factory. This makes bean factories simple to</span></span><br><span class="line"><span class="comment"> * configure for small namespaces, but doesn't work as well as standard Spring</span></span><br><span class="line"><span class="comment"> * behavior for bigger applications.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean to autowire by type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the merged bean definition to update through autowiring</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bw BeanWrapper from which we can obtain information about the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pvs the PropertyValues to register wired objects with</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//根据类型对属性进行自动依赖注入</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">autowireByType</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取用户定义的类型转换器</span></span><br><span class="line">   TypeConverter converter = getCustomTypeConverter();</span><br><span class="line">   <span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">      converter = bw;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//存放解析的要注入的属性</span></span><br><span class="line">   Set&lt;String&gt; autowiredBeanNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">   <span class="comment">//对Bean对象中非简单属性(不是简单继承的对象，如8中原始类型，字符</span></span><br><span class="line">   <span class="comment">//URL等都是简单属性)进行处理</span></span><br><span class="line">   String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">   <span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//获取指定属性名称的属性描述器</span></span><br><span class="line">         PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);</span><br><span class="line">         <span class="comment">// Don't try autowiring by type for type Object: never makes sense,</span></span><br><span class="line">         <span class="comment">// even if it technically is a unsatisfied, non-simple property.</span></span><br><span class="line">         <span class="comment">//不对Object类型的属性进行autowiring自动依赖注入</span></span><br><span class="line">         <span class="keyword">if</span> (Object<span class="class">.<span class="keyword">class</span> !</span>= pd.getPropertyType()) &#123;</span><br><span class="line">            <span class="comment">//获取属性的setter方法</span></span><br><span class="line">            MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);</span><br><span class="line">            <span class="comment">// Do not allow eager init for type matching in case of a prioritized post-processor.</span></span><br><span class="line">            <span class="comment">//检查指定类型是否可以被转换为目标对象的类型</span></span><br><span class="line">            <span class="keyword">boolean</span> eager = !PriorityOrdered<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">bw</span>.<span class="title">getWrappedInstance</span>())</span>;</span><br><span class="line">            <span class="comment">//创建一个要被注入的依赖描述</span></span><br><span class="line">            DependencyDescriptor desc = <span class="keyword">new</span> AutowireByTypeDependencyDescriptor(methodParam, eager);</span><br><span class="line">            <span class="comment">//根据容器的Bean定义解析依赖关系，返回所有要被注入的Bean对象</span></span><br><span class="line">            Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);</span><br><span class="line">            <span class="keyword">if</span> (autowiredArgument != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//为属性赋值所引用的对象</span></span><br><span class="line">               pvs.add(propertyName, autowiredArgument);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (String autowiredBeanName : autowiredBeanNames) &#123;</span><br><span class="line">               <span class="comment">//指定名称属性注册依赖Bean名称，进行属性依赖注入</span></span><br><span class="line">               registerDependentBean(autowiredBeanName, beanName);</span><br><span class="line">               <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                  logger.debug(<span class="string">"Autowiring by type from bean name '"</span> + beanName + <span class="string">"' via property '"</span> +</span><br><span class="line">                        propertyName + <span class="string">"' to bean named '"</span> + autowiredBeanName + <span class="string">"'"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//释放已自动注入的属性</span></span><br><span class="line">            autowiredBeanNames.clear();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的源码分析，我们可以看出来通过属性名进行自动依赖注入的相对比通过属性类型进行自动依 赖注入要稍微简单一些，但是真正实现属性注入的是 DefaultSingletonBeanRegistry 类的 registerDependentBean()方法。</p>
<p><strong>3、DefaultSingletonBeanRegistry 的 registerDependentBean()方法对属性注入</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为指定的Bean注入依赖的Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerDependentBean</span><span class="params">(String beanName, String dependentBeanName)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// A quick check for an existing entry upfront, avoiding synchronization...</span></span><br><span class="line">   <span class="comment">//处理Bean名称，将别名转换为规范的Bean名称</span></span><br><span class="line">   String canonicalName = canonicalName(beanName);</span><br><span class="line">   Set&lt;String&gt; dependentBeans = <span class="keyword">this</span>.dependentBeanMap.get(canonicalName);</span><br><span class="line">   <span class="keyword">if</span> (dependentBeans != <span class="keyword">null</span> &amp;&amp; dependentBeans.contains(dependentBeanName)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// No entry yet -&gt; fully synchronized manipulation of the dependentBeans Set</span></span><br><span class="line">   <span class="comment">//多线程同步，保证容器内数据的一致性</span></span><br><span class="line">   <span class="comment">//先从容器中：bean名称--&gt;全部依赖Bean名称集合找查找给定名称Bean的依赖Bean</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.dependentBeanMap) &#123;</span><br><span class="line">      <span class="comment">//获取给定名称Bean的所有依赖Bean名称</span></span><br><span class="line">      dependentBeans = <span class="keyword">this</span>.dependentBeanMap.get(canonicalName);</span><br><span class="line">      <span class="keyword">if</span> (dependentBeans == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">//为Bean设置依赖Bean信息</span></span><br><span class="line">         dependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">         <span class="keyword">this</span>.dependentBeanMap.put(canonicalName, dependentBeans);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//向容器中：bean名称--&gt;全部依赖Bean名称集合添加Bean的依赖信息</span></span><br><span class="line">      <span class="comment">//即，将Bean所依赖的Bean添加到容器的集合中</span></span><br><span class="line">      dependentBeans.add(dependentBeanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//从容器中：bean名称--&gt;指定名称Bean的依赖Bean集合找查找给定名称Bean的依赖Bean</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.dependenciesForBeanMap) &#123;</span><br><span class="line">      Set&lt;String&gt; dependenciesForBean = <span class="keyword">this</span>.dependenciesForBeanMap.get(dependentBeanName);</span><br><span class="line">      <span class="keyword">if</span> (dependenciesForBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">         dependenciesForBean = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">         <span class="keyword">this</span>.dependenciesForBeanMap.put(dependentBeanName, dependenciesForBean);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//向容器中：bean名称--&gt;指定Bean的依赖Bean名称集合添加Bean的依赖信息</span></span><br><span class="line">      <span class="comment">//即，将Bean所依赖的Bean添加到容器的集合中</span></span><br><span class="line">      dependenciesForBean.add(canonicalName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过对 autowiring 的源码分析，我们可以看出，autowiring 的实现过程:</p>
<ol>
<li><p>对 Bean 的属性代调用 getBean()方法，完成依赖 Bean 的初始化和依赖注入。</p>
</li>
<li><p>将依赖 Bean 的属性引用设置到被依赖的 Bean 属性上。</p>
</li>
<li><p>将依赖 Bean 的名称和被依赖 Bean 的名称存储在 IOC 容器的集合中。</p>
</li>
</ol>
<p>Spring IOC 容器的 autowiring 属性自动依赖注入是一个很方便的特性，可以简化开发时的配置，但是凡是都有两面性，自动属性依赖注入也有不足，首先，Bean 的依赖关系在 配置文件中无法很清楚地看出来，对于维护造成一定困难。其次，由于自动依赖注入是 Spring 容器自动执行的，容器是不会智能判断的，如果配置不当，将会带来无法预料的后果，所以自动依赖注入特性在使用时还是综合考虑。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shoufengsfsf.github.io/2020/06/22/4%E5%BC%A0%E5%9B%BE%E5%B8%A6%E4%BD%A0%E8%AF%BB%E6%87%82Spring-IoC%E7%9A%84%E4%B8%96%E7%95%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shoufeng">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shoufengsfsf.github.io">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/22/4%E5%BC%A0%E5%9B%BE%E5%B8%A6%E4%BD%A0%E8%AF%BB%E6%87%82Spring-IoC%E7%9A%84%E4%B8%96%E7%95%8C/" class="post-title-link" itemprop="url">4张图带你读懂Spring-IoC的世界</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-22 14:57:21 / 修改时间：15:00:50" itemprop="dateCreated datePublished" datetime="2020-06-22T14:57:21+08:00">2020-06-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">spring源码解读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="4张图带你读懂Spring-IoC的世界"><a href="#4张图带你读懂Spring-IoC的世界" class="headerlink" title="4张图带你读懂Spring-IoC的世界"></a>4张图带你读懂Spring-IoC的世界</h1><h2 id="1-Bean-的转换过程"><a href="#1-Bean-的转换过程" class="headerlink" title="1. Bean 的转换过程"></a>1. Bean 的转换过程</h2><p>下面这张图演示了一个可用的 bean 是如何从 xml 配置文件中演变过来的。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg12rvv7mtj318g0tljup.jpg" alt="img"></p>
<h2 id="2-ApplicationContext-的架构图"><a href="#2-ApplicationContext-的架构图" class="headerlink" title="2. ApplicationContext 的架构图"></a>2. ApplicationContext 的架构图</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg12s8ndumj31w80se0yy.jpg" alt="img"></p>
<h2 id="3-load-BeanDefinition-的全流程"><a href="#3-load-BeanDefinition-的全流程" class="headerlink" title="3. load BeanDefinition 的全流程"></a>3. load BeanDefinition 的全流程</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg12soffd0j30wb0u0adh.jpg" alt="img"></p>
<h2 id="4-get-Bean-的全流程"><a href="#4-get-Bean-的全流程" class="headerlink" title="4. get Bean 的全流程"></a>4. get Bean 的全流程</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg12t5ien9j30u03c8anv.jpg" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shoufengsfsf.github.io/2020/06/21/spring%E6%BA%90%E7%A0%81%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shoufeng">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shoufengsfsf.github.io">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/21/spring%E6%BA%90%E7%A0%81%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">spring源码问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-21 22:50:13 / 修改时间：22:55:28" itemprop="dateCreated datePublished" datetime="2020-06-21T22:50:13+08:00">2020-06-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">spring源码解读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="spring源码问题"><a href="#spring源码问题" class="headerlink" title="spring源码问题"></a>spring源码问题</h1><h2 id="1、如何统一配置文件的标准？"><a href="#1、如何统一配置文件的标准？" class="headerlink" title="1、如何统一配置文件的标准？"></a>1、如何统一配置文件的标准？</h2><p>BeanDefinition</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SpringIOC容器管理了我们定义的各种Bean对象及其相互的关系，Bean对象在Spring实现中是以BeanDefinition来描述的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinition</span> <span class="keyword">extends</span> <span class="title">AttributeAccessor</span>, <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Scope identifier for the standard singleton scope: "singleton".</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Note that extended bean factories might support further scopes.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setScope</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Scope identifier for the standard prototype scope: "prototype".</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Note that extended bean factories might support further scopes.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setScope</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Role hint indicating that a &#123;<span class="doctag">@code</span> BeanDefinition&#125; is a major part</span></span><br><span class="line"><span class="comment">    * of the application. Typically corresponds to a user-defined bean.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">int</span> ROLE_APPLICATION = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Role hint indicating that a &#123;<span class="doctag">@code</span> BeanDefinition&#125; is a supporting</span></span><br><span class="line"><span class="comment">    * part of some larger configuration, typically an outer</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.parsing.ComponentDefinition&#125;.</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> SUPPORT&#125; beans are considered important enough to be aware</span></span><br><span class="line"><span class="comment">    * of when looking more closely at a particular</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.parsing.ComponentDefinition&#125;,</span></span><br><span class="line"><span class="comment">    * but not when looking at the overall configuration of an application.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">int</span> ROLE_SUPPORT = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Role hint indicating that a &#123;<span class="doctag">@code</span> BeanDefinition&#125; is providing an</span></span><br><span class="line"><span class="comment">    * entirely background role and has no relevance to the end-user. This hint is</span></span><br><span class="line"><span class="comment">    * used when registering beans that are completely part of the internal workings</span></span><br><span class="line"><span class="comment">    * of a &#123;<span class="doctag">@link</span> org.springframework.beans.factory.parsing.ComponentDefinition&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">int</span> ROLE_INFRASTRUCTURE = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Modifiable attributes</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set the name of the parent definition of this bean definition, if any.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setParentName</span><span class="params">(@Nullable String parentName)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the name of the parent definition of this bean definition, if any.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">String <span class="title">getParentName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Specify the bean class name of this bean definition.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;The class name can be modified during bean factory post-processing,</span></span><br><span class="line"><span class="comment">    * typically replacing the original class name with a parsed variant of it.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setParentName</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setFactoryBeanName</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setFactoryMethodName</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(@Nullable String beanClassName)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the current bean class name of this bean definition.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Note that this does not have to be the actual class name used at runtime, in</span></span><br><span class="line"><span class="comment">    * case of a child definition overriding/inheriting the class name from its parent.</span></span><br><span class="line"><span class="comment">    * Also, this may just be the class that a factory method is called on, or it may</span></span><br><span class="line"><span class="comment">    * even be empty in case of a factory bean reference that a method is called on.</span></span><br><span class="line"><span class="comment">    * Hence, do &lt;i&gt;not&lt;/i&gt; consider this to be the definitive bean type at runtime but</span></span><br><span class="line"><span class="comment">    * rather only use it for parsing purposes at the individual bean definition level.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getParentName()</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getFactoryBeanName()</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getFactoryMethodName()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">String <span class="title">getBeanClassName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Override the target scope of this bean, specifying a new scope name.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #SCOPE_SINGLETON</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #SCOPE_PROTOTYPE</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setScope</span><span class="params">(@Nullable String scope)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the name of the current target scope for this bean,</span></span><br><span class="line"><span class="comment">    * or &#123;<span class="doctag">@code</span> null&#125; if not known yet.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">String <span class="title">getScope</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set whether this bean should be lazily initialized.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;If &#123;<span class="doctag">@code</span> false&#125;, the bean will get instantiated on startup by bean</span></span><br><span class="line"><span class="comment">    * factories that perform eager initialization of singletons.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setLazyInit</span><span class="params">(<span class="keyword">boolean</span> lazyInit)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return whether this bean should be lazily initialized, i.e. not</span></span><br><span class="line"><span class="comment">    * eagerly instantiated on startup. Only applicable to a singleton bean.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isLazyInit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set the names of the beans that this bean depends on being initialized.</span></span><br><span class="line"><span class="comment">    * The bean factory will guarantee that these beans get initialized first.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setDependsOn</span><span class="params">(@Nullable String... dependsOn)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the bean names that this bean depends on.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   String[] getDependsOn();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set whether this bean is a candidate for getting autowired into some other bean.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Note that this flag is designed to only affect type-based autowiring.</span></span><br><span class="line"><span class="comment">    * It does not affect explicit references by name, which will get resolved even</span></span><br><span class="line"><span class="comment">    * if the specified bean is not marked as an autowire candidate. As a consequence,</span></span><br><span class="line"><span class="comment">    * autowiring by name will nevertheless inject a bean if the name matches.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setAutowireCandidate</span><span class="params">(<span class="keyword">boolean</span> autowireCandidate)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return whether this bean is a candidate for getting autowired into some other bean.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set whether this bean is a primary autowire candidate.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;If this value is &#123;<span class="doctag">@code</span> true&#125; for exactly one bean among multiple</span></span><br><span class="line"><span class="comment">    * matching candidates, it will serve as a tie-breaker.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setPrimary</span><span class="params">(<span class="keyword">boolean</span> primary)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return whether this bean is a primary autowire candidate.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isPrimary</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Specify the factory bean to use, if any.</span></span><br><span class="line"><span class="comment">    * This the name of the bean to call the specified factory method on.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setFactoryMethodName</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setFactoryBeanName</span><span class="params">(@Nullable String factoryBeanName)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the factory bean name, if any.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">String <span class="title">getFactoryBeanName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Specify a factory method, if any. This method will be invoked with</span></span><br><span class="line"><span class="comment">    * constructor arguments, or with no arguments if none are specified.</span></span><br><span class="line"><span class="comment">    * The method will be invoked on the specified factory bean, if any,</span></span><br><span class="line"><span class="comment">    * or otherwise as a static method on the local bean class.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setFactoryBeanName</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setBeanClassName</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setFactoryMethodName</span><span class="params">(@Nullable String factoryMethodName)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return a factory method, if any.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">String <span class="title">getFactoryMethodName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the constructor argument values for this bean.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;The returned instance can be modified during bean factory post-processing.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the ConstructorArgumentValues object (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">ConstructorArgumentValues <span class="title">getConstructorArgumentValues</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return if there are constructor argument values defined for this bean.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 5.0.2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">hasConstructorArgumentValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> !getConstructorArgumentValues().isEmpty();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the property values to be applied to a new instance of the bean.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;The returned instance can be modified during bean factory post-processing.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the MutablePropertyValues object (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">MutablePropertyValues <span class="title">getPropertyValues</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return if there are property values values defined for this bean.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 5.0.2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">hasPropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> !getPropertyValues().isEmpty();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Read-only attributes</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return whether this a &lt;b&gt;Singleton&lt;/b&gt;, with a single, shared instance</span></span><br><span class="line"><span class="comment">    * returned on all calls.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #SCOPE_SINGLETON</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return whether this a &lt;b&gt;Prototype&lt;/b&gt;, with an independent instance</span></span><br><span class="line"><span class="comment">    * returned for each call.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #SCOPE_PROTOTYPE</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return whether this bean is "abstract", that is, not meant to be instantiated.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isAbstract</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Get the role hint for this &#123;<span class="doctag">@code</span> BeanDefinition&#125;. The role hint</span></span><br><span class="line"><span class="comment">    * provides the frameworks as well as tools with an indication of</span></span><br><span class="line"><span class="comment">    * the role and importance of a particular &#123;<span class="doctag">@code</span> BeanDefinition&#125;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #ROLE_APPLICATION</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #ROLE_SUPPORT</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #ROLE_INFRASTRUCTURE</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getRole</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return a human-readable description of this bean definition.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return a description of the resource that this bean definition</span></span><br><span class="line"><span class="comment">    * came from (for the purpose of showing context in case of errors).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">String <span class="title">getResourceDescription</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the originating BeanDefinition, or &#123;<span class="doctag">@code</span> null&#125; if none.</span></span><br><span class="line"><span class="comment">    * Allows for retrieving the decorated bean definition, if any.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Note that this method returns the immediate originator. Iterate through the</span></span><br><span class="line"><span class="comment">    * originator chain to find the original BeanDefinition as defined by the user.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">BeanDefinition <span class="title">getOriginatingBeanDefinition</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、IOC容器最顶层接口"><a href="#2、IOC容器最顶层接口" class="headerlink" title="2、IOC容器最顶层接口"></a>2、IOC容器最顶层接口</h2><p>BeanFactory</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在BeanFactory里只对IOC容器的基本行为作了定义，根本不关心你的Bean是如何定义怎样加载的。</span></span><br><span class="line"><span class="comment">//正如我们只关心工厂里得到什么的产品对象，至于工厂是怎么生产这些对象的，这个基本的接口不关心。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Used to dereference a &#123;<span class="doctag">@link</span> FactoryBean&#125; instance and distinguish it from</span></span><br><span class="line"><span class="comment">    * beans &lt;i&gt;created&lt;/i&gt; by the FactoryBean. For example, if the bean named</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> myJndiObject&#125; is a FactoryBean, getting &#123;<span class="doctag">@code</span> &amp;myJndiObject&#125;</span></span><br><span class="line"><span class="comment">    * will return the factory, not the instance returned by the factory.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//对FactoryBean的转义定义，因为如果使用bean的名字检索FactoryBean得到的对象是工厂生成的对象，</span></span><br><span class="line">   <span class="comment">//如果需要得到工厂本身，需要转义</span></span><br><span class="line">   String FACTORY_BEAN_PREFIX = <span class="string">"&amp;"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;This method allows a Spring BeanFactory to be used as a replacement for the</span></span><br><span class="line"><span class="comment">    * Singleton or Prototype design pattern. Callers may retain references to</span></span><br><span class="line"><span class="comment">    * returned objects in the case of Singleton beans.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean definition</span></span><br><span class="line"><span class="comment">    * with the specified name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeansException if the bean could not be obtained</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//根据bean的名字，获取在IOC容器中得到bean实例</span></span><br><span class="line">   <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Behaves the same as &#123;<span class="doctag">@link</span> #getBean(String)&#125;, but provides a measure of type</span></span><br><span class="line"><span class="comment">    * safety by throwing a BeanNotOfRequiredTypeException if the bean is not of the</span></span><br><span class="line"><span class="comment">    * required type. This means that ClassCastException can't be thrown on casting</span></span><br><span class="line"><span class="comment">    * the result correctly, as can happen with &#123;<span class="doctag">@link</span> #getBean(String)&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> requiredType type the bean must match. Can be an interface or superclass</span></span><br><span class="line"><span class="comment">    * of the actual class, or &#123;<span class="doctag">@code</span> null&#125; for any match. For example, if the value</span></span><br><span class="line"><span class="comment">    * is &#123;<span class="doctag">@code</span> Object.class&#125;, this method will succeed whatever the class of the</span></span><br><span class="line"><span class="comment">    * returned instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no such bean definition</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeanNotOfRequiredTypeException if the bean is not of the required type</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//根据bean的名字和Class类型来得到bean实例，增加了类型安全验证机制。</span></span><br><span class="line">   &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, @Nullable Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Allows for specifying explicit constructor arguments / factory method arguments,</span></span><br><span class="line"><span class="comment">    * overriding the specified default arguments (if any) in the bean definition.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment">    * (only applied when creating a new instance as opposed to retrieving an existing one)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no such bean definition</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeanDefinitionStoreException if arguments have been given but</span></span><br><span class="line"><span class="comment">    * the affected bean isn't a prototype</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the bean instance that uniquely matches the given object type, if any.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;This method goes into &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; by-type lookup territory</span></span><br><span class="line"><span class="comment">    * but may also be translated into a conventional by-name lookup based on the name</span></span><br><span class="line"><span class="comment">    * of the given type. For more extensive retrieval operations across sets of beans,</span></span><br><span class="line"><span class="comment">    * use &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; and/or &#123;<span class="doctag">@link</span> BeanFactoryUtils&#125;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> requiredType type the bean must match; can be an interface or superclass.</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> null&#125; is disallowed.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> an instance of the single bean matching the required type</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if no bean of the given type was found</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoUniqueBeanDefinitionException if more than one bean of the given type was found</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> ListableBeanFactory</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Allows for specifying explicit constructor arguments / factory method arguments,</span></span><br><span class="line"><span class="comment">    * overriding the specified default arguments (if any) in the bean definition.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;This method goes into &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; by-type lookup territory</span></span><br><span class="line"><span class="comment">    * but may also be translated into a conventional by-name lookup based on the name</span></span><br><span class="line"><span class="comment">    * of the given type. For more extensive retrieval operations across sets of beans,</span></span><br><span class="line"><span class="comment">    * use &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; and/or &#123;<span class="doctag">@link</span> BeanFactoryUtils&#125;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> requiredType type the bean must match; can be an interface or superclass.</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> null&#125; is disallowed.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment">    * (only applied when creating a new instance as opposed to retrieving an existing one)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no such bean definition</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeanDefinitionStoreException if arguments have been given but</span></span><br><span class="line"><span class="comment">    * the affected bean isn't a prototype</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 4.1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Does this bean factory contain a bean definition or externally registered singleton</span></span><br><span class="line"><span class="comment">    * instance with the given name?</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;If the given name is an alias, it will be translated back to the corresponding</span></span><br><span class="line"><span class="comment">    * canonical bean name.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;If this factory is hierarchical, will ask any parent factory if the bean cannot</span></span><br><span class="line"><span class="comment">    * be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;If a bean definition or singleton instance matching the given name is found,</span></span><br><span class="line"><span class="comment">    * this method will return &#123;<span class="doctag">@code</span> true&#125; whether the named bean definition is concrete</span></span><br><span class="line"><span class="comment">    * or abstract, lazy or eager, in scope or not. Therefore, note that a &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">    * return value from this method does not necessarily indicate that &#123;<span class="doctag">@link</span> #getBean&#125;</span></span><br><span class="line"><span class="comment">    * will be able to obtain an instance for the same name.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> whether a bean with the given name is present</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//提供对bean的检索，看看是否在IOC容器有这个名字的bean</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Is this bean a shared singleton? That is, will &#123;<span class="doctag">@link</span> #getBean&#125; always</span></span><br><span class="line"><span class="comment">    * return the same instance?</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Note: This method returning &#123;<span class="doctag">@code</span> false&#125; does not clearly indicate</span></span><br><span class="line"><span class="comment">    * independent instances. It indicates non-singleton instances, which may correspond</span></span><br><span class="line"><span class="comment">    * to a scoped bean as well. Use the &#123;<span class="doctag">@link</span> #isPrototype&#125; operation to explicitly</span></span><br><span class="line"><span class="comment">    * check for independent instances.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> whether this bean corresponds to a singleton instance</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #isPrototype</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//根据bean名字得到bean实例，并同时判断这个bean是不是单例</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Is this bean a prototype? That is, will &#123;<span class="doctag">@link</span> #getBean&#125; always return</span></span><br><span class="line"><span class="comment">    * independent instances?</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Note: This method returning &#123;<span class="doctag">@code</span> false&#125; does not clearly indicate</span></span><br><span class="line"><span class="comment">    * a singleton object. It indicates non-independent instances, which may correspond</span></span><br><span class="line"><span class="comment">    * to a scoped bean as well. Use the &#123;<span class="doctag">@link</span> #isSingleton&#125; operation to explicitly</span></span><br><span class="line"><span class="comment">    * check for a shared singleton instance.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> whether this bean will always deliver independent instances</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 2.0.3</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #isSingleton</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Check whether the bean with the given name matches the specified type.</span></span><br><span class="line"><span class="comment">    * More specifically, check whether a &#123;<span class="doctag">@link</span> #getBean&#125; call for the given name</span></span><br><span class="line"><span class="comment">    * would return an object that is assignable to the specified target type.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> typeToMatch the type to match against (as a &#123;<span class="doctag">@code</span> ResolvableType&#125;)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the bean type matches,</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> false&#125; if it doesn't match or cannot be determined yet</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getType</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Check whether the bean with the given name matches the specified type.</span></span><br><span class="line"><span class="comment">    * More specifically, check whether a &#123;<span class="doctag">@link</span> #getBean&#125; call for the given name</span></span><br><span class="line"><span class="comment">    * would return an object that is assignable to the specified target type.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> typeToMatch the type to match against (as a &#123;<span class="doctag">@code</span> Class&#125;)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the bean type matches,</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> false&#125; if it doesn't match or cannot be determined yet</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 2.0.1</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getType</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, @Nullable Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Determine the type of the bean with the given name. More specifically,</span></span><br><span class="line"><span class="comment">    * determine the type of object that &#123;<span class="doctag">@link</span> #getBean&#125; would return for the given name.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;For a &#123;<span class="doctag">@link</span> FactoryBean&#125;, return the type of object that the FactoryBean creates,</span></span><br><span class="line"><span class="comment">    * as exposed by &#123;<span class="doctag">@link</span> FactoryBean#getObjectType()&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the type of the bean, or &#123;<span class="doctag">@code</span> null&#125; if not determinable</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 1.1.2</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #isTypeMatch</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//得到bean实例的Class类型</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the aliases for the given bean name, if any.</span></span><br><span class="line"><span class="comment">    * All of those aliases point to the same bean when used in a &#123;<span class="doctag">@link</span> #getBean&#125; call.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;If the given name is an alias, the corresponding original bean name</span></span><br><span class="line"><span class="comment">    * and other aliases (if any) will be returned, with the original bean name</span></span><br><span class="line"><span class="comment">    * being the first element in the array.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the bean name to check for aliases</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the aliases, or an empty array if none</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//得到bean的别名，如果根据别名检索，那么其原名也会被检索出来</span></span><br><span class="line">   String[] getAliases(String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shoufengsfsf.github.io/2020/06/21/%E5%90%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AF%B9%E6%AF%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shoufeng">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shoufengsfsf.github.io">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/21/%E5%90%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AF%B9%E6%AF%94/" class="post-title-link" itemprop="url">各设计模式总结与对比</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-21 12:36:44 / 修改时间：13:05:05" itemprop="dateCreated datePublished" datetime="2020-06-21T12:36:44+08:00">2020-06-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          请输入密码查看.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/06/21/%E5%90%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AF%B9%E6%AF%94/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shoufengsfsf.github.io/2020/06/20/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shoufeng">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shoufengsfsf.github.io">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/20/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">装饰者模式和观察者模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-20 16:44:08" itemprop="dateCreated datePublished" datetime="2020-06-20T16:44:08+08:00">2020-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-21 12:36:14" itemprop="dateModified" datetime="2020-06-21T12:36:14+08:00">2020-06-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          请输入密码查看.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/06/20/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shoufengsfsf.github.io/2020/06/20/%E6%A8%A1%E7%89%88%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shoufeng">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shoufengsfsf.github.io">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/20/%E6%A8%A1%E7%89%88%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">模版模式和适配器模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-20 16:18:21 / 修改时间：16:41:37" itemprop="dateCreated datePublished" datetime="2020-06-20T16:18:21+08:00">2020-06-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          请输入密码查看.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/06/20/%E6%A8%A1%E7%89%88%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">shoufeng</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shoufeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
