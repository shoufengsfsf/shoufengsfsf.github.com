<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AtomicInteger</title>
    <url>/2020/06/18/AtomicInteger/</url>
    <content><![CDATA[<h1 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a><strong>AtomicInteger</strong></h1><p>首先说明，此处 AtomicInteger ，一个提供原子操作的 Integer 的类，常见的还有AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 等，他们的实现原理相同，区别在与运算对象类型的不同。令人兴奋地，还可以通过 AtomicReference<V>将一个对象的所有操作转化成原子操作。</p>
<p>我们知道，在多线程程序中，诸如++i 或 i++等运算不具有原子性，是不安全的线程操作之一。通常我们会使用 synchronized 将该操作变成一个原子操作，但 JVM 为此类操作特意提供了一些</p>
<p>同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger的性能是 ReentantLock 的好几倍。</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>ReadWriteLock读写锁</title>
    <url>/2020/06/18/ReadWriteLock%E8%AF%BB%E5%86%99%E9%94%81/</url>
    <content><![CDATA[<h1 id="ReadWriteLock读写锁"><a href="#ReadWriteLock读写锁" class="headerlink" title="ReadWriteLock读写锁"></a>ReadWriteLock读写锁</h1><p>为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。</p>
<h2 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a><strong>读锁</strong></h2><p>如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁</p>
<h2 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a><strong>写锁</strong></h2><p>如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！</p>
<p>Java 中 读 写 锁 有 个 接 口 java.util.concurrent.locks.ReadWriteLock ， 也 有 具 体 的 实 现ReentrantReadWriteLock。</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Semaphore信号量</title>
    <url>/2020/06/18/Semaphore%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
    <content><![CDATA[<h1 id="Semaphore信号量"><a href="#Semaphore信号量" class="headerlink" title="Semaphore信号量"></a>Semaphore信号量</h1><p>Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore 可以用来构建一些对象池，资源池之类的，比如数据库连接池</p>
<p>实现互斥锁（计数器为 1）</p>
<p>我们也可以创建计数为 1 的 Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。</p>
<p><strong>代码实现</strong></p>
<p>它的用法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个计数阈值为 5 的信号量对象</span></span><br><span class="line"><span class="comment">// 只能 5 个线程同时访问</span></span><br><span class="line">Semaphore semp = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">try</span> &#123; <span class="comment">// 申请许可</span></span><br><span class="line">semp.acquire();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line"><span class="number">121623125152125125</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 释放许可</span></span><br><span class="line">semp.release();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Semaphore-与-ReentrantLock"><a href="#Semaphore-与-ReentrantLock" class="headerlink" title="Semaphore 与 ReentrantLock"></a><strong>Semaphore</strong> <strong>与</strong> <strong>ReentrantLock</strong></h2><p>Semaphore 基本能完成 ReentrantLock 的所有工作，使用方法也与之类似，通过 acquire()与release()方法来获得和释放临界资源。经实测，Semaphone.acquire()方法默认为可响应中断锁，与 ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被Thread.interrupt()方法中断。</p>
<p>此外，Semaphore 也实现了可轮询的锁请求与定时锁的功能，除了方法名 tryAcquire 与 tryLock不同，其使用方法与 ReentrantLock 几乎一致。Semaphore 也提供了公平与非公平锁的机制，也可在构造函数中进行设定。</p>
<p>Semaphore 的锁释放操作也由手动进行，因此与 ReentrantLock 一样，为避免线程因抛出异常而无法正常释放锁的情况发生，释放锁的操作也必须在 finally 代码块中完成。</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>ReentrantLock</title>
    <url>/2020/06/18/ReentrantLock/</url>
    <content><![CDATA[<h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><strong>ReentrantLock</strong></h1><p>ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。</p>
<h2 id="Lock-接口的主要方法"><a href="#Lock-接口的主要方法" class="headerlink" title="Lock 接口的主要方法"></a><strong>Lock</strong> <strong>接口的主要方法</strong></h2><ol>
<li><p>void lock(): 执行此方法时, 如果锁处于空闲状态, 当前线程将获取到锁. 相反, 如果锁已经被其他线程持有, 将禁用当前线程, 直到当前线程获取到锁.</p>
</li>
<li><p>boolean tryLock()：如果锁可用, 则获取锁, 并立即返回 true, 否则返回 false. 该方法和lock()的区别在于, tryLock()只是”试图”获取锁, 如果锁不可用, 不会导致当前线程被禁用, 当前线程仍然继续往下执行代码. 而 lock()方法则是一定要获取到锁, 如果锁不可用, 就一直等待, 在未获得锁之前,当前线程并不继续向下执行. </p>
</li>
<li><p>void unlock()：执行此方法时, 当前线程将释放持有的锁. 锁只能由持有者释放, 如果线程并不持有锁, 却执行该方法, 可能导致异常的发生.</p>
</li>
<li><p>Condition newCondition()：条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的 await()方法，而调用后，当前线程将缩放锁。</p>
</li>
<li><p>getHoldCount() ：查询当前线程保持此锁的次数，也就是执行此线程执行 lock 方法的次数。</p>
</li>
<li><p>getQueueLength（）：返回正等待获取此锁的线程估计数，比如启动 10 个线程，1 个线程获得锁，此时返回的是 9</p>
</li>
<li><p>getWaitQueueLength：（Condition condition）返回等待与此锁相关的给定条件的线程估计数。比如 10 个线程，用同一个 condition 对象，并且此时这 10 个线程都执行了condition 对象的 await 方法，那么此时执行此方法返回 10</p>
</li>
<li><p>hasWaiters(Condition condition)：查询是否有线程等待与此锁有关的给定条件</p>
</li>
</ol>
<p>(condition)，对于指定 contidion 对象，有多少线程执行了 condition.await 方法</p>
<ol start="9">
<li><p>hasQueuedThread(Thread thread)：查询给定线程是否等待获取此锁</p>
</li>
<li><p>hasQueuedThreads()：是否有线程等待此锁</p>
</li>
<li><p>isFair()：该锁是否公平锁</p>
</li>
<li><p>isHeldByCurrentThread()： 当前线程是否保持锁锁定，线程的执行 lock 方法的前后分别是 false 和 true</p>
</li>
<li><p>isLock()：此锁是否有任意线程占用</p>
</li>
<li><p>lockInterruptibly（）：如果当前线程未被中断，获取锁</p>
</li>
<li><p>tryLock（）：尝试获得锁，仅在调用时锁未被线程占用，获得锁</p>
</li>
<li><p>tryLock(long timeout TimeUnit unit)：如果锁在给定等待时间内没有被另一个线程保持，则获取该锁。</p>
</li>
</ol>
<h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a><strong>非公平锁</strong></h2><p>JVM 按随机、就近原则分配锁的机制则称为不公平锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式，默认为非公平锁。非公平锁实际执行的效率要远远超出公平锁，除非程序有特殊需要，否则最常用非公平锁的分配机制。</p>
<h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a><strong>公平锁</strong></h2><p>公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式来定义公平锁。</p>
<h2 id="ReentrantLock-与-synchronized"><a href="#ReentrantLock-与-synchronized" class="headerlink" title="ReentrantLock 与 synchronized"></a><strong>ReentrantLock</strong> <strong>与</strong> <strong>synchronized</strong></h2><ol>
<li><p>ReentrantLock 通过方法 lock()与 unlock()来进行加锁与解锁操作，与 synchronized 会 被 JVM 自动解锁机制不同，ReentrantLock 加锁后需要手动进行解锁。为了避免程序出现异常而无法正常解锁的情况，使用 ReentrantLock 必须在 finally 控制块中进行解锁操作。</p>
</li>
<li><p>ReentrantLock 相比 synchronized 的优势是可中断、公平锁、多个锁。这种情况下需要使用 ReentrantLock。</p>
</li>
</ol>
<h3 id="ReentrantLock-实现"><a href="#ReentrantLock-实现" class="headerlink" title="ReentrantLock 实现"></a><strong>ReentrantLock</strong> <strong>实现</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//Lock lock=new ReentrantLock(true);//公平锁</span></span><br><span class="line"><span class="comment">//Lock lock=new ReentrantLock(false);//非公平锁</span></span><br><span class="line"><span class="keyword">private</span> Condition condition=lock.newCondition();<span class="comment">//创建 Condition</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();<span class="comment">//lock 加锁</span></span><br><span class="line"><span class="comment">//1：wait 方法等待：</span></span><br><span class="line"><span class="comment">//System.out.println("开始 wait");</span></span><br><span class="line">condition.await();</span><br><span class="line"><span class="comment">//通过创建 Condition 对象来使线程 wait，必须先执行 lock.lock 方法获得锁</span></span><br><span class="line"><span class="comment">//:2：signal 方法唤醒</span></span><br><span class="line">condition.signal();<span class="comment">//condition 对象的 signal 方法可以唤醒 wait 线程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"ThreadName="</span> + Thread.currentThread().getName()+ (<span class="string">" "</span> + (i + <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line"><span class="number">121623125152125125</span></span><br><span class="line">&#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125; &#125; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Condition-类和-Object-类锁方法区别区别"><a href="#Condition-类和-Object-类锁方法区别区别" class="headerlink" title="Condition 类和 Object 类锁方法区别区别"></a><strong>Condition</strong> <strong>类和</strong> <strong>Object</strong> <strong>类锁方法区别区别</strong></h3><ol>
<li><p>Condition 类的 awiat 方法和 Object 类的 wait 方法等效</p>
</li>
<li><p>Condition 类的 signal 方法和 Object 类的 notify 方法等效</p>
</li>
<li><p>Condition 类的 signalAll 方法和 Object 类的 notifyAll 方法等效</p>
</li>
<li><p>ReentrantLock 类可以唤醒指定条件的线程，而 object 的唤醒是随机的</p>
</li>
</ol>
<h3 id="tryLock-和-lock-和-lockInterruptibly-的区别"><a href="#tryLock-和-lock-和-lockInterruptibly-的区别" class="headerlink" title="tryLock 和 lock 和 lockInterruptibly 的区别"></a><strong>tryLock</strong> <strong>和</strong> <strong>lock</strong> <strong>和</strong> <strong>lockInterruptibly</strong> <strong>的区别</strong></h3><ol>
<li><p>tryLock 能获得锁就返回 true，不能就立即返回 false，tryLock(long timeout,TimeUnit unit)，可以增加时间限制，如果超过该时间段还没获得锁，返回 false</p>
</li>
<li><p>lock 能获得锁就返回 true，不能的话一直等待获得锁</p>
</li>
<li><p>lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程，lock 不会抛出异常，而 lockInterruptibly 会抛出异常。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>spring源码问题</title>
    <url>/2020/06/21/spring%E6%BA%90%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="spring源码问题"><a href="#spring源码问题" class="headerlink" title="spring源码问题"></a>spring源码问题</h1><h2 id="1、如何统一配置文件的标准？"><a href="#1、如何统一配置文件的标准？" class="headerlink" title="1、如何统一配置文件的标准？"></a>1、如何统一配置文件的标准？</h2><p>BeanDefinition</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SpringIOC容器管理了我们定义的各种Bean对象及其相互的关系，Bean对象在Spring实现中是以BeanDefinition来描述的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinition</span> <span class="keyword">extends</span> <span class="title">AttributeAccessor</span>, <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Scope identifier for the standard singleton scope: "singleton".</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Note that extended bean factories might support further scopes.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setScope</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Scope identifier for the standard prototype scope: "prototype".</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Note that extended bean factories might support further scopes.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setScope</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Role hint indicating that a &#123;<span class="doctag">@code</span> BeanDefinition&#125; is a major part</span></span><br><span class="line"><span class="comment">    * of the application. Typically corresponds to a user-defined bean.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">int</span> ROLE_APPLICATION = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Role hint indicating that a &#123;<span class="doctag">@code</span> BeanDefinition&#125; is a supporting</span></span><br><span class="line"><span class="comment">    * part of some larger configuration, typically an outer</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.parsing.ComponentDefinition&#125;.</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> SUPPORT&#125; beans are considered important enough to be aware</span></span><br><span class="line"><span class="comment">    * of when looking more closely at a particular</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.parsing.ComponentDefinition&#125;,</span></span><br><span class="line"><span class="comment">    * but not when looking at the overall configuration of an application.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">int</span> ROLE_SUPPORT = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Role hint indicating that a &#123;<span class="doctag">@code</span> BeanDefinition&#125; is providing an</span></span><br><span class="line"><span class="comment">    * entirely background role and has no relevance to the end-user. This hint is</span></span><br><span class="line"><span class="comment">    * used when registering beans that are completely part of the internal workings</span></span><br><span class="line"><span class="comment">    * of a &#123;<span class="doctag">@link</span> org.springframework.beans.factory.parsing.ComponentDefinition&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">int</span> ROLE_INFRASTRUCTURE = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Modifiable attributes</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set the name of the parent definition of this bean definition, if any.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setParentName</span><span class="params">(@Nullable String parentName)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the name of the parent definition of this bean definition, if any.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">String <span class="title">getParentName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Specify the bean class name of this bean definition.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;The class name can be modified during bean factory post-processing,</span></span><br><span class="line"><span class="comment">    * typically replacing the original class name with a parsed variant of it.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setParentName</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setFactoryBeanName</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setFactoryMethodName</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(@Nullable String beanClassName)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the current bean class name of this bean definition.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Note that this does not have to be the actual class name used at runtime, in</span></span><br><span class="line"><span class="comment">    * case of a child definition overriding/inheriting the class name from its parent.</span></span><br><span class="line"><span class="comment">    * Also, this may just be the class that a factory method is called on, or it may</span></span><br><span class="line"><span class="comment">    * even be empty in case of a factory bean reference that a method is called on.</span></span><br><span class="line"><span class="comment">    * Hence, do &lt;i&gt;not&lt;/i&gt; consider this to be the definitive bean type at runtime but</span></span><br><span class="line"><span class="comment">    * rather only use it for parsing purposes at the individual bean definition level.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getParentName()</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getFactoryBeanName()</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getFactoryMethodName()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">String <span class="title">getBeanClassName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Override the target scope of this bean, specifying a new scope name.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #SCOPE_SINGLETON</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #SCOPE_PROTOTYPE</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setScope</span><span class="params">(@Nullable String scope)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the name of the current target scope for this bean,</span></span><br><span class="line"><span class="comment">    * or &#123;<span class="doctag">@code</span> null&#125; if not known yet.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">String <span class="title">getScope</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set whether this bean should be lazily initialized.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;If &#123;<span class="doctag">@code</span> false&#125;, the bean will get instantiated on startup by bean</span></span><br><span class="line"><span class="comment">    * factories that perform eager initialization of singletons.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setLazyInit</span><span class="params">(<span class="keyword">boolean</span> lazyInit)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return whether this bean should be lazily initialized, i.e. not</span></span><br><span class="line"><span class="comment">    * eagerly instantiated on startup. Only applicable to a singleton bean.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isLazyInit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set the names of the beans that this bean depends on being initialized.</span></span><br><span class="line"><span class="comment">    * The bean factory will guarantee that these beans get initialized first.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setDependsOn</span><span class="params">(@Nullable String... dependsOn)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the bean names that this bean depends on.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   String[] getDependsOn();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set whether this bean is a candidate for getting autowired into some other bean.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Note that this flag is designed to only affect type-based autowiring.</span></span><br><span class="line"><span class="comment">    * It does not affect explicit references by name, which will get resolved even</span></span><br><span class="line"><span class="comment">    * if the specified bean is not marked as an autowire candidate. As a consequence,</span></span><br><span class="line"><span class="comment">    * autowiring by name will nevertheless inject a bean if the name matches.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setAutowireCandidate</span><span class="params">(<span class="keyword">boolean</span> autowireCandidate)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return whether this bean is a candidate for getting autowired into some other bean.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set whether this bean is a primary autowire candidate.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;If this value is &#123;<span class="doctag">@code</span> true&#125; for exactly one bean among multiple</span></span><br><span class="line"><span class="comment">    * matching candidates, it will serve as a tie-breaker.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setPrimary</span><span class="params">(<span class="keyword">boolean</span> primary)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return whether this bean is a primary autowire candidate.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isPrimary</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Specify the factory bean to use, if any.</span></span><br><span class="line"><span class="comment">    * This the name of the bean to call the specified factory method on.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setFactoryMethodName</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setFactoryBeanName</span><span class="params">(@Nullable String factoryBeanName)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the factory bean name, if any.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">String <span class="title">getFactoryBeanName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Specify a factory method, if any. This method will be invoked with</span></span><br><span class="line"><span class="comment">    * constructor arguments, or with no arguments if none are specified.</span></span><br><span class="line"><span class="comment">    * The method will be invoked on the specified factory bean, if any,</span></span><br><span class="line"><span class="comment">    * or otherwise as a static method on the local bean class.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setFactoryBeanName</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setBeanClassName</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setFactoryMethodName</span><span class="params">(@Nullable String factoryMethodName)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return a factory method, if any.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">String <span class="title">getFactoryMethodName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the constructor argument values for this bean.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;The returned instance can be modified during bean factory post-processing.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the ConstructorArgumentValues object (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">ConstructorArgumentValues <span class="title">getConstructorArgumentValues</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return if there are constructor argument values defined for this bean.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 5.0.2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">hasConstructorArgumentValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> !getConstructorArgumentValues().isEmpty();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the property values to be applied to a new instance of the bean.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;The returned instance can be modified during bean factory post-processing.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the MutablePropertyValues object (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">MutablePropertyValues <span class="title">getPropertyValues</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return if there are property values values defined for this bean.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 5.0.2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">hasPropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> !getPropertyValues().isEmpty();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Read-only attributes</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return whether this a &lt;b&gt;Singleton&lt;/b&gt;, with a single, shared instance</span></span><br><span class="line"><span class="comment">    * returned on all calls.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #SCOPE_SINGLETON</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return whether this a &lt;b&gt;Prototype&lt;/b&gt;, with an independent instance</span></span><br><span class="line"><span class="comment">    * returned for each call.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #SCOPE_PROTOTYPE</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return whether this bean is "abstract", that is, not meant to be instantiated.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isAbstract</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Get the role hint for this &#123;<span class="doctag">@code</span> BeanDefinition&#125;. The role hint</span></span><br><span class="line"><span class="comment">    * provides the frameworks as well as tools with an indication of</span></span><br><span class="line"><span class="comment">    * the role and importance of a particular &#123;<span class="doctag">@code</span> BeanDefinition&#125;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #ROLE_APPLICATION</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #ROLE_SUPPORT</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #ROLE_INFRASTRUCTURE</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getRole</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return a human-readable description of this bean definition.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return a description of the resource that this bean definition</span></span><br><span class="line"><span class="comment">    * came from (for the purpose of showing context in case of errors).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">String <span class="title">getResourceDescription</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the originating BeanDefinition, or &#123;<span class="doctag">@code</span> null&#125; if none.</span></span><br><span class="line"><span class="comment">    * Allows for retrieving the decorated bean definition, if any.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Note that this method returns the immediate originator. Iterate through the</span></span><br><span class="line"><span class="comment">    * originator chain to find the original BeanDefinition as defined by the user.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">BeanDefinition <span class="title">getOriginatingBeanDefinition</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、IOC容器最顶层接口"><a href="#2、IOC容器最顶层接口" class="headerlink" title="2、IOC容器最顶层接口"></a>2、IOC容器最顶层接口</h2><p>BeanFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在BeanFactory里只对IOC容器的基本行为作了定义，根本不关心你的Bean是如何定义怎样加载的。</span></span><br><span class="line"><span class="comment">//正如我们只关心工厂里得到什么的产品对象，至于工厂是怎么生产这些对象的，这个基本的接口不关心。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Used to dereference a &#123;<span class="doctag">@link</span> FactoryBean&#125; instance and distinguish it from</span></span><br><span class="line"><span class="comment">    * beans &lt;i&gt;created&lt;/i&gt; by the FactoryBean. For example, if the bean named</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> myJndiObject&#125; is a FactoryBean, getting &#123;<span class="doctag">@code</span> &amp;myJndiObject&#125;</span></span><br><span class="line"><span class="comment">    * will return the factory, not the instance returned by the factory.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//对FactoryBean的转义定义，因为如果使用bean的名字检索FactoryBean得到的对象是工厂生成的对象，</span></span><br><span class="line">   <span class="comment">//如果需要得到工厂本身，需要转义</span></span><br><span class="line">   String FACTORY_BEAN_PREFIX = <span class="string">"&amp;"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;This method allows a Spring BeanFactory to be used as a replacement for the</span></span><br><span class="line"><span class="comment">    * Singleton or Prototype design pattern. Callers may retain references to</span></span><br><span class="line"><span class="comment">    * returned objects in the case of Singleton beans.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean definition</span></span><br><span class="line"><span class="comment">    * with the specified name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeansException if the bean could not be obtained</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//根据bean的名字，获取在IOC容器中得到bean实例</span></span><br><span class="line">   <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Behaves the same as &#123;<span class="doctag">@link</span> #getBean(String)&#125;, but provides a measure of type</span></span><br><span class="line"><span class="comment">    * safety by throwing a BeanNotOfRequiredTypeException if the bean is not of the</span></span><br><span class="line"><span class="comment">    * required type. This means that ClassCastException can't be thrown on casting</span></span><br><span class="line"><span class="comment">    * the result correctly, as can happen with &#123;<span class="doctag">@link</span> #getBean(String)&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> requiredType type the bean must match. Can be an interface or superclass</span></span><br><span class="line"><span class="comment">    * of the actual class, or &#123;<span class="doctag">@code</span> null&#125; for any match. For example, if the value</span></span><br><span class="line"><span class="comment">    * is &#123;<span class="doctag">@code</span> Object.class&#125;, this method will succeed whatever the class of the</span></span><br><span class="line"><span class="comment">    * returned instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no such bean definition</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeanNotOfRequiredTypeException if the bean is not of the required type</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//根据bean的名字和Class类型来得到bean实例，增加了类型安全验证机制。</span></span><br><span class="line">   &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, @Nullable Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Allows for specifying explicit constructor arguments / factory method arguments,</span></span><br><span class="line"><span class="comment">    * overriding the specified default arguments (if any) in the bean definition.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment">    * (only applied when creating a new instance as opposed to retrieving an existing one)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no such bean definition</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeanDefinitionStoreException if arguments have been given but</span></span><br><span class="line"><span class="comment">    * the affected bean isn't a prototype</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the bean instance that uniquely matches the given object type, if any.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;This method goes into &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; by-type lookup territory</span></span><br><span class="line"><span class="comment">    * but may also be translated into a conventional by-name lookup based on the name</span></span><br><span class="line"><span class="comment">    * of the given type. For more extensive retrieval operations across sets of beans,</span></span><br><span class="line"><span class="comment">    * use &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; and/or &#123;<span class="doctag">@link</span> BeanFactoryUtils&#125;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> requiredType type the bean must match; can be an interface or superclass.</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> null&#125; is disallowed.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> an instance of the single bean matching the required type</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if no bean of the given type was found</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoUniqueBeanDefinitionException if more than one bean of the given type was found</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> ListableBeanFactory</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Allows for specifying explicit constructor arguments / factory method arguments,</span></span><br><span class="line"><span class="comment">    * overriding the specified default arguments (if any) in the bean definition.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;This method goes into &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; by-type lookup territory</span></span><br><span class="line"><span class="comment">    * but may also be translated into a conventional by-name lookup based on the name</span></span><br><span class="line"><span class="comment">    * of the given type. For more extensive retrieval operations across sets of beans,</span></span><br><span class="line"><span class="comment">    * use &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; and/or &#123;<span class="doctag">@link</span> BeanFactoryUtils&#125;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> requiredType type the bean must match; can be an interface or superclass.</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> null&#125; is disallowed.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment">    * (only applied when creating a new instance as opposed to retrieving an existing one)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no such bean definition</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeanDefinitionStoreException if arguments have been given but</span></span><br><span class="line"><span class="comment">    * the affected bean isn't a prototype</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 4.1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Does this bean factory contain a bean definition or externally registered singleton</span></span><br><span class="line"><span class="comment">    * instance with the given name?</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;If the given name is an alias, it will be translated back to the corresponding</span></span><br><span class="line"><span class="comment">    * canonical bean name.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;If this factory is hierarchical, will ask any parent factory if the bean cannot</span></span><br><span class="line"><span class="comment">    * be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;If a bean definition or singleton instance matching the given name is found,</span></span><br><span class="line"><span class="comment">    * this method will return &#123;<span class="doctag">@code</span> true&#125; whether the named bean definition is concrete</span></span><br><span class="line"><span class="comment">    * or abstract, lazy or eager, in scope or not. Therefore, note that a &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">    * return value from this method does not necessarily indicate that &#123;<span class="doctag">@link</span> #getBean&#125;</span></span><br><span class="line"><span class="comment">    * will be able to obtain an instance for the same name.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> whether a bean with the given name is present</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//提供对bean的检索，看看是否在IOC容器有这个名字的bean</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Is this bean a shared singleton? That is, will &#123;<span class="doctag">@link</span> #getBean&#125; always</span></span><br><span class="line"><span class="comment">    * return the same instance?</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Note: This method returning &#123;<span class="doctag">@code</span> false&#125; does not clearly indicate</span></span><br><span class="line"><span class="comment">    * independent instances. It indicates non-singleton instances, which may correspond</span></span><br><span class="line"><span class="comment">    * to a scoped bean as well. Use the &#123;<span class="doctag">@link</span> #isPrototype&#125; operation to explicitly</span></span><br><span class="line"><span class="comment">    * check for independent instances.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> whether this bean corresponds to a singleton instance</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #isPrototype</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//根据bean名字得到bean实例，并同时判断这个bean是不是单例</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Is this bean a prototype? That is, will &#123;<span class="doctag">@link</span> #getBean&#125; always return</span></span><br><span class="line"><span class="comment">    * independent instances?</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Note: This method returning &#123;<span class="doctag">@code</span> false&#125; does not clearly indicate</span></span><br><span class="line"><span class="comment">    * a singleton object. It indicates non-independent instances, which may correspond</span></span><br><span class="line"><span class="comment">    * to a scoped bean as well. Use the &#123;<span class="doctag">@link</span> #isSingleton&#125; operation to explicitly</span></span><br><span class="line"><span class="comment">    * check for a shared singleton instance.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> whether this bean will always deliver independent instances</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 2.0.3</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #isSingleton</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Check whether the bean with the given name matches the specified type.</span></span><br><span class="line"><span class="comment">    * More specifically, check whether a &#123;<span class="doctag">@link</span> #getBean&#125; call for the given name</span></span><br><span class="line"><span class="comment">    * would return an object that is assignable to the specified target type.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> typeToMatch the type to match against (as a &#123;<span class="doctag">@code</span> ResolvableType&#125;)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the bean type matches,</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> false&#125; if it doesn't match or cannot be determined yet</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getType</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Check whether the bean with the given name matches the specified type.</span></span><br><span class="line"><span class="comment">    * More specifically, check whether a &#123;<span class="doctag">@link</span> #getBean&#125; call for the given name</span></span><br><span class="line"><span class="comment">    * would return an object that is assignable to the specified target type.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> typeToMatch the type to match against (as a &#123;<span class="doctag">@code</span> Class&#125;)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the bean type matches,</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> false&#125; if it doesn't match or cannot be determined yet</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 2.0.1</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getType</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, @Nullable Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Determine the type of the bean with the given name. More specifically,</span></span><br><span class="line"><span class="comment">    * determine the type of object that &#123;<span class="doctag">@link</span> #getBean&#125; would return for the given name.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;For a &#123;<span class="doctag">@link</span> FactoryBean&#125;, return the type of object that the FactoryBean creates,</span></span><br><span class="line"><span class="comment">    * as exposed by &#123;<span class="doctag">@link</span> FactoryBean#getObjectType()&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the type of the bean, or &#123;<span class="doctag">@code</span> null&#125; if not determinable</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 1.1.2</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #isTypeMatch</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//得到bean实例的Class类型</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the aliases for the given bean name, if any.</span></span><br><span class="line"><span class="comment">    * All of those aliases point to the same bean when used in a &#123;<span class="doctag">@link</span> #getBean&#125; call.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;If the given name is an alias, the corresponding original bean name</span></span><br><span class="line"><span class="comment">    * and other aliases (if any) will be returned, with the original bean name</span></span><br><span class="line"><span class="comment">    * being the first element in the array.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the bean name to check for aliases</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the aliases, or an empty array if none</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//得到bean的别名，如果根据别名检索，那么其原名也会被检索出来</span></span><br><span class="line">   String[] getAliases(String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>spring源码解读</category>
      </categories>
      <tags>
        <tag>spring源码问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Synchronized同步锁</title>
    <url>/2020/06/17/Synchronized%E5%90%8C%E6%AD%A5%E9%94%81/</url>
    <content><![CDATA[<h1 id="Synchronized同步锁"><a href="#Synchronized同步锁" class="headerlink" title="Synchronized同步锁"></a>Synchronized同步锁</h1><p>synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重入锁。</p>
<h2 id="Synchronized-作用范围"><a href="#Synchronized-作用范围" class="headerlink" title="Synchronized 作用范围"></a><strong>Synchronized</strong> <strong>作用范围</strong></h2><ol>
<li><p>作用于方法时，锁住的是对象的实例(this)；</p>
</li>
<li><p>当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen（jdk1.8 则是 metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程；</p>
</li>
<li><p>synchronized 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。</p>
</li>
</ol>
<h2 id="Synchronized-核心组件"><a href="#Synchronized-核心组件" class="headerlink" title="Synchronized 核心组件"></a><strong>Synchronized</strong> <strong>核心组件</strong></h2><ol>
<li><p>Wait Set：哪些调用 wait 方法被阻塞的线程被放置在这里；</p>
</li>
<li><p>Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；</p>
</li>
<li><p>Entry List：Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中；</p>
</li>
<li><p>OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck；</p>
</li>
<li><p>Owner：当前已经获取到所资源的线程被称为 Owner；</p>
</li>
<li><p>!Owner：当前释放锁的线程。</p>
</li>
</ol>
<h2 id="Synchronized-实现"><a href="#Synchronized-实现" class="headerlink" title="Synchronized 实现"></a><strong>Synchronized</strong> <strong>实现</strong></h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfwhot9cepj317s0jstod.jpg" alt="image-20200618154736405"></p>
<ol>
<li><p>JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争，JVM 会将一部分线程移动到 EntryList 中作为候选竞争线程。</p>
</li>
<li><p>Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并指定EntryList 中的某个线程为 OnDeck 线程（一般是最先进去的那个线程）。</p>
</li>
<li><p>Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck，OnDeck 需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM 中，也把这种选择行为称之为“竞争切换”。</p>
</li>
<li><p>OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList中。如果 Owner 线程被 wait 方法阻塞，则转移到 WaitSet 队列中，直到某个时刻通过 notify或者 notifyAll 唤醒，会重新进去 EntryList 中。</p>
</li>
<li><p>处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux 内核下采用 pthread_mutex_lock 内核函数实现的）。</p>
</li>
<li><p>Synchronized 是非公平锁。 Synchronized 在线程进入 ContentionList 时，等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源。参考：<a href="https://blog.csdn.net/zqz_zqz/article/details/70233767" target="_blank" rel="noopener">https://blog.csdn.net/zqz_zqz/article/details/70233767</a></p>
</li>
<li><p>每个对象都有个 monitor 对象，加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的</p>
</li>
<li><p>synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。</p>
</li>
<li><p>Java1.6，synchronized 进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。</p>
</li>
<li><p>锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀；</p>
</li>
<li><p>JDK 1.6 中默认是开启偏向锁和轻量级锁，可以通过-XX:-UseBiasedLocking 来禁用偏向锁。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>乐观锁、悲观锁、自旋锁</title>
    <url>/2020/06/17/%E4%B9%90%E8%A7%82%E9%94%81%E3%80%81%E6%82%B2%E8%A7%82%E9%94%81%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81/</url>
    <content><![CDATA[<h1 id="乐观锁、悲观锁、自旋锁"><a href="#乐观锁、悲观锁、自旋锁" class="headerlink" title="乐观锁、悲观锁、自旋锁"></a>乐观锁、悲观锁、自旋锁</h1><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a><strong>乐观锁</strong></h2><p>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。</p>
<p>java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。</p>
<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a><strong>悲观锁</strong></h2><p>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。</p>
<p>java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如 RetreenLock。</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a><strong>自旋锁</strong></h2><p>自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p>
<p>线程自旋是需要消耗 cup 的，说白了就是让 cup 在做无用功，如果一直获取不到锁，那线程也不能一直占用 cup 自旋做无用功，所以需要设定一个自旋等待的最大时间。</p>
<p>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p>
<h3 id="自旋锁的优缺点"><a href="#自旋锁的优缺点" class="headerlink" title="自旋锁的优缺点"></a><strong>自旋锁的优缺点</strong></h3><p>自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！</p>
<p>但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cup 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁；自旋锁时间阈值（1.6 引入了适应性自旋锁）自旋锁的目的是为了占着 CPU 的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！</p>
<p>JVM 对于自旋周期的选择，jdk1.5 这个限度是一定的写死的，在 1.6 引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时 JVM 还针对当前 CPU 的负荷情况做了较多的优化，如果平均负载小于 CPUs 则一直自旋，如果有超过(CPUs/2)个线程正在自旋，则后来线程直接阻塞，如果正在自旋的线程发现 Owner 发生了变化则延迟自旋时间（自旋计数）或进入阻塞，如果 CPU 处于节电模式则停止自旋，自旋时间的最坏情况是 CPU的存储延迟（CPU A 存储了一个数据，到 CPU B 得知这个数据直接的时间差），自旋时会适当放弃线程优先级之间的差异。</p>
<p><strong>自旋锁的开启</strong></p>
<p>JDK1.6 中-XX:+UseSpinning 开启；</p>
<p>-XX:PreBlockSpin=10 为自旋次数；</p>
<p>JDK1.7 后，去掉此参数，由 jvm 控制；</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2020/06/20/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="代理模式的应用场景"><a href="#代理模式的应用场景" class="headerlink" title="代理模式的应用场景"></a>代理模式的应用场景</h2><p>在生活中，我们经常见到这样的场景，如:租房中介、售票黄牛、婚介、经纪人、快递、 事务代理、非侵入式日志监听等，这些都是代理模式的实际体现。代理模式(Proxy Pattern)的定义也非常简单，是指为其他对象提供一种代理，以控制对这个对象的访问。 代理对象在客服端和目标对象之间起到中介作用，代理模式属于结构型设计模式。使用 代理模式主要有两个目的:一保护目标对象，二增强目标对象。下面我们来看一下代理 模式的类结构图:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfyjt058zpj30o20ledpe.jpg" alt="image-20200620103147017"></p>
<p>Subject 是顶层接口，RealSubject 是真实对象(被代理对象)，Proxy 是代理对象，代 理对象持有被代理对象的引用，客户端调用代理对象方法，同时也调用被代理对象的方 法，但是在代理对象前后增加一些处理。在代码中，我们想到代理，就会理解为是代码 增强，其实就是在原本逻辑前后增加一些逻辑，而调用者无感知。代理模式属于结构型 模式，有静态代理和动态代理。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>举个例子:人到了适婚年龄，父母总是迫不及待希望早点抱孙子。而现在社会的人在各 种压力之下，都选择晚婚晚育。于是着急的父母就开始到处为自己的子女相亲，比子女 自己还着急。这个相亲的过程，就是一种我们人人都有份的代理。来看代码实现: 顶层接口 Person:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 人有很多行为，要谈恋爱，要住房子，要购物，要工作 * Created by Tom.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findLove</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>儿子要找对象，实现 Son 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findLove</span><span class="params">()</span></span>&#123; <span class="comment">//我没有时间</span></span><br><span class="line">    <span class="comment">//工作忙</span></span><br><span class="line">    System.out.println(<span class="string">"儿子要求:肤白貌美大长腿"</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父亲要帮儿子相亲，实现 Father 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> Son son; </span><br><span class="line">  <span class="comment">//没办法扩展</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">(Son son)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.son = son; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//目标对象的引用给拿到 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findLove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"父母物色对象"</span>); </span><br><span class="line">    <span class="keyword">this</span>.son.findLove(); </span><br><span class="line">    System.out.println(<span class="string">"双方同意交往，确立关系"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看测试代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">  <span class="comment">//只能帮儿子找对象 </span></span><br><span class="line">  <span class="comment">//不能帮表妹、不能帮陌生人</span></span><br><span class="line">  Father father = <span class="keyword">new</span> Father(<span class="keyword">new</span> Son()); </span><br><span class="line">  father.findLove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理和静态对比基本思路是一致的，只不过动态代理功能更加强大，随着业务的扩 展适应性更强。如果还以找对象为例，使用动态代理相当于是能够适应复杂的业务场景。 不仅仅只是父亲给儿子找对象，如果找对象这项业务发展成了一个产业，进而出现了媒 婆、婚介所等这样的形式。那么，此时用静态代理成本就更大了，需要一个更加通用的 解决方案，要满足任何单身人士找对象的需求。我们升级一下代码，先来看 JDK 实现方 式:</p>
<h3 id="JDK-实现方式"><a href="#JDK-实现方式" class="headerlink" title="JDK 实现方式"></a><strong>JDK 实现方式</strong></h3><p>创建媒婆(婚介)JDKMeipo 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKMeipo</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123; <span class="comment">//被代理的对象，把引用给保存下来</span></span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">		Class&lt;?&gt; clazz = target.getClass();</span><br><span class="line">		<span class="keyword">return</span> Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		before();</span><br><span class="line">		Object obj = method.invoke(<span class="keyword">this</span>.target, args);</span><br><span class="line">		after();</span><br><span class="line">		<span class="keyword">return</span> obj;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"我是媒婆:我要给你找对象，现在已经拿到你的需求"</span>);</span><br><span class="line">		System.out.println(<span class="string">"开始物色"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"如果合适的话，就准备办事"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建单身客户 Customer 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findLove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"高富帅"</span>); </span><br><span class="line">    System.out.println(<span class="string">"身高 180cm"</span>); </span><br><span class="line">    System.out.println(<span class="string">"胸大，6 块腹肌"</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Person obj = (Person)<span class="keyword">new</span> JDKMeipo().getInstance(<span class="keyword">new</span> Customer());</span><br><span class="line">    obj.findLove(); </span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高仿真-JDK-Proxy-手写实现"><a href="#高仿真-JDK-Proxy-手写实现" class="headerlink" title="高仿真 JDK Proxy 手写实现"></a><strong>高仿真 JDK Proxy 手写实现</strong></h3><p>不仅知其然，还得知其所以然。既然 JDK Proxy 功能如此强大，那么它是如何实现的呢? 我们现在来探究一下原理，并模仿 JDK Proxy 自己动手写一个属于自己的动态代理。 我们都知道 JDK Proxy 采用字节重组，重新生的对象来替代原始的对象以达到动态代理 的目的。JDK Proxy 生成对象的步骤如下:</p>
<ol>
<li><p>拿到被代理对象的引用，并且获取到它的所有的接口，反射获取。</p>
</li>
<li><p>JDK Proxy 类重新生成一个新的类、同时新的类要实现被代理类所有实现的所有的接 口。</p>
</li>
<li><p>动态生成 Java 代码，把新加的业务逻辑方法由一定的逻辑代码去调用(在代码中体 现)。</p>
</li>
<li><p>编译新生成的 Java 代码.class。</p>
</li>
<li><p>再重新加载到 JVM 中运行。</p>
</li>
</ol>
<p>以上这个过程就叫字节码重组。JDK 中有一个规范，在 ClassPath 下只要是$开头的 class 文件一般都是自动生成的。</p>
<h3 id="CGLib-调用-API-及原理分析"><a href="#CGLib-调用-API-及原理分析" class="headerlink" title="CGLib 调用 API 及原理分析"></a><strong>CGLib 调用 API 及原理分析</strong></h3><p>简单看一下 CGLib 代理的使用,还是以媒婆为例，创建 CglibMeipo 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibMeipo</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Class&lt;?&gt; clazz)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer(); </span><br><span class="line">    <span class="comment">//要把哪个设置为即将生成的新类父类 </span></span><br><span class="line">    enhancer.setSuperclass(clazz); </span><br><span class="line">    enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> enhancer.create(); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">//业务的增强</span></span><br><span class="line">    before();</span><br><span class="line">    Object obj = methodProxy.invokeSuper(o,objects);   </span><br><span class="line">    after();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123; </span><br><span class="line">    System.out.println(<span class="string">"我是媒婆:我要给你找对象，现在已经拿到你的需求"</span>); </span><br><span class="line">    System.out.println(<span class="string">"开始物色"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"如果合适的话，就准备办事"</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建单身客户 Customer 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findLove</span><span class="params">()</span></span>&#123; </span><br><span class="line">    System.out.println(<span class="string">"肤白貌美大象腿"</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有个小细节，CGLib 代理的目标对象不需要实现任何接口，它是通过动态继承目标对象 实现的动态代理。来看测试代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Customer obj = (Customer)<span class="keyword">new</span> CglibMeipo().getInstance(Customer<span class="class">.<span class="keyword">class</span>)</span>; </span><br><span class="line">      obj.findLove();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CGLib-和-JDK-动态代理对比"><a href="#CGLib-和-JDK-动态代理对比" class="headerlink" title="CGLib 和 JDK 动态代理对比"></a><strong>CGLib 和 JDK 动态代理对比</strong></h3><ol>
<li><p>JDK 动态代理是实现了被代理对象的接口，CGLib 是继承了被代理对象。</p>
</li>
<li><p>JDK 和 CGLib 都是在运行期生成字节码，JDK 是直接写 Class 字节码，CGLib 使用 ASM 框架写 Class 字节码，Cglib 代理实现更复杂，生成代理类比 JDK 效率低。</p>
</li>
<li><p>JDK 调用代理方法，是通过反射机制调用，CGLib 是通过 FastClass 机制直接调用方法， CGLib 执行效率更高。</p>
</li>
</ol>
<h2 id="代理模式与-Spring"><a href="#代理模式与-Spring" class="headerlink" title="代理模式与 Spring"></a>代理模式与 Spring</h2><h3 id="代理模式在-Spring-源码中的应用"><a href="#代理模式在-Spring-源码中的应用" class="headerlink" title="代理模式在 Spring 源码中的应用"></a><strong>代理模式在 Spring 源码中的应用</strong></h3><p>先看 ProxyFactoryBean 核心的方法就是 getObject()方法，我们来看一下源码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123; </span><br><span class="line">  initializeAdvisorChain();</span><br><span class="line">  <span class="keyword">if</span> (isSingleton()) &#123;</span><br><span class="line">    <span class="keyword">return</span> getSingletonInstance(); </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.targetName == <span class="keyword">null</span>) &#123;</span><br><span class="line">      logger.warn(<span class="string">"Using non-singleton proxies with singleton targets is often undesirable. "</span> + <span class="string">"Enableprototype proxies by setting the 'targetName' property."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newPrototypeInstance(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 getObject()方法中，主要调用 getSingletonInstance()和 newPrototypeInstance(); 在 Spring 的配置中，如果不做任何设置，那么 Spring 代理生成的 Bean 都是单例对象。 如果修改 scope 则每次创建一个新的原型对象。newPrototypeInstance()里面的逻辑比 较复杂，我们后面的课程再做深入研究，这里我们先做简单的了解。</p>
<p>Spring 利用动态代理实现 AOP 有两个非常重要的类，一个是 JdkDynamicAopProxy 类 和 CglibAopProxy 类，来看一下类图:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfyplasskxj311a0fa7bx.jpg" alt="image-20200620135211816"></p>
<h3 id="Spring-中的代理选择原则"><a href="#Spring-中的代理选择原则" class="headerlink" title="Spring 中的代理选择原则"></a><strong>Spring 中的代理选择原则</strong></h3><ol>
<li><p>当 Bean 有实现接口时，Spring 就会用 JDK 的动态代理 </p>
</li>
<li><p>当 Bean 没有实现接口时，Spring 选择 CGLib。</p>
</li>
<li><p>Spring 可以通过配置强制使用 CGLib，只需在 Spring 的配置文件中加入如下代码:</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>参考资料:</p>
<p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.ht" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/core.ht</a> ml</p>
<h2 id="静态代理和动态的本质区别"><a href="#静态代理和动态的本质区别" class="headerlink" title="静态代理和动态的本质区别"></a>静态代理和动态的本质区别</h2><ol>
<li><p>静态代理只能通过手动完成代理操作，如果被代理类增加新的方法，代理类需要同步 新增，违背开闭原则。 </p>
</li>
<li><p>动态代理采用在运行时动态生成代码的方式，取消了对被代理类的扩展限制，遵循开 闭原则。 </p>
</li>
<li><p>若动态代理要对目标类的增强逻辑扩展，结合策略模式，只需要新增策略类便可完成， 无需修改代理类的代码。</p>
</li>
</ol>
<h2 id="代理模式的优缺点"><a href="#代理模式的优缺点" class="headerlink" title="代理模式的优缺点"></a>代理模式的优缺点</h2><p>使用代理模式具有以下几个优点: </p>
<ol>
<li><p>代理模式能将代理对象与真实被调用的目标对象分离。 </p>
</li>
<li><p>一定程度上降低了系统的耦合度，扩展性好。 </p>
</li>
<li><p>可以起到保护目标对象的作用。 </p>
</li>
<li><p>可以对目标对象的功能增强。 </p>
</li>
</ol>
<p>当然，代理模式也是有缺点的:</p>
<ol>
<li><p>代理模式会造成系统设计中类的数量增加。 </p>
</li>
<li><p>在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢。</p>
</li>
<li><p>增加了系统的复杂度。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>偏向锁</title>
    <url>/2020/06/18/%E5%81%8F%E5%90%91%E9%94%81/</url>
    <content><![CDATA[<h1 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h1><p>Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换ThreadID 的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>公平锁与非公平锁</title>
    <url>/2020/06/18/%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81/</url>
    <content><![CDATA[<h1 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h1><h2 id="公平锁（Fair）"><a href="#公平锁（Fair）" class="headerlink" title="公平锁（Fair）"></a>公平锁（Fair）</h2><p>加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得</p>
<h3 id="非公平锁（Nonfair）"><a href="#非公平锁（Nonfair）" class="headerlink" title="非公平锁（Nonfair）"></a>非公平锁（Nonfair）</h3><p>加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待</p>
<ol>
<li><p>非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列</p>
</li>
<li><p>Java 中的 synchronized 是非公平锁，ReentrantLock 默认的 lock()方法采用的是非公平锁。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>分段锁</title>
    <url>/2020/06/18/%E5%88%86%E6%AE%B5%E9%94%81/</url>
    <content><![CDATA[<p>分段锁也并非一种实际的锁，而是一种思想 ConcurrentHashMap 是学习分段锁的最好实践</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2020/06/20/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="单例模式的应用场景"><a href="#单例模式的应用场景" class="headerlink" title="单例模式的应用场景"></a><strong>单例模式的应用场景</strong></h2><p>单例模式(Singleton Pattern)是指确保一个类在任何情况下都绝对只有一个实例，并 提供一个全局访问点。单例模式是创建型模式。单例模式在现实生活中应用也非常广泛。 例如，国家主席、公司 CEO、部门经理等。在 J2EE 标准中，ServletContext、 ServletContextConfig 等;在 Spring 框架应用中 ApplicationContext;数据库的连接 池也都是单例形式。</p>
<h2 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a><strong>饿汉式单例</strong></h2><p>先来看单例模式的类结构图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfyiiaqxqmj30gk08igpd.jpg" alt="image-20200620094709265"></p>
<p>饿汉式单例是在类加载的时候就立即初始化，并且创建单例对象。绝对线程安全，在线 程还没出现以前就是实例化了，不可能存在访问安全问题。 优点:没有加任何的锁、执行效率比较高，在用户体验上来说，比懒汉式更好。 缺点:类加载的时候就初始化，不管用与不用都占着空间，浪费了内存，有可能占着茅 坑不拉屎。</p>
<p>Spring 中 IOC 容器 ApplicationContext 本身就是典型的饿汉式单例。接下来看一段代 码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123; </span><br><span class="line">  <span class="comment">//先静态、后动态 </span></span><br><span class="line">  <span class="comment">//先属性、后方法</span></span><br><span class="line">  <span class="comment">//先上后下</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton hungrySingleton = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> hungrySingleton;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有另外一种写法，利用静态代码块的机制:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//饿汉式静态块单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungryStaticSingleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungryStaticSingleton hungrySingleton;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    hungrySingleton = <span class="keyword">new</span> HungryStaticSingleton();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">HungryStaticSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungryStaticSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hungrySingleton; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种写法都非常的简单，也非常好理解，饿汉式适用在单例对象较少的情况。下面我 们来看性能更优的写法。</p>
<h2 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a><strong>懒汉式单例</strong></h2><p>懒汉式单例的特点是:被外部类调用的时候内部类才会加载，下面看懒汉式单例的简单 实现 LazySimpleSingleton:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式单例 </span></span><br><span class="line"><span class="comment">//在外部需要使用的时候才进行实例化 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySimpleSingleton</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">LazySimpleSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">//静态块，公共内存区域</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> LazySimpleSingleton lazy = <span class="keyword">null</span>; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySimpleSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lazy == <span class="keyword">null</span>)&#123;</span><br><span class="line">      lazy = <span class="keyword">new</span> LazySimpleSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lazy; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后写一个线程类 ExectorThread 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExectorThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123; </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LazySimpleSingleton singleton = LazySimpleSingleton.getInstance();</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + singleton);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端测试代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySimpleSingletonTest</span> </span>&#123; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ExectorThread()); </span><br><span class="line">     Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ExectorThread()); </span><br><span class="line">     t1.start();</span><br><span class="line">     t2.start();</span><br><span class="line">     System.out.println(<span class="string">"End"</span>); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一定几率出现创建两个不同结果的情况，意味着上面的单例存在线程安全隐患。</p>
<h3 id="双重检查锁的单例模式"><a href="#双重检查锁的单例模式" class="headerlink" title="双重检查锁的单例模式"></a>双重检查锁的单例模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyDoubleCheckSingleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyDoubleCheckSingleton lazy = <span class="keyword">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">LazyDoubleCheckSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyDoubleCheckSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lazy == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (LazyDoubleCheckSingleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazy == <span class="keyword">null</span>)&#123;</span><br><span class="line">          lazy = <span class="keyword">new</span> LazyDoubleCheckSingleton(); </span><br><span class="line">          <span class="comment">//1.分配内存给这个对象</span></span><br><span class="line">          <span class="comment">//2.初始化对象</span></span><br><span class="line">          <span class="comment">//3.设置 lazy 指向刚分配的内存地址</span></span><br><span class="line">        &#125; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lazy; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态内部类的单例模式"><a href="#静态内部类的单例模式" class="headerlink" title="静态内部类的单例模式"></a>静态内部类的单例模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这种形式兼顾饿汉式的内存浪费，也兼顾 synchronized 性能问题 //完美地屏蔽了这两个缺点</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInnerClassSingleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">//默认使用 LazyInnerClassGeneral 的时候，会先初始化内部类</span></span><br><span class="line">  <span class="comment">//如果没使用的话，内部类是不加载的 private LazyInnerClassSingleton()&#123;&#125;</span></span><br><span class="line">  <span class="comment">//每一个关键字都不是多余的</span></span><br><span class="line">  <span class="comment">//static 是为了使单例的空间共享</span></span><br><span class="line">  <span class="comment">//保证这个方法不会被重写，重载</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LazyInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//在返回结果以前，一定会先加载内部类</span></span><br><span class="line">    <span class="keyword">return</span> LazyHolder.LAZY; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//默认不加载</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LazyInnerClassSingleton LAZY = <span class="keyword">new</span> LazyInnerClassSingleton(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种形式兼顾饿汉式的内存浪费，也兼顾 synchronized 性能问题。内部类一定是要在方 法调用之前初始化，巧妙地避免了线程安全问题。由于这种方式比较简单，我们就不带 大家一步一步调试了。</p>
<h2 id="反射破坏单例"><a href="#反射破坏单例" class="headerlink" title="反射破坏单例"></a><strong>反射破坏单例</strong></h2><p>大家有没有发现，上面介绍的单例模式的构造方法除了加上 private 以外，没有做任何处 理。如果我们使用反射来调用其构造方法，然后，再调用 getInstance()方法，应该就会 两个不同的实例。现在来看一段测试代码，以 LazyInnerClassSingleton 为例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInnerClassSingletonTest</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment">//很无聊的情况下，进行破坏</span></span><br><span class="line">      Class&lt;?&gt; clazz = LazyInnerClassSingleton<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">      <span class="comment">//通过反射拿到私有的构造方法</span></span><br><span class="line">      Constructor c = clazz.getDeclaredConstructor(<span class="keyword">null</span>); </span><br><span class="line">      <span class="comment">//强制访问，强吻，不愿意也要吻</span></span><br><span class="line">      c.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">//暴力初始化</span></span><br><span class="line">      Object o1 = c.newInstance();</span><br><span class="line">      <span class="comment">//调用了两次构造方法，相当于 new 了两次 //犯了原则性问题，</span></span><br><span class="line">      Object o2 = c.newInstance();</span><br><span class="line">      System.out.println(o1 == o2); </span><br><span class="line">      Object o2 = c.newInstance();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123; </span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，是创建了两个不同的实例。现在，我们在其构造方法中做一些限制，一旦出现多 次重复创建，则直接抛出异常。来看优化后的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//史上最牛 B 的单例模式的实现方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInnerClassSingleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">//默认使用 LazyInnerClassGeneral 的时候，会先初始化内部类 //如果没使用的话，内部类是不加载的</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">LazyInnerClassSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(LazyHolder.LAZY != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"不允许创建多个实例"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//每一个关键字都不是多余的</span></span><br><span class="line">  <span class="comment">//static 是为了使单例的空间共享</span></span><br><span class="line">  <span class="comment">//保证这个方法不会被重写，重载</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LazyInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//在返回结果以前，一定会先加载内部类</span></span><br><span class="line">    <span class="keyword">return</span> LazyHolder.LAZY; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//默认不加载</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LazyInnerClassSingleton LAZY = <span class="keyword">new</span> LazyInnerClassSingleton(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="序列化破坏单例"><a href="#序列化破坏单例" class="headerlink" title="序列化破坏单例"></a><strong>序列化破坏单例</strong></h2><p>当我们将一个单例对象创建好，有时候需要将对象序列化然后写入到磁盘，下次使用时 再从磁盘中读取到对象，反序列化转化为内存对象。反序列化后的对象会重新分配内存， 即重新创建。那如果序列化的目标的对象为单例对象，就违背了单例模式的初衷，相当 于破坏了单例，来看一段代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反序列化时导致单例破坏</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeriableSingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="comment">//序列化就是说把内存中的状态通过转换成字节码的形式 </span></span><br><span class="line">  <span class="comment">//从而转换一个 IO 流，写入到其他地方(可以是磁盘、网络 IO) </span></span><br><span class="line">  <span class="comment">//内存中状态给永久保存下来了</span></span><br><span class="line">  <span class="comment">//反序列化</span></span><br><span class="line">  <span class="comment">//讲已经持久化的字节码内容，转换为 IO 流</span></span><br><span class="line">  <span class="comment">//通过 IO 流的读取，进而将读取的内容转换为 Java 对象 </span></span><br><span class="line">  <span class="comment">//在转换过程中会重新创建对象 new</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> SeriableSingleton INSTANCE = <span class="keyword">new</span> SeriableSingleton(); </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SeriableSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SeriableSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeriableSingletonTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SeriableSingleton s1 = <span class="keyword">null</span>;</span><br><span class="line">    SeriableSingleton s2 = SeriableSingleton.getInstance();</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"SeriableSingleton.obj"</span>); </span><br><span class="line">      ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos); oos.writeObject(s2);</span><br><span class="line">      oos.flush();</span><br><span class="line">      oos.close();</span><br><span class="line">      FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"SeriableSingleton.obj"</span>); </span><br><span class="line">      ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">      s1 = (SeriableSingleton)ois.readObject();</span><br><span class="line">      ois.close();</span><br><span class="line">      System.out.println(s1); </span><br><span class="line">      System.out.println(s2); </span><br><span class="line">      System.out.println(s1 == s2);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 运行结果中，可以看出，反序列化后的对象和手动创建的对象是不一致的，实例化了两 次，违背了单例的设计初衷。那么，我们如何保证序列化的情况下也能够实现单例?其</p>
<p>实很简单，只需要增加 readResolve()方法即可。来看优化代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeriableSingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> SeriableSingleton INSTANCE = <span class="keyword">new</span> SeriableSingleton();</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SeriableSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SeriableSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>共享锁和独占锁</title>
    <url>/2020/06/18/%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E7%8B%AC%E5%8D%A0%E9%94%81/</url>
    <content><![CDATA[<h1 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h1><p>java 并发包提供的加锁模式分为独占锁和共享锁。</p>
<h2 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a><strong>独占锁</strong></h2><p>独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。</p>
<p>独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。</p>
<h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a><strong>共享锁</strong></h2><p>共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。</p>
<ol>
<li><p>AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等待线程的锁获取模式。</p>
</li>
<li><p>java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，或者被一个 写操作访问，但两者不能同时进行。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2020/06/20/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="原型模式的应用场景"><a href="#原型模式的应用场景" class="headerlink" title="原型模式的应用场景"></a><strong>原型模式的应用场景</strong></h2><p>你一定遇到过大篇幅 getter、setter 赋值的场景。例如这样的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParam</span><span class="params">(ExamPaperVo vo)</span></span>&#123;</span><br><span class="line">  ExamPaper examPaper = <span class="keyword">new</span> ExamPaper();</span><br><span class="line">  <span class="comment">//试卷主键 </span></span><br><span class="line">  examPaper.setExaminationPaperId(vo.getExaminationPaperId()); </span><br><span class="line">  <span class="comment">//剩余时间</span></span><br><span class="line">  curForm.setLeavTime(examPaper.getLeavTime());</span><br><span class="line">  <span class="comment">//单位主键 </span></span><br><span class="line">  curForm.setOrganizationId(examPaper.getOrganizationId()); </span><br><span class="line">  <span class="comment">//考试主键</span></span><br><span class="line">  curForm.setId(examPaper.getId());</span><br><span class="line">  <span class="comment">//考场主键 </span></span><br><span class="line">  curForm.setExamroomId(examPaper.getExamroomId()); </span><br><span class="line">  <span class="comment">//用户主键 </span></span><br><span class="line">  curForm.setUserId(examPaper.getUserId());</span><br><span class="line">  <span class="comment">//专业 </span></span><br><span class="line">  curForm.setSpecialtyCode(examPaper.getSpecialtyCode()); </span><br><span class="line">  <span class="comment">//岗位 </span></span><br><span class="line">  curForm.setPostionCode(examPaper.getPostionCode()); </span><br><span class="line">  <span class="comment">//等级</span></span><br><span class="line">  curForm.setGradeCode(examPaper.getGradeCode()); </span><br><span class="line">  <span class="comment">//考试开始时间 </span></span><br><span class="line">  curForm.setExamStartTime(examPaper.getExamStartTime()); </span><br><span class="line">  <span class="comment">//考试结束时间</span></span><br><span class="line">  curForm.setExamEndTime(examPaper.getExamEndTime());</span><br><span class="line">  <span class="comment">//单选题重要数量 </span></span><br><span class="line">  curForm.setSingleSelectionImpCount(examPaper.getSingleSelectionImpCount()); </span><br><span class="line">  <span class="comment">//多选题重要数量 </span></span><br><span class="line">  curForm.setMultiSelectionImpCount(examPaper.getMultiSelectionImpCount()); </span><br><span class="line">  <span class="comment">//判断题重要数量 </span></span><br><span class="line">  curForm.setJudgementImpCount(examPaper.getJudgementImpCount());</span><br><span class="line">  <span class="comment">//考试时间</span></span><br><span class="line">  curForm.setExamTime(examPaper.getExamTime());</span><br><span class="line">  <span class="comment">//总分</span></span><br><span class="line">  curForm.setFullScore(examPaper.getFullScore());</span><br><span class="line">  <span class="comment">//及格分</span></span><br><span class="line">  curForm.setPassScore(examPaper.getPassScore());</span><br><span class="line">  <span class="comment">//学员姓名</span></span><br><span class="line">  curForm.setUserName(examPaper.getUserName());</span><br><span class="line">  <span class="comment">//分数</span></span><br><span class="line">  curForm.setScore(examPaper.getScore());</span><br><span class="line">  <span class="comment">//是否及格</span></span><br><span class="line">  curForm.setResult(examPaper.getResult()); </span><br><span class="line">  curForm.setIsPassed(examPaper.getIsPassed());</span><br><span class="line">  <span class="comment">//单选答对数量 </span></span><br><span class="line">  curForm.setSingleOkCount(examPaper.getSingleOkCount()); </span><br><span class="line">  <span class="comment">//多选答对数量 </span></span><br><span class="line">  curForm.setMultiOkCount(examPaper.getMultiOkCount()); </span><br><span class="line">  <span class="comment">//判断答对数量 </span></span><br><span class="line">  curForm.setJudgementOkCount(examPaper.getJudgementOkCount());</span><br><span class="line">  <span class="comment">//提交试卷</span></span><br><span class="line">  service.submit(examPaper); &#125;</span><br></pre></td></tr></table></figure>

<p>代码非常工整，命名非常规范，注释也写的很全面，大家觉得这样的代码优雅吗?我认 为，这样的代码属于纯体力劳动。那么原型模式，能帮助我们解决这样的问题。 原型模式(Prototype Pattern)是指原型实例指定创建对象的种类，并且通过拷贝这些 原型创建新的对象。</p>
<p>原型模式主要适用于以下场景:</p>
<ol>
<li>类初始化消耗资源较多。</li>
<li>new 产生的一个对象需要非常繁琐的过程(数据准备、访问权限等) </li>
<li>构造函数比较复杂。</li>
<li>循环体中生产大量对象时。</li>
</ol>
<p>在 Spring 中，原型模式应用得非常广泛。例如 scope=“prototype”，在我们经常用 的 JSON.parseObject()也是一种原型模式。下面，我们来看看原型模式类结构图:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfyhtavz0yj319y0ew4ac.jpg" alt="image-20200620092308215"></p>
<h2 id="简单克隆"><a href="#简单克隆" class="headerlink" title="简单克隆"></a><strong>简单克隆</strong></h2><p>一个标准的原型模式代码，应该是这样设计的。先创建原型 Prototype 接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Prototype</span></span>&#123; </span><br><span class="line">  <span class="function">Prototype <span class="title">clone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建具体需要克隆的对象 ConcretePrototype</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototypeA</span> <span class="keyword">implements</span> <span class="title">Prototype</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> List hobbies;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List <span class="title">getHobbies</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hobbies;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHobbies</span><span class="params">(List hobbies)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.hobbies = hobbies;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ConcretePrototypeA <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConcretePrototypeA concretePrototype = <span class="keyword">new</span> ConcretePrototypeA(); </span><br><span class="line">    concretePrototype.setAge(<span class="keyword">this</span>.age);</span><br><span class="line">    concretePrototype.setName(<span class="keyword">this</span>.name); </span><br><span class="line">    concretePrototype.setHobbies(<span class="keyword">this</span>.hobbies);</span><br><span class="line">    <span class="keyword">return</span> concretePrototype;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 Client 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Prototype prototype; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">(Prototype prototype)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.prototype = prototype; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Prototype <span class="title">startClone</span><span class="params">(Prototype concretePrototype)</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (Prototype)concretePrototype.clone();</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个具体的需要克隆的对象</span></span><br><span class="line">    ConcretePrototypeA concretePrototype = <span class="keyword">new</span> ConcretePrototypeA(); </span><br><span class="line">    <span class="comment">// 填充属性，方便测试</span></span><br><span class="line">    concretePrototype.setAge(<span class="number">18</span>); </span><br><span class="line">    concretePrototype.setName(<span class="string">"prototype"</span>);</span><br><span class="line">    List hobbies = <span class="keyword">new</span> ArrayList&lt;String&gt;(); </span><br><span class="line">    concretePrototype.setHobbies(hobbies); </span><br><span class="line">    System.out.println(concretePrototype);</span><br><span class="line">    <span class="comment">// 创建 Client 对象，准备开始克隆</span></span><br><span class="line">    Client client = <span class="keyword">new</span> Client(concretePrototype); </span><br><span class="line">    ConcretePrototypeA concretePrototypeClone = (ConcretePrototypeA)client.startClone(concretePrototype);</span><br><span class="line">    System.out.println(concretePrototypeClone);</span><br><span class="line">    System.out.println(<span class="string">"克隆对象中的引用类型地址值:"</span> + concretePrototypeClone.getHobbies()); </span><br><span class="line">    System.out.println(<span class="string">"原对象中的引用类型地址值:"</span> + concretePrototype.getHobbies()); </span><br><span class="line">    System.out.println(<span class="string">"对象地址比较:"</span>+(concretePrototypeClone.getHobbies() == concretePrototype.getHobbies())); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从测试结果看出 hobbies 的引用地址是相同的，意味着复制的不是值，而是引用的地址。 这样的话，如果我们修改任意一个对象中的属性值，concretePrototype 和 concretePrototypeCone 的 hobbies 值都会改变。这就是我们常说的浅克隆。只是完整 复制了值类型数据，没有赋值引用对象。换言之，所有的引用对象仍然指向原来的对象， 显然不是我们想要的结果。下面我们来看深度克隆继续改造。</p>
<h2 id="深度克隆"><a href="#深度克隆" class="headerlink" title="深度克隆"></a><strong>深度克隆</strong></h2><p>我们换一个场景，大家都知道齐天大圣。首先它是一只猴子，有七十二般变化，把一根 毫毛就可以吹出千万个泼猴，手里还拿着金箍棒，金箍棒可以变大变小。这就是我们耳 熟能详的原型模式的经典体现。<br> 创建原型猴子 Monkey 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> </span>&#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> height; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> weight; </span><br><span class="line">  <span class="keyword">public</span> Date birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建引用对象金箍棒 Jingubang 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JinGuBang</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">float</span> h = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">float</span> d = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">big</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.d *= <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">this</span>.h *= <span class="number">2</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">small</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.d /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.h /= <span class="number">2</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建具体的对象齐天大圣 QiTianDaSheng 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QiTianDaSheng</span> <span class="keyword">extends</span> <span class="title">Monkey</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> JinGuBang jinGuBang;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QiTianDaSheng</span><span class="params">()</span> </span>&#123; <span class="comment">//只是初始化</span></span><br><span class="line">        <span class="keyword">this</span>.birthday = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">this</span>.jinGuBang = <span class="keyword">new</span> JinGuBang();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.deepClone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">            oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line">            ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">            QiTianDaSheng copy = (QiTianDaSheng) ois.readObject();</span><br><span class="line">            copy.birthday = <span class="keyword">new</span> Date();</span><br><span class="line">            <span class="keyword">return</span> copy;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> QiTianDaSheng <span class="title">shallowClone</span><span class="params">(QiTianDaSheng target)</span> </span>&#123;</span><br><span class="line">        QiTianDaSheng qiTianDaSheng = <span class="keyword">new</span> QiTianDaSheng();</span><br><span class="line">        qiTianDaSheng.height = target.height;</span><br><span class="line">        qiTianDaSheng.weight = target.height;</span><br><span class="line">        qiTianDaSheng.jinGuBang = target.jinGuBang;</span><br><span class="line">        qiTianDaSheng.birthday = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">return</span> qiTianDaSheng;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="克隆破坏单例模式"><a href="#克隆破坏单例模式" class="headerlink" title="克隆破坏单例模式"></a><strong>克隆破坏单例模式</strong></h2><p>如果我们克隆的目标的对象是单例对象，那意味着，深克隆就会破坏单例。实际上防止 克隆破坏单例解决思路非常简单，禁止深克隆便可。要么你我们的单例类不实现 Cloneable 接口;要么我们重写 clone()方法，在 clone 方法中返回单例对象即可，具体代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Cloneable-源码分析"><a href="#Cloneable-源码分析" class="headerlink" title="Cloneable 源码分析"></a><strong>Cloneable 源码分析</strong></h2><p>先看我们常用的 ArrayList 就实现了 Cloneable 接口，来看代码 clone()方法的实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    ArrayList&lt;?&gt; v=(ArrayList&lt;?&gt;)<span class="keyword">super</span>.clone();v.elementData=Arrays.copyOf(elementData,size);</span><br><span class="line">    v.modCount=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">  &#125;<span class="keyword">catch</span>(CloneNotSupportedException e)&#123;</span><br><span class="line">    <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>可重入锁（递归锁）</title>
    <url>/2020/06/18/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%88%E9%80%92%E5%BD%92%E9%94%81%EF%BC%89/</url>
    <content><![CDATA[<h1 id="可重入锁（递归锁）"><a href="#可重入锁（递归锁）" class="headerlink" title="可重入锁（递归锁）"></a>可重入锁（递归锁）</h1><p>本文里面讲的是广义上的可重入锁，而不是单指 JAVA 下的 ReentrantLock。可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。在 JAVA 环境下 ReentrantLock 和 synchronized 都是 可重入锁。</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>各设计模式总结与对比</title>
    <url>/2020/06/21/%E5%90%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h1 id="各设计模式总结与对比"><a href="#各设计模式总结与对比" class="headerlink" title="各设计模式总结与对比"></a>各设计模式总结与对比</h1><h2 id="GOF-23-种设计模式简介"><a href="#GOF-23-种设计模式简介" class="headerlink" title="GOF 23 种设计模式简介"></a>GOF 23 种设计模式简介</h2><p>设计模式其实一门艺术。设计模式来源于生活，不要为了套用设计模式而去使用设计模 式。设计模式是在我们迷茫时提供的一种解决问题的方案，或者说用好设计模式可以防 范于未然。自古以来 ，在我们人生迷茫时，我们往往都会寻求帮助，或上门咨询，或查 经问典。就在几千年前，孔夫子就教给了我们怎样做人。对于中国人来说都知道:从出 生元婴、二十加冕、三十而立、四十不惑、五十知天命、六十花甲、七十古稀不逾矩、 八、九十耄耋… …我们这就是在用模板模式，当然，有些人不会选择这套模板。 设计模式总结的是经验之谈,总结的是前人的经验，提供给后人去借鉴使用，前人栽树， 后人乘凉。设计模式可以帮助我们提升代码的可读性、可扩展性;降低维护成本;解决 复杂的业务问题，但是，千万千万不要死记硬背，生搬硬套。</p>
<p>下面我们还是先来总体预览一下 GOF 23 种设计模式的归纳和总结。</p>
<table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th><strong>设计模式</strong></th>
</tr>
</thead>
<tbody><tr>
<td>创建型</td>
<td>工厂方法模式(Factory Method)、抽象工厂模式(Abstract Factory)、 建造者模式(Builder)、原型模式(Prototype)、单例模式(Singleton)</td>
</tr>
<tr>
<td>结构型</td>
<td>适配器模式(Adapter)、桥接模式(Bridge)、组合模式(Composite)、 装饰器模式(Decorator)、门面模式(Facade)、享元模式(Flyweight)、 代理模式(Proxy)</td>
</tr>
<tr>
<td>行为型</td>
<td>解释器模式(Interpreter)、模板方法模式(Template Method)、 责任链模式(Chain of Responsibility)、命令模式(Command)、 迭代器模式(Iterator)、调解者模式(Mediator)、备忘录模式(Memento)、 观察者模式(Observer)、状态模式(State)、策略模式(Strategy)、 访问者模式(Visitor)</td>
</tr>
</tbody></table>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfzt44fdd0j30v20u07st.jpg" alt="image-20200621123941080"></p>
<h2 id="设计模式之间的关联关系和对比"><a href="#设计模式之间的关联关系和对比" class="headerlink" title="设计模式之间的关联关系和对比"></a>设计模式之间的关联关系和对比</h2><h3 id="单例模式和工厂模式"><a href="#单例模式和工厂模式" class="headerlink" title="单例模式和工厂模式"></a><strong>单例模式和工厂模式</strong></h3><p>实际业务代码中，通常会把工厂类设计为单例。</p>
<h3 id="策略模式和工厂模式"><a href="#策略模式和工厂模式" class="headerlink" title="策略模式和工厂模式"></a><strong>策略模式和工厂模式</strong></h3><ol>
<li><p>工厂模式包含工厂方法模式和抽象工厂模式是创建型模式，策略模式属于行为型模 式。</p>
</li>
<li><p>工厂模式主要目的是封装好创建逻辑，策略模式接收工厂创建好的对象，从而实现不 同的行为。</p>
</li>
</ol>
<h3 id="策略模式和委派模式"><a href="#策略模式和委派模式" class="headerlink" title="策略模式和委派模式"></a><strong>策略模式和委派模式</strong></h3><ol>
<li><p>策略模式是委派模式内部的一种实现形式，策略模式关注的结果是否能相互替代。 </p>
</li>
<li><p>委派模式更关注分发和调度的过程。</p>
</li>
</ol>
<h3 id="模板方法模式和工厂方法模式"><a href="#模板方法模式和工厂方法模式" class="headerlink" title="模板方法模式和工厂方法模式"></a><strong>模板方法模式和工厂方法模式</strong></h3><p>工厂方法是模板方法的一种特殊实现。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfzt6fqm3qj31hq0oie02.jpg" alt="image-20200621124153877"></p>
<p>对于工厂方法模式的 create()方法而言，相当于只有一个步骤的模板方法模式。这一个步 骤交给子类去实现。而模板方法呢，将 needHomework()方法和 checkHomework()方 法交给子类实现，needHomework()方法和 checkHomework()方法又属于父类的某一 个步骤且不可变更。</p>
<h3 id="模板方法模式和策略模式"><a href="#模板方法模式和策略模式" class="headerlink" title="模板方法模式和策略模式"></a><strong>模板方法模式和策略模式</strong></h3><ol>
<li><p>模板方法和策略模式都有封装算法。 </p>
</li>
<li><p>策略模式是使不同算法可以相互替换，且不影响客户端应用层的使用。 </p>
</li>
<li><p>模板方法是针对定义一个算法的流程，将一些有细微差异的部分交给子类实现。 </p>
</li>
<li><p>模板方法模式不能改变算法流程，策略模式可以改变算法流程且可替换。策略模式通 常用来代替 if…else…等条件分支语句。</p>
</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfzt7m6w2xj31l20eonei.jpg" alt="image-20200621124302208"></p>
<ol>
<li>WechatPay、JDPay、AliPay 是交给用户选择且相互替代解决方案。而 JdbcTemplate 下面的子类是不能相互代替的。</li>
<li>策略模式中的 queryBalance()方法虽然在 pay()方法中也有调用，但是这个逻辑只是 出于程序健壮性考虑。用户完全可以自主调用 queryBalance()方法。而模板方法模式中 的 mapRow()方法一定要在获得 ResultSet 之后方可调用，否则没有意义。</li>
</ol>
<h3 id="装饰者模式和静态代理模式"><a href="#装饰者模式和静态代理模式" class="headerlink" title="装饰者模式和静态代理模式"></a><strong>装饰者模式和静态代理模式</strong></h3><ol>
<li><p>装饰者模式关注点在于给对象动态添加方法，而代理更加注重控制对对象的访问。</p>
</li>
<li><p>代理模式通常会在代理类中创建被代理对象的实例，而装饰者模式通常把被装饰者作 为构造参数。</p>
</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfzt9frluej31ai0nmtpc.jpg" alt="image-20200621124447395"></p>
<p>装饰者和代理者虽然都持有对方引用，但逻辑处理重心是不一样的。</p>
<h3 id="装饰者模式和适配器模式"><a href="#装饰者模式和适配器模式" class="headerlink" title="装饰者模式和适配器模式"></a><strong>装饰者模式和适配器模式</strong></h3><ol>
<li><p>装饰者模式和适配器模式都是属于包装器模式(Wrapper Pattern)。 </p>
</li>
<li><p>装饰者模式可以实现被装饰者与相同的接口或者继承被装饰者作为它的子类，而适配 器和被适配者可以实现不同的接口。</p>
</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfztackkn3j31jw0g6av1.jpg" alt="image-20200621124539813"></p>
<p>装饰者和适配器都是对 SiginService 的包装和扩展，属于装饰器模式的实现形式。但是 装饰者需要满足 OOP 的 is-a 关系，我们也讲过煎饼的例子，不管如何包装都有共同的父类。而适配器主要解决兼容问题，不一定要统一父类，上图中 LoginAdapter 和 RegistAdapter 就是兼容不同功能的两个类，但 RegistForQQAdapter 需要注册后自动 登录，因此既继承了 RegistAdpter 又继承了 LoginAdapter。</p>
<h3 id="适配器模式和静态代理模式"><a href="#适配器模式和静态代理模式" class="headerlink" title="适配器模式和静态代理模式"></a><strong>适配器模式和静态代理模式</strong></h3><p>适配器可以结合静态代理来实现，保存被适配对象的引用，但不是唯一的实现方式。</p>
<h3 id="适配器模式和策略模式"><a href="#适配器模式和策略模式" class="headerlink" title="适配器模式和策略模式"></a><strong>适配器模式和策略模式</strong></h3><p>在适配业务复杂的情况下，利用策略模式优化动态适配逻辑。</p>
<h2 id="Spring-中常用的设计模式对比"><a href="#Spring-中常用的设计模式对比" class="headerlink" title="Spring 中常用的设计模式对比"></a>Spring 中常用的设计模式对比</h2><p>各设计模式对比及编程思想总结</p>
<table>
<thead>
<tr>
<th><strong>设计模式</strong></th>
<th><strong>一句话归纳</strong></th>
<th><strong>举例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>工厂模式(Factory)</td>
<td>只对结果负责，封装创建过程。</td>
<td>BeanFactory、Calender</td>
</tr>
<tr>
<td>单例模式(Singleton)</td>
<td>保证独一无二。</td>
<td>ApplicationContext、Calender</td>
</tr>
<tr>
<td>原型模式(Prototype)</td>
<td>拔一根猴毛，吹出千万个。</td>
<td>ArrayList、PrototypeBean</td>
</tr>
<tr>
<td>代理模式(Proxy)</td>
<td>找人办事，增强职责。</td>
<td>ProxyFactoryBean、 JdkDynamicAopProxy、CglibAopProxy</td>
</tr>
<tr>
<td>委派模式(Delegate)</td>
<td>干活算你的(普通员工)，功 劳算我的(项目经理)。</td>
<td>DispatcherServlet、 BeanDefinitionParserDelegate</td>
</tr>
<tr>
<td>策略模式(Strategy)</td>
<td>用户选择，结果统一。</td>
<td>InstantiationStrategy</td>
</tr>
<tr>
<td>模板模式(Template)</td>
<td>流程标准化，自己实现定制。</td>
<td>JdbcTemplate、HttpServlet</td>
</tr>
<tr>
<td>适配器模式(Adapter)</td>
<td>兼容转换头。</td>
<td>AdvisorAdapter、HandlerAdapter</td>
</tr>
<tr>
<td>装饰器模式(Decorator)</td>
<td>包装，同宗同源。</td>
<td>BufferedReader、InputStream、OutputStream、 HttpHeadResponseDecorator</td>
</tr>
<tr>
<td>观察者模式(Observer)</td>
<td>任务完成时通知。</td>
<td>ContextLoaderListener</td>
</tr>
</tbody></table>
<h2 id="Spring-中的编程思想总结"><a href="#Spring-中的编程思想总结" class="headerlink" title="Spring 中的编程思想总结"></a>Spring 中的编程思想总结</h2><table>
<thead>
<tr>
<th><strong>Spring 思想</strong></th>
<th><strong>应用场景(特点)</strong></th>
<th><strong>一句话归纳</strong></th>
</tr>
</thead>
<tbody><tr>
<td>OOP</td>
<td>Object Oriented Programming(面向对象编 程)用程序归纳总结生活中一切事物。</td>
<td>封装、继承、多态。</td>
</tr>
<tr>
<td>BOP</td>
<td>Bean Oriented Programming(面向 Bean 编 程)面向 Bean(普通的 Java 类)设计程序， 解放程序员。</td>
<td>一切从 Bean 开始。</td>
</tr>
<tr>
<td>AOP</td>
<td>Aspect Oriented Programming(面向切面编 程)找出多个类中有一定规律的代码，开发时拆 开，运行时再合并。 面向切面编程，即面向规则编程。</td>
<td>解耦，专人做专事。</td>
</tr>
<tr>
<td>IOC</td>
<td>Inversion of Control(控制反转)将 new 对象的动作交给 Spring 管理，并由 Spring 保存已创建的对象(IOC 容器)。</td>
<td>转交控制权(即控制权反转)</td>
</tr>
<tr>
<td>DI/DL</td>
<td>Dependency Injection(依赖注入)或者 Dependency Lookup(依赖查找) 依赖注入、依赖查找，Spring 不仅保存自己创 建的对象，而且保存对象与对象之间的关系。注入即赋值，主要三种方式构造方法、set 方法、 直接赋值。</td>
<td>赋值</td>
</tr>
</tbody></table>
<h3 id="AOP-在-Spring-中的应用"><a href="#AOP-在-Spring-中的应用" class="headerlink" title="AOP 在 Spring 中的应用"></a><strong>AOP 在 Spring 中的应用</strong></h3><p>SpringAOP 是一种编程范式，主要目的是将非功能性需求从功能性需求中分离出来，达 到解耦的目的。主要应用场景有:Authentication(权限认证)、Auto Caching(自 动缓存处理)、Error Handling(统一错误处理)、Debugging(调试信息输出)、 Logging(日志记录)、Transactions(事务处理)。现实生活中也常常使用 AOP 思维来解决实际问题，如飞机组装、汽车组装等(如下图)。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfztj5zvikj31hi0ggayu.jpg" alt="image-20200621125408820"></p>
<p>飞机各部件的零件会交给不同的厂家去生产，最终由组装工厂将各个部件组装起来 变成一个整体。将零件的生产交出去主要目的是解耦，但是解耦之前必须有统一的 标准。</p>
<p><strong>学习 AOP 之前必须明白的几个概念:</strong></p>
<ol>
<li><p>Aspect(切面):通常是一个类，里面可以定义切入点和通知。 </p>
</li>
<li><p>JointPoint(连接点):程序执行过程中明确的点，一般是方法的调用。</p>
</li>
<li><p>Advice(通知):AOP 在特定的切入点上执行的增强处理，有 before、after、 afterReturning、afterThrowing、around</p>
</li>
<li><p>Pointcut(切入点):就是带有通知的连接点，在程序中主要体现为书写切入点表达式AOP 框架创建的对象，实际就是使用代理对目标对象功能增强。Spring 中的 AOP 代理 可以使 JDK 动态代理，也可以是 CGLIB 代理，前者基于接口，后者基于子类。</p>
</li>
</ol>
<p><strong>关于 Execution 表达式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) <span class="keyword">throws</span>-pattern?)</span><br></pre></td></tr></table></figure>

<p>modifiers-pattern:方法的操作权限 </p>
<p>ret-type-pattern:返回值【必填】 </p>
<p>declaring-type-pattern:方法所在的包 </p>
<p>name-pattern:方法名 【必填】 </p>
<p>parm-pattern:参数名 </p>
<p>throws-pattern:异常</p>
<p>目前 SpringAOP 配置有两种形式，这个小伙伴们应该都非常清楚，我这里就不做 过多赘述，如下 Annotation 配置形式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明这是一个组件 </span></span><br><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="comment">//声明这是一个切面 Bean </span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotaionAspect</span> </span>&#123;</span><br><span class="line"><span class="comment">//配置切入点,该方法无方法体,主要为方便同类中其他方法使用此处配置的切入点 </span></span><br><span class="line">  <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.gupaoedu.vip.pattern.spring.aop.service..*(..))"</span>) </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aspect</span><span class="params">()</span></span>&#123; </span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//配置前置通知,使用在方法 aspect()上注册的切入点,同时接受 JoinPoint 切入点对象,可以没有该参数</span></span><br><span class="line">  <span class="meta">@Before</span>(<span class="string">"aspect()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">    log.info(<span class="string">"before 通知 "</span> + joinPoint); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//配置后置通知,使用在方法 aspect()上注册的切入点 </span></span><br><span class="line">  <span class="meta">@After</span>(<span class="string">"aspect()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">    log.info(<span class="string">"after通知 "</span>+joinPoint); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//配置环绕通知,使用在方法 aspect()上注册的切入点 </span></span><br><span class="line">  <span class="meta">@Around</span>(<span class="string">"aspect()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis(); </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ((ProceedingJoinPoint) joinPoint).proceed();</span><br><span class="line">      <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">      log.info(<span class="string">"around 通知 "</span> + joinPoint + <span class="string">"\tUse time : "</span> + (end - start) + <span class="string">" ms!"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">      log.info(<span class="string">"around 通知 "</span> + joinPoint + <span class="string">"\tUse time : "</span> + (end - start) + <span class="string">" ms with exception :"</span> + e.getMessage()); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//配置后置返回通知,使用在方法 aspect()上注册的切入点 </span></span><br><span class="line">  <span class="meta">@AfterReturning</span>(<span class="string">"aspect()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturn</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">    log.info(<span class="string">"afterReturn 通知 "</span> + joinPoint); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//配置抛出异常后通知,使用在方法 aspect()上注册的切入点 </span></span><br><span class="line">  <span class="meta">@AfterThrowing</span>(pointcut=<span class="string">"aspect()"</span>, throwing=<span class="string">"ex"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrow</span><span class="params">(JoinPoint joinPoint, Exception ex)</span></span>&#123;</span><br><span class="line">    log.info(<span class="string">"afterThrow 通知 "</span> + joinPoint + <span class="string">"\t"</span> + ex.getMessage()); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Xml 配置形式:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"xmlAspect"</span> <span class="attr">class</span>=<span class="string">"com.gupaoedu.vip.pattern.spring.aop.aspect.XmlAspect"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- AOP 配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 声明一个切面,并注入切面 Bean,相当于@Aspect --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"xmlAspect"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置一个切入点,相当于@Pointcut --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* com.gupaoedu.vip.pattern.spring.aop.service..*(..))"</span> <span class="attr">id</span>=<span class="string">"simplePointcut"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置通知,相当于@Before、@After、@AfterReturn、@Around、@AfterThrowing --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"simplePointcut"</span> <span class="attr">method</span>=<span class="string">"before"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut-ref</span>=<span class="string">"simplePointcut"</span> <span class="attr">method</span>=<span class="string">"after"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut-ref</span>=<span class="string">"simplePointcut"</span> <span class="attr">method</span>=<span class="string">"afterReturn"</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut-ref</span>=<span class="string">"simplePointcut"</span> <span class="attr">method</span>=<span class="string">"afterThrow"</span> <span class="attr">throwing</span>=<span class="string">"ex"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>委派模式以及策略模式</title>
    <url>/2020/06/20/%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="委派模式以及策略模式"><a href="#委派模式以及策略模式" class="headerlink" title="委派模式以及策略模式"></a>委派模式以及策略模式</h1><h2 id="委派模式"><a href="#委派模式" class="headerlink" title="委派模式"></a>委派模式</h2><h3 id="委派模式的定义及应用场景"><a href="#委派模式的定义及应用场景" class="headerlink" title="委派模式的定义及应用场景"></a>委派模式的定义及应用场景</h3><p>委派模式不属于 GOF23 种设计模式中。委派模式(Delegate Pattern)的基本作用就是 负责任务的调用和分配任务，跟代理模式很像，可以看做是一种特殊情况下的静态代理 的全权代理，但是代理模式注重过程，而委派模式注重结果。委派模式在 Spring 中应用 非常多，大家常用的 DispatcherServlet 其实就是用到了委派模式。现实生活中也常有委 派的场景发生，例如:老板(Boss)给项目经理(Leader)下达任务，项目经理会根据 实际情况给每个员工派发工作任务，待员工把工作任务完成之后，再由项目经理汇报工 作进度和结果给老板。我们用代码来模拟下这个业务场景，先来看一下类图:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfyt6ebq11j30ty0nsh04.jpg" alt="image-20200620155618318"></p>
<h3 id="委派模式在源码中的体现"><a href="#委派模式在源码中的体现" class="headerlink" title="委派模式在源码中的体现"></a><strong>委派模式在源码中的体现</strong></h3><p>在 Spring 源码中，只要以 Delegate 结尾的 都是实现了委派模式。例如:BeanDefinitionParserDelegate 根据不同类型委派不同的 逻辑解析 BeanDefinition。</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式(Strategy Pattern)是指定义了算法家族、分别封装起来，让它们之间可以互 相替换，此模式让算法的变化不会影响到使用算法的用户。</p>
<h3 id="策略模式的应用场景"><a href="#策略模式的应用场景" class="headerlink" title="策略模式的应用场景"></a><strong>策略模式的应用场景</strong></h3><ol>
<li><p>假如系统中有很多类，而他们的区别仅仅在于他们的行为不同。</p>
</li>
<li><p>一个系统需要动态地在几种算法中选择一种。</p>
</li>
</ol>
<h3 id="策略模式在-JDK-源码中的体现"><a href="#策略模式在-JDK-源码中的体现" class="headerlink" title="策略模式在 JDK 源码中的体现"></a><strong>策略模式在 JDK 源码中的体现</strong></h3><p>首先来看一个比较常用的比较器 Comparator 接口，我们看到的一个大家常用的 compare()方法，就是一个策略抽象实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Comparator 抽象下面有非常多的实现类，我们经常会把 Comparator 作为参数传入作 为排序策略，例如 Arrays 类的 parallelSort 方法等:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Arrays</span> </span>&#123; </span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">parallelSort</span><span class="params">(T[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, Comparator&lt;? <span class="keyword">super</span> T&gt; cmp)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有 TreeMap 的构造方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">  &#125; </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是 Comparator 在 JDK 源码中的应用。那我们来看策略模式在 Spring 源码中的应 用，来看 Resource 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resource</span> <span class="keyword">extends</span> <span class="title">InputStreamSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Determine whether this resource actually exists in physical form.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;This method performs a definitive existence check, whereas the</span></span><br><span class="line"><span class="comment">    * existence of a &#123;<span class="doctag">@code</span> Resource&#125; handle only guarantees a valid</span></span><br><span class="line"><span class="comment">    * descriptor handle.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Indicate whether the contents of this resource can be read via</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #getInputStream()&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Will be &#123;<span class="doctag">@code</span> true&#125; for typical resource descriptors;</span></span><br><span class="line"><span class="comment">    * note that actual content reading may still fail when attempted.</span></span><br><span class="line"><span class="comment">    * However, a value of &#123;<span class="doctag">@code</span> false&#125; is a definitive indication</span></span><br><span class="line"><span class="comment">    * that the resource content cannot be read.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getInputStream()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Indicate whether this resource represents a handle with an open stream.</span></span><br><span class="line"><span class="comment">    * If &#123;<span class="doctag">@code</span> true&#125;, the InputStream cannot be read multiple times,</span></span><br><span class="line"><span class="comment">    * and must be read and closed to avoid resource leaks.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Will be &#123;<span class="doctag">@code</span> false&#125; for typical resource descriptors.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Determine whether this resource represents a file in a file system.</span></span><br><span class="line"><span class="comment">    * A value of &#123;<span class="doctag">@code</span> true&#125; strongly suggests (but does not guarantee)</span></span><br><span class="line"><span class="comment">    * that a &#123;<span class="doctag">@link</span> #getFile()&#125; call will succeed.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;This is conservatively &#123;<span class="doctag">@code</span> false&#125; by default.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getFile()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return a URL handle for this resource.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IOException if the resource cannot be resolved as URL,</span></span><br><span class="line"><span class="comment">    * i.e. if the resource is not available as descriptor</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">URL <span class="title">getURL</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return a URI handle for this resource.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IOException if the resource cannot be resolved as URI,</span></span><br><span class="line"><span class="comment">    * i.e. if the resource is not available as descriptor</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">URI <span class="title">getURI</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return a File handle for this resource.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> java.io.FileNotFoundException if the resource cannot be resolved as</span></span><br><span class="line"><span class="comment">    * absolute file path, i.e. if the resource is not available in a file system</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IOException in case of general resolution/reading failures</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getInputStream()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">File <span class="title">getFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return a &#123;<span class="doctag">@link</span> ReadableByteChannel&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;It is expected that each call creates a &lt;i&gt;fresh&lt;/i&gt; channel.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;The default implementation returns &#123;<span class="doctag">@link</span> Channels#newChannel(InputStream)&#125;</span></span><br><span class="line"><span class="comment">    * with the result of &#123;<span class="doctag">@link</span> #getInputStream()&#125;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the byte channel for the underlying resource (must not be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> java.io.FileNotFoundException if the underlying resource doesn't exist</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IOException if the content channel could not be opened</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getInputStream()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">default</span> ReadableByteChannel <span class="title">readableChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Channels.newChannel(getInputStream());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Determine the content length for this resource.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IOException if the resource cannot be resolved</span></span><br><span class="line"><span class="comment">    * (in the file system or as some other known physical resource type)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">long</span> <span class="title">contentLength</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Determine the last-modified timestamp for this resource.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IOException if the resource cannot be resolved</span></span><br><span class="line"><span class="comment">    * (in the file system or as some other known physical resource type)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Create a resource relative to this resource.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> relativePath the relative path (relative to this resource)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the resource handle for the relative resource</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IOException if the relative resource cannot be determined</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">Resource <span class="title">createRelative</span><span class="params">(String relativePath)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Determine a filename for this resource, i.e. typically the last</span></span><br><span class="line"><span class="comment">    * part of the path: for example, "myfile.txt".</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Returns &#123;<span class="doctag">@code</span> null&#125; if this type of resource does not</span></span><br><span class="line"><span class="comment">    * have a filename.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">String <span class="title">getFilename</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return a description for this resource,</span></span><br><span class="line"><span class="comment">    * to be used for error output when working with the resource.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Implementations are also encouraged to return this value</span></span><br><span class="line"><span class="comment">    * from their &#123;<span class="doctag">@code</span> toString&#125; method.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> Object#toString()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们虽然没有直接使用 Resource 类，但是我们经常使用它的子类，例如:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfytlqr7doj30zo0sw78u.jpg" alt="image-20200620161102750"></p>
<p>还有一个非常典型的场景，Spring 的初始化也采用了策略模式，不同的类型的类采用不 同的初始化策略。首先有一个 InstantiationStrategy 接口，我们来看一下源码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstantiationStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return an instance of the bean with the given name in this factory.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> bd the bean definition</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanName the name of the bean when it's created in this context.</span></span><br><span class="line"><span class="comment">    * The name can be &#123;<span class="doctag">@code</span> null&#125; if we're autowiring a bean which doesn't</span></span><br><span class="line"><span class="comment">    * belong to the factory.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> owner the owning BeanFactory</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> a bean instance for this bean definition</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeansException if the instantiation attempt failed</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return an instance of the bean with the given name in this factory,</span></span><br><span class="line"><span class="comment">    * creating it via the given constructor.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> bd the bean definition</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanName the name of the bean when it's created in this context.</span></span><br><span class="line"><span class="comment">    * The name can be &#123;<span class="doctag">@code</span> null&#125; if we're autowiring a bean which doesn't</span></span><br><span class="line"><span class="comment">    * belong to the factory.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> owner the owning BeanFactory</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> ctor the constructor to use</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> args the constructor arguments to apply</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> a bean instance for this bean definition</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeansException if the instantiation attempt failed</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,</span></span></span><br><span class="line"><span class="function"><span class="params">         Constructor&lt;?&gt; ctor, @Nullable Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return an instance of the bean with the given name in this factory,</span></span><br><span class="line"><span class="comment">    * creating it via the given factory method.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> bd the bean definition</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanName the name of the bean when it's created in this context.</span></span><br><span class="line"><span class="comment">    * The name can be &#123;<span class="doctag">@code</span> null&#125; if we're autowiring a bean which doesn't</span></span><br><span class="line"><span class="comment">    * belong to the factory.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> owner the owning BeanFactory</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> factoryBean the factory bean instance to call the factory method on,</span></span><br><span class="line"><span class="comment">    * or &#123;<span class="doctag">@code</span> null&#125; in case of a static factory method</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> factoryMethod the factory method to use</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> args the factory method arguments to apply</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> a bean instance for this bean definition</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeansException if the instantiation attempt failed</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,</span></span></span><br><span class="line"><span class="function"><span class="params">         @Nullable Object factoryBean, Method factoryMethod, @Nullable Object... args)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfytn8srqfj311e0g6767.jpg" alt="image-20200620161229040"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfytpcouayj30r80j840y.jpg" alt="image-20200620161431760"></p>
<p>打开类图我们还发现 CglibSubclassingInstantiationStrategy 策略类还继承了 SimpleInstantiationStrategy 类，说明在实际应用中多种策略之间还可以继承使用。小伙们可以作为一个参考，在实际业务场景中，可以根据需要来设计。</p>
<h3 id="策略模式的优缺点"><a href="#策略模式的优缺点" class="headerlink" title="策略模式的优缺点"></a><strong>策略模式的优缺点</strong></h3><p>优点:</p>
<ol>
<li><p>策略模式符合开闭原则。</p>
</li>
<li><p>避免使用多重条件转移语句，如 if…else…语句、switch 语句 3、使用策略模式可以提高算法的保密性和安全性。</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>客户端必须知道所有的策略，并且自行决定使用哪一个策略类。</p>
</li>
<li><p>代码中会产生非常多策略类，增加维护难度。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2020/06/19/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="工厂模式详解"><a href="#工厂模式详解" class="headerlink" title="工厂模式详解"></a>工厂模式详解</h2><h3 id="工厂模式的历史由来"><a href="#工厂模式的历史由来" class="headerlink" title="工厂模式的历史由来"></a><strong>工厂模式的历史由来</strong></h3><p>在现实生活中我们都知道，原始社会自给自足(没有工厂)、农耕社会小作坊(简单工 厂，民间酒坊)、工业革命流水线(工厂方法，自产自销)、现代产业链代工厂(抽象工厂， 富士康)</p>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>简单工厂模式(Simple Factory Pattern)是指由一个工厂对象决定创建出哪一种产品类 的实例，但它不属于 GOF，23 种设计模式(参考资料: <a href="http://en.wikipedia.org/wiki/Design_Patterns#Patterns_by_Type)。简单工厂适用" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Design_Patterns#Patterns_by_Type)。简单工厂适用</a> 于工厂类负责创建的对象较少的场景，且客户端只需要传入工厂类的参数，对于如何创 建对象的逻辑不需要关心。 接下来我们来看代码，还是以课程为例。目前开设有 Java 架构、大数据、人工 智能等课程，已经形成了一个生态。我们可以定义一个课程标准 ICourse 接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICourse</span> </span>&#123; </span><br><span class="line">  <span class="comment">/** 录制视频 */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">record</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个 Java 课程的实现 JavaCourse 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaCourse</span> <span class="keyword">implements</span> <span class="title">ICourse</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">record</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"录制 Java 课程"</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看客户端调用代码，我们会这样写:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">  ICourse course = <span class="keyword">new</span> JavaCourse(); </span><br><span class="line">  course.record();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看上面的代码，父类 ICourse 指向子类 JavaCourse 的引用，应用层代码需要依赖 JavaCourse，如果业务扩展，我继续增加 PythonCourse 甚至更多，那么我们客户端的 依赖会变得越来越臃肿。因此，我们要想办法把这种依赖减弱，把创建细节隐藏。虽然 目前的代码中，我们创建对象的过程并不复杂，但从代码设计角度来讲不易于扩展。现 在，我们用简单工厂模式对代码进行优化。先增加课程 PythonCourse 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PythonCourse</span> <span class="keyword">implements</span> <span class="title">ICourse</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">record</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"录制 Python 课程"</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 CourseFactory 工厂类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ICourse <span class="title">create</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"java"</span>.equals(name))&#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> JavaCourse();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"python"</span>.equals(name))&#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> PythonCourse();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改客户端调用代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactoryTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CourseFactory factory = <span class="keyword">new</span> CourseFactory();</span><br><span class="line">    factory.create(<span class="string">"java"</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，我们为了调用方便，可将 factory 的 create()改为静态方法，下面来看一下类图:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfxdbvlezsj30my0pi15c.jpg" alt="image-20200619100225030"></p>
<p>客户端调用是简单了，但如果我们业务继续扩展，要增加前端课程，那么工厂中的 create() 就要根据产品链的丰富每次都要修改代码逻辑。不符合开闭原则。因此，我们对简单工 厂还可以继续优化，可以采用反射技术:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ICourse <span class="title">create</span><span class="params">(String className)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(<span class="keyword">null</span> == className || <span class="string">""</span>.equals(className))) &#123;</span><br><span class="line">        <span class="keyword">return</span> (ICourse) Class.forName(className).newInstance(); </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123; </span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a><strong>工厂方法模式</strong></h2><p>工厂方法模式(Fatory Method Pattern)是指定义一个创建对象的接口，但让实现这个 接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。在工厂方法 模式中用户只需要关心所需产品对应的工厂，无须关心创建细节，而且加入新的产品符 合开闭原则。 </p>
<p>工厂方法模式主要解决产品扩展的问题，在简单工厂中，随着产品链的丰富，如果每个 课程的创建逻辑有区别的话，工厂的职责会变得越来越多，有点像万能工厂，并不便于 维护。根据单一职责原则我们将职能继续拆分，专人干专事。Java 课程由 Java 工厂创建， Python 课程由 Python 工厂创建，对工厂本身也做一个抽象。</p>
<p>工厂方法适用于以下场景:<br> 1、创建对象需要大量重复的代码。 2、客户端(应用层)不依赖于产品类实例如何被创建、实现等细节。 3、一个类通过其子类来指定创建哪个对象。<br> 工厂方法也有缺点:<br> 1、类的个数容易过多，增加复杂度。<br> 2、增加了系统的抽象性和理解难度。</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂模式(Abastract Factory Pattern)是指提供一个创建一系列相关或相互依赖对象的接口，无须指定他们具体的类。客户端(应用层)不依赖于产品类实例如何被创 建、实现等细节，强调的是一系列相关的产品对象(属于同一产品族)一起使用创建对 象需要大量重复的代码。需要提供一个产品类的库，所有的产品以同样的接口出现，从 而使客户端不依赖于具体实现。 讲解抽象工厂之前，我们要了解两个概念产品等级结构和产品族，看下面的图:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfyh36nnegj31300oi0wn.jpg" alt="image-20200620085759434"></p>
<p>从上图中看出有正方形，圆形和菱形三种图形，相同颜色深浅的就代表同一个产品族， 相同形状的代表同一个产品等级结构。同样可以从生活中来举例，比如，美的电器生产 多种家用电器。那么上图中，颜色最深的正方形就代表美的洗衣机、颜色最深的圆形代 表美的空调、颜色最深的菱形代表美的热水器，颜色最深的一排都属于美的品牌，都是 美的电器这个产品族。再看最右侧的菱形，颜色最深的我们指定了代表美的热水器，那 么第二排颜色稍微浅一点的菱形，代表海信的热水器。同理，同一产品结构下还有格力 热水器，格力空调，格力洗衣机。</p>
<p>再看下面的这张图，最左侧的小房子我们就认为具体的工厂，有美的工厂，有海信工厂， 有格力工厂。每个品牌的工厂都生产洗衣机、热水器和空调。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfyh4e565oj317e0neafx.jpg" alt="image-20200620085911334"></p>
<p>抽象工厂也是 有缺点的: </p>
<ol>
<li><p>规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂 的接口。</p>
</li>
<li><p>增加了系统的抽象性和理解难度。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>模仿spring-mvc</title>
    <url>/2020/06/17/%E6%A8%A1%E4%BB%BFspring-mvc/</url>
    <content><![CDATA[<h1 id="模仿spring-mvc"><a href="#模仿spring-mvc" class="headerlink" title="模仿spring-mvc"></a>模仿spring-mvc</h1><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfvnfa3619j31gm0tie81.jpg" alt="image-20200617222032762"></p>
<h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><h3 id="配置-application-properties-文件"><a href="#配置-application-properties-文件" class="headerlink" title="配置 application.properties 文件"></a>配置 application.properties 文件</h3><p>为了解析方便，我们用 application.properties 来代替 application.xml 文件，具体配置内容如下：</p>
<p>scanPackage=com.shoufeng.demo</p>
<h3 id="配置-web-xml-文件"><a href="#配置-web-xml-文件" class="headerlink" title="配置 web.xml 文件"></a>配置 web.xml 文件</h3><p>大家都知道，所有依赖于 web 容器的项目，都是从读取 web.xml 文件开始的。我们先配置好 web.xml 中的内容。 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">version</span>=<span class="string">"2.4"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>sf Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>sfmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.shoufeng.mvc.core.servlet.SFDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>application.properties<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>sfmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中 SFDispatcherServlet 是有自己模拟 Spring 实现的核心功能类。 </p>
<h3 id="自定义-Annotation"><a href="#自定义-Annotation" class="headerlink" title="自定义 Annotation"></a>自定义 Annotation</h3><h4 id="SFAutowired-注解："><a href="#SFAutowired-注解：" class="headerlink" title="@SFAutowired 注解："></a>@SFAutowired 注解：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoufeng.mvc.core.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shoufeng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SFAutowired &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SFController-注解："><a href="#SFController-注解：" class="headerlink" title="@SFController 注解："></a>@SFController 注解：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoufeng.mvc.core.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shoufeng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SFController &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SFRequestMapping-注解："><a href="#SFRequestMapping-注解：" class="headerlink" title="@SFRequestMapping 注解："></a>@SFRequestMapping 注解：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoufeng.mvc.core.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shoufeng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SFRequestMapping &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SFRequestParam-注解："><a href="#SFRequestParam-注解：" class="headerlink" title="@SFRequestParam 注解："></a>@SFRequestParam 注解：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoufeng.mvc.core.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shoufeng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.PARAMETER&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SFRequestParam &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SFService-注解："><a href="#SFService-注解：" class="headerlink" title="@SFService 注解："></a>@SFService 注解：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoufeng.mvc.core.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shoufeng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SFService &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="容器初始化"><a href="#容器初始化" class="headerlink" title="容器初始化"></a>容器初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoufeng.mvc.core.servlet;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.shoufeng.mvc.core.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shoufeng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SFDispatcherServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存application.properties配置文件中的内容</span></span><br><span class="line">    <span class="keyword">private</span> Properties contextConfig = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存扫描的所有的类名</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; classNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传说中的IOC容器，我们来揭开它的神秘面纱</span></span><br><span class="line">    <span class="comment">//为了简化程序，暂时不考虑ConcurrentHashMap</span></span><br><span class="line">    <span class="comment">// 主要还是关注设计思想和原理</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; ioc = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存url和Method的对应关系</span></span><br><span class="line"><span class="comment">//    private Map&lt;String,Method&gt; handlerMapping = new HashMap&lt;String,Method&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//思考：为什么不用Map</span></span><br><span class="line">    <span class="comment">//你用Map的话，key，只能是url</span></span><br><span class="line">    <span class="comment">//Handler 本身的功能就是把url和method对应关系，已经具备了Map的功能</span></span><br><span class="line">    <span class="comment">//根据设计原则：冗余的感觉了，单一职责，最少知道原则，帮助我们更好的理解</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Handler&gt; handlerMapping = <span class="keyword">new</span> ArrayList&lt;Handler&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6、调用，运行阶段</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doDispatch(req, resp);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            resp.getWriter().write(<span class="string">"500 Exection,Detail : "</span> + Arrays.toString(e.getStackTrace()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化阶段</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、加载配置文件</span></span><br><span class="line">        doLoadConfig(config.getInitParameter(<span class="string">"contextConfigLocation"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、扫描相关的类</span></span><br><span class="line">        doScanner(contextConfig.getProperty(<span class="string">"scanPackage"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、初始化扫描到的类，并且将它们放入到ICO容器之中</span></span><br><span class="line">        doInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、完成依赖注入</span></span><br><span class="line">        doAutowired();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5、初始化HandlerMapping</span></span><br><span class="line">        initHandlerMapping();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"SF Spring framework is init."</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Handler handler = getHandler(req);</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//        if(!this.handlerMapping.containsKey(url))&#123;</span></span><br><span class="line">            resp.getWriter().write(<span class="string">"404 Not Found!!!"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得方法的形参列表</span></span><br><span class="line">        Class&lt;?&gt;[] paramTypes = handler.getParamTypes();</span><br><span class="line"></span><br><span class="line">        Object[] paramValues = <span class="keyword">new</span> Object[paramTypes.length];</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String[]&gt; params = req.getParameterMap();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String[]&gt; parm : params.entrySet()) &#123;</span><br><span class="line">            String value = Arrays.toString(parm.getValue()).replaceAll(<span class="string">"\\[|\\]"</span>, <span class="string">""</span>)</span><br><span class="line">                    .replaceAll(<span class="string">"\\s"</span>, <span class="string">","</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!handler.paramIndexMapping.containsKey(parm.getKey())) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = handler.paramIndexMapping.get(parm.getKey());</span><br><span class="line">            paramValues[index] = convert(paramTypes[index], value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (handler.paramIndexMapping.containsKey(HttpServletRequest<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())) </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> reqIndex = handler.paramIndexMapping.get(HttpServletRequest<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">            paramValues[reqIndex] = req;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (handler.paramIndexMapping.containsKey(HttpServletResponse<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())) </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> respIndex = handler.paramIndexMapping.get(HttpServletResponse<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">            paramValues[respIndex] = resp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object returnValue = handler.method.invoke(handler.controller, paramValues);</span><br><span class="line">        <span class="keyword">if</span> (returnValue == <span class="keyword">null</span> || returnValue <span class="keyword">instanceof</span> Void) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        resp.getWriter().write(returnValue.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Handler <span class="title">getHandler</span><span class="params">(HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handlerMapping.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//绝对路径</span></span><br><span class="line">        String url = req.getRequestURI();</span><br><span class="line">        <span class="comment">//处理成相对路径</span></span><br><span class="line">        String contextPath = req.getContextPath();</span><br><span class="line">        url = url.replaceAll(contextPath, <span class="string">""</span>).replaceAll(<span class="string">"/+"</span>, <span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Handler handler : <span class="keyword">this</span>.handlerMapping) &#123;</span><br><span class="line">            Matcher matcher = handler.getPattern().matcher(url);</span><br><span class="line">            <span class="keyword">if</span> (!matcher.matches()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> handler;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//url传过来的参数都是String类型的，HTTP是基于字符串协议</span></span><br><span class="line">    <span class="comment">//只需要把String转换为任意类型就好</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">convert</span><span class="params">(Class&lt;?&gt; type, String value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果是int</span></span><br><span class="line">        <span class="keyword">if</span> (Integer<span class="class">.<span class="keyword">class</span> </span>== type) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.valueOf(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Double<span class="class">.<span class="keyword">class</span> </span>== type) &#123;</span><br><span class="line">            <span class="keyword">return</span> Double.valueOf(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果还有double或者其他类型，继续加if</span></span><br><span class="line">        <span class="comment">//这时候，我们应该想到策略模式了</span></span><br><span class="line">        <span class="comment">//在这里暂时不实现，希望小伙伴自己来实现</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化url和Method的一对一对应关系</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ioc.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : ioc.entrySet()) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = entry.getValue().getClass();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!clazz.isAnnotationPresent(SFController<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//保存写在类上面的@SFRequestMapping("/demo")</span></span><br><span class="line">            String baseUrl = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">if</span> (clazz.isAnnotationPresent(SFRequestMapping<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                SFRequestMapping requestMapping = clazz.getAnnotation(SFRequestMapping<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                baseUrl = requestMapping.value();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//默认获取所有的public方法</span></span><br><span class="line">            <span class="keyword">for</span> (Method method : clazz.getMethods()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!method.isAnnotationPresent(SFRequestMapping<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                SFRequestMapping requestMapping = method.getAnnotation(SFRequestMapping<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                <span class="comment">//优化</span></span><br><span class="line">                <span class="comment">// //demo///query</span></span><br><span class="line">                String regex = (<span class="string">"/"</span> + baseUrl + <span class="string">"/"</span> + requestMapping.value())</span><br><span class="line">                        .replaceAll(<span class="string">"/+"</span>, <span class="string">"/"</span>);</span><br><span class="line">                Pattern pattern = Pattern.compile(regex);</span><br><span class="line">                <span class="keyword">this</span>.handlerMapping.add(<span class="keyword">new</span> Handler(pattern, entry.getValue(), method));</span><br><span class="line"><span class="comment">//                handlerMapping.put(url,method);</span></span><br><span class="line">                System.out.println(<span class="string">"Mapped :"</span> + pattern + <span class="string">","</span> + method);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自动依赖注入</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAutowired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ioc.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : ioc.entrySet()) &#123;</span><br><span class="line">            <span class="comment">//Declared 所有的，特定的 字段，包括private/protected/default</span></span><br><span class="line">            <span class="comment">//正常来说，普通的OOP编程只能拿到public的属性</span></span><br><span class="line">            Field[] fields = entry.getValue().getClass().getDeclaredFields();</span><br><span class="line">            <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!field.isAnnotationPresent(SFAutowired<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                SFAutowired autowired = field.getAnnotation(SFAutowired<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果用户没有自定义beanName，默认就根据类型注入</span></span><br><span class="line">                <span class="comment">//这个地方省去了对类名首字母小写的情况的判断，这个作为课后作业</span></span><br><span class="line">                <span class="comment">//小伙伴们自己去完善</span></span><br><span class="line">                String beanName = autowired.value().trim();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">""</span>.equals(beanName)) &#123;</span><br><span class="line">                    <span class="comment">//获得接口的类型，作为key待会拿这个key到ioc容器中去取值</span></span><br><span class="line">                    beanName = field.getType().getName();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果是public以外的修饰符，只要加了@Autowired注解，都要强制赋值</span></span><br><span class="line">                <span class="comment">//反射中叫做暴力访问， 强吻</span></span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//用反射机制，动态给字段赋值</span></span><br><span class="line">                    field.set(entry.getValue(), ioc.get(beanName));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化，为DI做准备</span></span><br><span class="line">        <span class="keyword">if</span> (classNames.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (String className : classNames) &#123;</span><br><span class="line">                Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//什么样的类才需要初始化呢？</span></span><br><span class="line">                <span class="comment">//加了注解的类，才初始化，怎么判断？</span></span><br><span class="line">                <span class="comment">//为了简化代码逻辑，主要体会设计思想，只举例 @Controller和@Service,</span></span><br><span class="line">                <span class="comment">// @Componment...就一一举例了</span></span><br><span class="line">                <span class="keyword">if</span> (clazz.isAnnotationPresent(SFController<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                    Object instance = clazz.newInstance();</span><br><span class="line">                    <span class="comment">//Spring默认类名首字母小写</span></span><br><span class="line">                    String beanName = toLowerFirstCase(clazz.getSimpleName());</span><br><span class="line">                    ioc.put(beanName, instance);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz.isAnnotationPresent(SFService<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                    <span class="comment">//1、自定义的beanName</span></span><br><span class="line">                    SFService service = clazz.getAnnotation(SFService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                    String beanName = service.value();</span><br><span class="line">                    <span class="comment">//2、默认类名首字母小写</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">""</span>.equals(beanName.trim())) &#123;</span><br><span class="line">                        beanName = toLowerFirstCase(clazz.getSimpleName());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Object instance = clazz.newInstance();</span><br><span class="line">                    ioc.put(beanName, instance);</span><br><span class="line">                    <span class="comment">//3、根据类型自动赋值,投机取巧的方式</span></span><br><span class="line">                    <span class="keyword">for</span> (Class&lt;?&gt; i : clazz.getInterfaces()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (ioc.containsKey(i.getName())) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"The “"</span> + i.getName() + <span class="string">"” is exists!!"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//把接口的类型直接当成key了</span></span><br><span class="line">                        ioc.put(i.getName(), instance);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果类名本身是小写字母，确实会出问题</span></span><br><span class="line">    <span class="comment">//但是我要说明的是：这个方法是我自己用，private的</span></span><br><span class="line">    <span class="comment">//传值也是自己传，类也都遵循了驼峰命名法</span></span><br><span class="line">    <span class="comment">//默认传入的值，存在首字母小写的情况，也不可能出现非字母的情况</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了简化程序逻辑，就不做其他判断了，大家了解就OK</span></span><br><span class="line">    <span class="comment">//其实用写注释的时间都能够把逻辑写完了</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">toLowerFirstCase</span><span class="params">(String simpleName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = simpleName.toCharArray();</span><br><span class="line">        <span class="comment">//之所以加，是因为大小写字母的ASCII码相差32，</span></span><br><span class="line">        <span class="comment">// 而且大写字母的ASCII码要小于小写字母的ASCII码</span></span><br><span class="line">        <span class="comment">//在Java中，对char做算学运算，实际上就是对ASCII码做算学运算</span></span><br><span class="line">        chars[<span class="number">0</span>] += <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(chars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//扫描出相关的类</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doScanner</span><span class="params">(String scanPackage)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//scanPackage = com.gupaoedu.demo ，存储的是包路径</span></span><br><span class="line">        <span class="comment">//转换为文件路径，实际上就是把.替换为/就OK了</span></span><br><span class="line">        <span class="comment">//classpath</span></span><br><span class="line">        URL url = <span class="keyword">this</span>.getClass().getClassLoader().getResource(<span class="string">"/"</span> + scanPackage.replaceAll(<span class="string">"\\."</span>, <span class="string">"/"</span>));</span><br><span class="line">        File classPath = <span class="keyword">new</span> File(url.getFile());</span><br><span class="line">        <span class="keyword">for</span> (File file : classPath.listFiles()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                doScanner(scanPackage + <span class="string">"."</span> + file.getName());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!file.getName().endsWith(<span class="string">".class"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String className = (scanPackage + <span class="string">"."</span> + file.getName().replace(<span class="string">".class"</span>, <span class="string">""</span>));</span><br><span class="line">                classNames.add(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载配置文件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doLoadConfig</span><span class="params">(String contextConfigLocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//直接从类路径下找到Spring主配置文件所在的路径</span></span><br><span class="line">        <span class="comment">//并且将其读取出来放到Properties对象中</span></span><br><span class="line">        <span class="comment">//相对于scanPackage=com.gupaoedu.demo 从文件中保存到了内存中</span></span><br><span class="line">        InputStream fis = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(contextConfigLocation);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            contextConfig.load(fis);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != fis) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存一个url和一个Method的关系</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="comment">//必须把url放到HandlerMapping才好理解吧</span></span><br><span class="line">        <span class="keyword">private</span> Pattern pattern;  <span class="comment">//正则</span></span><br><span class="line">        <span class="keyword">private</span> Method method;</span><br><span class="line">        <span class="keyword">private</span> Object controller;</span><br><span class="line">        <span class="keyword">private</span> Class&lt;?&gt;[] paramTypes;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Pattern <span class="title">getPattern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pattern;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> method;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> controller;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt;[] getParamTypes() &#123;</span><br><span class="line">            <span class="keyword">return</span> paramTypes;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//形参列表</span></span><br><span class="line">        <span class="comment">//参数的名字作为key,参数的顺序，位置作为值</span></span><br><span class="line">        <span class="keyword">private</span> Map&lt;String, Integer&gt; paramIndexMapping;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Pattern pattern, Object controller, Method method)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.pattern = pattern;</span><br><span class="line">            <span class="keyword">this</span>.method = method;</span><br><span class="line">            <span class="keyword">this</span>.controller = controller;</span><br><span class="line"></span><br><span class="line">            paramTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">            paramIndexMapping = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">            putParamIndexMapping(method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putParamIndexMapping</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//提取方法中加了注解的参数</span></span><br><span class="line">            <span class="comment">//把方法上的注解拿到，得到的是一个二维数组</span></span><br><span class="line">            <span class="comment">//因为一个参数可以有多个注解，而一个方法又有多个参数</span></span><br><span class="line">            Annotation[][] pa = method.getParameterAnnotations();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pa.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Annotation a : pa[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a <span class="keyword">instanceof</span> SFRequestParam) &#123;</span><br><span class="line">                        String paramName = ((SFRequestParam) a).value();</span><br><span class="line">                        <span class="keyword">if</span> (!<span class="string">""</span>.equals(paramName.trim())) &#123;</span><br><span class="line">                            paramIndexMapping.put(paramName, i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//提取方法中的request和response参数</span></span><br><span class="line">            Class&lt;?&gt;[] paramsTypes = method.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paramsTypes.length; i++) &#123;</span><br><span class="line">                Class&lt;?&gt; type = paramsTypes[i];</span><br><span class="line">                <span class="keyword">if</span> (type == HttpServletRequest<span class="class">.<span class="keyword">class</span> ||</span></span><br><span class="line"><span class="class">                        <span class="title">type</span> </span>== HttpServletResponse<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    paramIndexMapping.put(type.getName(), i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行效果演示"><a href="#运行效果演示" class="headerlink" title="运行效果演示"></a>运行效果演示</h2><h3 id="启动tomcat"><a href="#启动tomcat" class="headerlink" title="启动tomcat"></a>启动tomcat</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfvog5hpifj31h50u0kbt.jpg" alt="image-20200617225559239"></p>
<h3 id="访问接口"><a href="#访问接口" class="headerlink" title="访问接口"></a>访问接口</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfvogof4xpj31j80to77l.jpg" alt="image-20200617225629999"></p>
]]></content>
      <categories>
        <category>spring源码解读</category>
      </categories>
      <tags>
        <tag>模仿spring-mvc</tag>
      </tags>
  </entry>
  <entry>
    <title>模版模式和适配器模式</title>
    <url>/2020/06/20/%E6%A8%A1%E7%89%88%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="模版模式和适配器模式"><a href="#模版模式和适配器模式" class="headerlink" title="模版模式和适配器模式"></a>模版模式和适配器模式</h1><h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><h3 id="模板模式的应用场景"><a href="#模板模式的应用场景" class="headerlink" title="模板模式的应用场景"></a><strong>模板模式的应用场景</strong></h3><p>我们平时办理入职流程填写入职登记表–&gt;打印简历–&gt;复印学历–&gt;复印身份证–&gt;签订 劳动合同–&gt;建立花名册–&gt;办理工牌–&gt;安排工位等;再比如，我平时在家里炒菜:洗锅 –&gt;点火–&gt;热锅–&gt;上油–&gt;下原料–&gt;翻炒–&gt;放调料–&gt;出锅;再比如赵本山问宋丹丹: “如何把大象放进冰箱?”宋丹丹回答:“第一步:打开冰箱门，第二步:把大象塞进 冰箱，第三步:关闭冰箱门”。赵本山再问:“怎么把长劲鹿放进冰箱?”宋丹丹答: “第一步:打开冰箱门，第二步:把大象拿出来，第三步:把长劲鹿塞进去，第四步: 关闭冰箱门”(如下图所示)，这些都是模板模式的体现。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfytv8jwxkj30yy0amgx0.jpg" alt="image-20200620162010032"></p>
<p>模板模式通常又叫模板方法模式(Template Method Pattern)是指定义一个算法的骨 架，并允许子类为一个或者多个步骤提供实现。模板方法使得子类可以在不改变算法结 构的情况下，重新定义算法的某些步骤，属于行为性设计模式。</p>
<p>模板方法适用于以下应 用场景:</p>
<ol>
<li><p>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。 </p>
</li>
<li><p>各子类中公共的行为被提取出来并集中到一个公共的父类中，从而避免代码重复。</p>
</li>
</ol>
<h3 id="模板模式在源码中的体现"><a href="#模板模式在源码中的体现" class="headerlink" title="模板模式在源码中的体现"></a><strong>模板模式在源码中的体现</strong></h3><p>先来看 JDK 中的 AbstractList，来看代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123; </span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到 get()是一个抽象方法，那么它的逻辑就是交给子类来实现，我们大家所熟知的 ArrayList 就是 AbstractList 的子类。同理，有 AbstractList 就有 AbstractSet 和 AbstractMap，有兴趣的小伙伴可以去看看这些的源码实现。还有一个每天都在用的 HttpServlet，有三个方法 service()和 doGet()、doPost()方法，都是模板方法的抽象实 现。</p>
<p>在 MyBatis 框架也有一些经典的应用，我们来一下 BaseExecutor 类，它是一个基础的 SQL 执行类，实现了大部分的 SQL 执行逻辑，然后把几个方法交给子类定制化完成，源 码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(BaseExecutor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Transaction transaction;</span><br><span class="line">  <span class="keyword">protected</span> Executor wrapper;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> ConcurrentLinkedQueue&lt;DeferredLoad&gt; deferredLoads;</span><br><span class="line">  <span class="keyword">protected</span> PerpetualCache localCache;</span><br><span class="line">  <span class="keyword">protected</span> PerpetualCache localOutputParameterCache;</span><br><span class="line">  <span class="keyword">protected</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> queryStack;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> closed;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">BaseExecutor</span><span class="params">(Configuration configuration, Transaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.transaction = transaction;</span><br><span class="line">    <span class="keyword">this</span>.deferredLoads = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">this</span>.localCache = <span class="keyword">new</span> PerpetualCache(<span class="string">"LocalCache"</span>);</span><br><span class="line">    <span class="keyword">this</span>.localOutputParameterCache = <span class="keyword">new</span> PerpetualCache(<span class="string">"LocalOutputParameterCache"</span>);</span><br><span class="line">    <span class="keyword">this</span>.closed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">    <span class="keyword">this</span>.wrapper = <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Transaction <span class="title">getTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> transaction;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">boolean</span> forceRollback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        rollback(forceRollback);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (transaction != <span class="keyword">null</span>) &#123;</span><br><span class="line">          transaction.close();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      <span class="comment">// Ignore.  There's nothing that can be done at this point.</span></span><br><span class="line">      log.warn(<span class="string">"Unexpected exception on closing transaction.  Cause: "</span> + e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      transaction = <span class="keyword">null</span>;</span><br><span class="line">      deferredLoads = <span class="keyword">null</span>;</span><br><span class="line">      localCache = <span class="keyword">null</span>;</span><br><span class="line">      localOutputParameterCache = <span class="keyword">null</span>;</span><br><span class="line">      closed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> closed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing an update"</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clearLocalCache();</span><br><span class="line">    <span class="keyword">return</span> doUpdate(ms, parameter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;BatchResult&gt; <span class="title">flushStatements</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> flushStatements(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;BatchResult&gt; <span class="title">flushStatements</span><span class="params">(<span class="keyword">boolean</span> isRollBack)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> doFlushStatements(isRollBack);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    BoundSql boundSql = ms.getBoundSql(parameter);</span><br><span class="line">    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">    <span class="keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing a query"</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      queryStack++;</span><br><span class="line">      list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      queryStack--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">        deferredLoad.load();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// issue #601</span></span><br><span class="line">      deferredLoads.clear();</span><br><span class="line">      <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">        <span class="comment">// issue #482</span></span><br><span class="line">        clearLocalCache();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">queryCursor</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    BoundSql boundSql = ms.getBoundSql(parameter);</span><br><span class="line">    <span class="keyword">return</span> doQueryCursor(ms, parameter, rowBounds, boundSql);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deferLoad</span><span class="params">(MappedStatement ms, MetaObject resultObject, String property, CacheKey key, Class&lt;?&gt; targetType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    DeferredLoad deferredLoad = <span class="keyword">new</span> DeferredLoad(resultObject, property, key, localCache, configuration, targetType);</span><br><span class="line">    <span class="keyword">if</span> (deferredLoad.canLoad()) &#123;</span><br><span class="line">      deferredLoad.load();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      deferredLoads.add(<span class="keyword">new</span> DeferredLoad(resultObject, property, key, localCache, configuration, targetType));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    CacheKey cacheKey = <span class="keyword">new</span> CacheKey();</span><br><span class="line">    cacheKey.update(ms.getId());</span><br><span class="line">    cacheKey.update(rowBounds.getOffset());</span><br><span class="line">    cacheKey.update(rowBounds.getLimit());</span><br><span class="line">    cacheKey.update(boundSql.getSql());</span><br><span class="line">    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">    TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">    <span class="comment">// mimic DefaultParameterHandler logic</span></span><br><span class="line">    <span class="keyword">for</span> (ParameterMapping parameterMapping : parameterMappings) &#123;</span><br><span class="line">      <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">        Object value;</span><br><span class="line">        String propertyName = parameterMapping.getProperty();</span><br><span class="line">        <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">          value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">          value = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">          value = parameterObject;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">          value = metaObject.getValue(propertyName);</span><br><span class="line">        &#125;</span><br><span class="line">        cacheKey.update(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configuration.getEnvironment() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// issue #176</span></span><br><span class="line">      cacheKey.update(configuration.getEnvironment().getId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheKey;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCached</span><span class="params">(MappedStatement ms, CacheKey key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> localCache.getObject(key) != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Cannot commit, transaction is already closed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clearLocalCache();</span><br><span class="line">    flushStatements();</span><br><span class="line">    <span class="keyword">if</span> (required) &#123;</span><br><span class="line">      transaction.commit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!closed) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        clearLocalCache();</span><br><span class="line">        flushStatements(<span class="keyword">true</span>);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (required) &#123;</span><br><span class="line">          transaction.rollback();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearLocalCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!closed) &#123;</span><br><span class="line">      localCache.clear();</span><br><span class="line">      localOutputParameterCache.clear();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;BatchResult&gt; <span class="title">doFlushStatements</span><span class="params">(<span class="keyword">boolean</span> isRollback)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">doQueryCursor</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">closeStatement</span><span class="params">(Statement statement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        statement.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Apply a transaction timeout.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> statement a current statement</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException if a database access error occurs, this method is called on a closed &lt;code&gt;Statement&lt;/code&gt;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 3.4.0</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span> StatementUtil#applyTransactionTimeout(Statement, Integer, Integer)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyTransactionTimeout</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    StatementUtil.applyTransactionTimeout(statement, statement.getQueryTimeout(), transaction.getTimeout());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLocallyCachedOutputParameters</span><span class="params">(MappedStatement ms, CacheKey key, Object parameter, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">      <span class="keyword">final</span> Object cachedParameter = localOutputParameterCache.getObject(key);</span><br><span class="line">      <span class="keyword">if</span> (cachedParameter != <span class="keyword">null</span> &amp;&amp; parameter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> MetaObject metaCachedParameter = configuration.newMetaObject(cachedParameter);</span><br><span class="line">        <span class="keyword">final</span> MetaObject metaParameter = configuration.newMetaObject(parameter);</span><br><span class="line">        <span class="keyword">for</span> (ParameterMapping parameterMapping : boundSql.getParameterMappings()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.IN) &#123;</span><br><span class="line">            <span class="keyword">final</span> String parameterName = parameterMapping.getProperty();</span><br><span class="line">            <span class="keyword">final</span> Object cachedValue = metaCachedParameter.getValue(parameterName);</span><br><span class="line">            metaParameter.setValue(parameterName, cachedValue);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      localCache.removeObject(key);</span><br><span class="line">    &#125;</span><br><span class="line">    localCache.putObject(key, list);</span><br><span class="line">    <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">      localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnection</span><span class="params">(Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Connection connection = transaction.getConnection();</span><br><span class="line">    <span class="keyword">if</span> (statementLog.isDebugEnabled()) &#123;</span><br><span class="line">      <span class="keyword">return</span> ConnectionLogger.newInstance(connection, statementLog, queryStack);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExecutorWrapper</span><span class="params">(Executor wrapper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.wrapper = wrapper;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeferredLoad</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MetaObject resultObject;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String property;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; targetType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CacheKey key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PerpetualCache localCache;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectFactory objectFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResultExtractor resultExtractor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// issue #781</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeferredLoad</span><span class="params">(MetaObject resultObject,</span></span></span><br><span class="line"><span class="function"><span class="params">                        String property,</span></span></span><br><span class="line"><span class="function"><span class="params">                        CacheKey key,</span></span></span><br><span class="line"><span class="function"><span class="params">                        PerpetualCache localCache,</span></span></span><br><span class="line"><span class="function"><span class="params">                        Configuration configuration,</span></span></span><br><span class="line"><span class="function"><span class="params">                        Class&lt;?&gt; targetType)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.resultObject = resultObject;</span><br><span class="line">      <span class="keyword">this</span>.property = property;</span><br><span class="line">      <span class="keyword">this</span>.key = key;</span><br><span class="line">      <span class="keyword">this</span>.localCache = localCache;</span><br><span class="line">      <span class="keyword">this</span>.objectFactory = configuration.getObjectFactory();</span><br><span class="line">      <span class="keyword">this</span>.resultExtractor = <span class="keyword">new</span> ResultExtractor(configuration, objectFactory);</span><br><span class="line">      <span class="keyword">this</span>.targetType = targetType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> localCache.getObject(key) != <span class="keyword">null</span> &amp;&amp; localCache.getObject(key) != EXECUTION_PLACEHOLDER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">      <span class="comment">// we suppose we get back a List</span></span><br><span class="line">      List&lt;Object&gt; list = (List&lt;Object&gt;) localCache.getObject(key);</span><br><span class="line">      Object value = resultExtractor.extractObjectFromList(list, targetType);</span><br><span class="line">      resultObject.setValue(property, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如 doUpdate、doFlushStatements、doQuery、doQueryCursor 这几个方法就是交 由子类来实现，那么 BaseExecutor 有哪些子类呢?我们来看一下它的类图:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfyu1tjsvvj30y80iygp8.jpg" alt="image-20200620162629411"></p>
<p>我们一起来看一下 SimpleExecutor 的 doUpdate 实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleExecutor</span> <span class="keyword">extends</span> <span class="title">BaseExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleExecutor</span><span class="params">(Configuration configuration, Transaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(configuration, transaction);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Configuration configuration = ms.getConfiguration();</span><br><span class="line">      StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>, ms, parameter, RowBounds.DEFAULT, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">      <span class="keyword">return</span> handler.update(stmt);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Configuration configuration = ms.getConfiguration();</span><br><span class="line">      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">      <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">doQueryCursor</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, <span class="keyword">null</span>, boundSql);</span><br><span class="line">    Statement stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    stmt.closeOnCompletion();</span><br><span class="line">    <span class="keyword">return</span> handler.queryCursor(stmt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;BatchResult&gt; <span class="title">doFlushStatements</span><span class="params">(<span class="keyword">boolean</span> isRollback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    Connection connection = getConnection(statementLog);</span><br><span class="line">    stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板模式的优缺点"><a href="#模板模式的优缺点" class="headerlink" title="模板模式的优缺点"></a><strong>模板模式的优缺点</strong></h3><p>优点: </p>
<ol>
<li><p>利用模板方法将相同处理逻辑的代码放到抽象父类中，可以提高代码的复用性。 </p>
</li>
<li><p>将不同的代码不同的子类中，通过对子类的扩展增加新的行为，提高代码的扩展性。 </p>
</li>
<li><p>把不变的行为写在父类上，去除子类的重复代码，提供了一个很好的代码复用平台， 符合开闭原则。</p>
</li>
</ol>
<p>缺点: </p>
<ol>
<li><p>类数目的增加，每一个抽象类都需要一个子类来实现，这样导致类的个数增加。 </p>
</li>
<li><p>类数量的增加，间接地增加了系统实现的复杂度。 </p>
</li>
<li><p>继承关系自身缺点，如果父类添加新的抽象方法，所有子类都要改一遍。 模板方法模式比较简单，相信小伙伴们肯定能学会，也肯定能理解好!只要勤加练习， 多结合业务场景思考问题，就能够把模板方法模式运用好。</p>
</li>
</ol>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="适配器模式的应用场景"><a href="#适配器模式的应用场景" class="headerlink" title="适配器模式的应用场景"></a><strong>适配器模式的应用场景</strong></h3><p>适配器模式(Adapter Pattern)是指将一个类的接口转换成客户期望的另一个接口，使 原本的接口不兼容的类可以一起工作，属于结构型设计模式。 适配器适用于以下几种业务场景:</p>
<ol>
<li><p>已经存在的类，它的方法和需求不匹配(方法结果相同或相似)的情况。 </p>
</li>
<li><p>适配器模式不是软件设计阶段考虑的设计模式，是随着软件维护，由于不同产品、不 同厂家造成功能类似而接口不相同情况下的解决方案。有点亡羊补牢的感觉。</p>
</li>
</ol>
<p>生活中也非常的应用场景，例如电源插转换头、手机充电转换头、显示器转接头。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfyu72foewj310w0d4461.jpg" alt="image-20200620163131421"></p>
<p>在中国民用电都是 220V 交流电，但我们手机使用的锂电池使用的 5V 直流电。因此，我 们给手机充电时就需要使用电源适配器来进行转换。</p>
<h3 id="适配器模式在源码中的体现"><a href="#适配器模式在源码中的体现" class="headerlink" title="适配器模式在源码中的体现"></a>适配器模式在源码中的体现</h3><p>Spring 中适配器模式也应用得非常广泛，例如:SpringAOP 中的 AdvisorAdapter 类， 它有三个实现类 MethodBeforeAdviceAdapter、AfterReturningAdviceAdapter 和 ThrowsAdviceAdapter，先来看顶层接口 AdvisorAdapter 的源代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AdvisorAdapter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看 MethodBeforeAdviceAdapter 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodBeforeAdviceAdapter</span> <span class="keyword">implements</span> <span class="title">AdvisorAdapter</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    MethodBeforeAdviceAdapter() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice advice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> advice <span class="keyword">instanceof</span> MethodBeforeAdvice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span> </span>&#123;</span><br><span class="line">        MethodBeforeAdvice advice = (MethodBeforeAdvice)advisor.getAdvice();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodBeforeAdviceInterceptor(advice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其它两个类我这里就不把代码贴出来了。Spring 会根据不同的 AOP 配置来确定使用对应的 Advice，跟策略模式不同的一个方法可以同时拥有多个 Advice。<br>下面再来看一个 SpringMVC 中的 HandlerAdapter 类，它也有多个子类，类图如下:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfyuaxwae2j313w08kjxu.jpg" alt="image-20200620163516095"></p>
<p>其适配调用的关键代码还是在 DispatcherServlet 的 doDispatch()方法中，下面我们还是来看源码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">            Object dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                processedRequest = <span class="keyword">this</span>.checkMultipart(request);</span><br><span class="line">                multipartRequestParsed = processedRequest != request;</span><br><span class="line">                mappedHandler = <span class="keyword">this</span>.getHandler(processedRequest);</span><br><span class="line">                <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.noHandlerFound(processedRequest, response);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                HandlerAdapter ha = <span class="keyword">this</span>.getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">                String method = request.getMethod();</span><br><span class="line">                <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">                <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">                    <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="keyword">new</span> ServletWebRequest(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.applyDefaultViewName(processedRequest, mv);</span><br><span class="line">                mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var20) &#123;</span><br><span class="line">                dispatchException = var20;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var21) &#123;</span><br><span class="line">                dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, var21);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var22) &#123;</span><br><span class="line">            <span class="keyword">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var23) &#123;</span><br><span class="line">            <span class="keyword">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, <span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, var23));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">            <span class="keyword">this</span>.cleanupMultipart(processedRequest);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 doDispatch()方法中调用了 getHandlerAdapter()方法，来看代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerAdapter <span class="title">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlerAdapters != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Iterator var2 = <span class="keyword">this</span>.handlerAdapters.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">            HandlerAdapter adapter = (HandlerAdapter)var2.next();</span><br><span class="line">            <span class="keyword">if</span> (adapter.supports(handler)) &#123;</span><br><span class="line">                <span class="keyword">return</span> adapter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"No adapter for handler ["</span> + handler + <span class="string">"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 getHandlerAdapter()方法中循环调用了 supports()方法判断是否兼容，循环迭代集 合中的 Adapter 又是在初始化时早已赋值。</p>
<h3 id="适配器模式的优缺点"><a href="#适配器模式的优缺点" class="headerlink" title="适配器模式的优缺点"></a><strong>适配器模式的优缺点</strong></h3><p>优点:<br> 1、能提高类的透明性和复用，现有的类复用但不需要改变。 2、目标类和适配器类解耦，提高程序的扩展性。 3、在很多业务场景中符合开闭原则。<br> 缺点:<br> 1、适配器编写过程需要全面考虑，可能会增加系统的复杂性。 2、增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰者模式和观察者模式</title>
    <url>/2020/06/20/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="装饰者模式和观察者模式"><a href="#装饰者模式和观察者模式" class="headerlink" title="装饰者模式和观察者模式"></a>装饰者模式和观察者模式</h1><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><h3 id="装饰者模式的应用场景"><a href="#装饰者模式的应用场景" class="headerlink" title="装饰者模式的应用场景"></a><strong>装饰者模式的应用场景</strong></h3><p>装饰者模式(Decorator Pattern)是指在不改变原有对象的基础之上，将功能附加到对 象上，提供了比继承更有弹性的替代方案(扩展原有对象的功能)，属于结构型模式。 装饰者模式在我们生活中应用也比较多如给煎饼加鸡蛋;给蛋糕加上一些水果;给房子 装修等，为对象扩展一些额外的职责。装饰者在代码程序中适用于以下场景: 1、用于扩展一个类的功能或给一个类添加附加职责。 2、动态的给一个对象添加功能，这些功能可以再动态的撤销。 来看一个这样的场景，上班族白领其实大多有睡懒觉的习惯，每天早上上班都是踩点，于是很多小伙伴为了多赖一会儿床都不吃早餐。那么，也有些小伙伴可能在上班路上碰 到卖煎饼的路边摊，都会顺带一个到公司茶水间吃早餐。卖煎饼的大姐可以给你的煎饼 加鸡蛋，也可以加香肠(如下图，PS:我买煎饼一般都要求不加生菜)。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfzma28e5kj31ik0j4npd.jpg" alt="image-20200621084310496"></p>
<p>下面我们用代码还原一下码农的生活。首先创建一个煎饼 Battercake 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Battercake</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">getMsg</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">"煎饼"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个加鸡蛋的煎饼 BattercakeWithEgg 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BattercakeWithEgg</span> <span class="keyword">extends</span> <span class="title">Battercake</span></span>&#123; </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getMsg() + <span class="string">"+1 个鸡蛋"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="comment">//加一个鸡蛋加 1 块钱 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getPrice() + <span class="number">1</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再创建一个既加鸡蛋又加香肠的 BattercakeWithEggAndSausage 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BattercakeWithEggAndSausage</span> <span class="keyword">extends</span> <span class="title">BattercakeWithEgg</span></span>&#123; </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">getMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getMsg() + <span class="string">"+1 根香肠"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="comment">//加一个香肠加 2 块钱 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getPrice() + <span class="number">2</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写客户端测试代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BattercakeTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Battercake battercake = <span class="keyword">new</span> Battercake(); </span><br><span class="line">    System.out.println(battercake.getMsg() + <span class="string">",总价格:"</span> + battercake.getPrice());</span><br><span class="line">    Battercake battercakeWithEgg = <span class="keyword">new</span> BattercakeWithEgg(); </span><br><span class="line">    System.out.println(battercakeWithEgg.getMsg() + <span class="string">",总价格:"</span> + battercakeWithEgg.getPrice());</span><br><span class="line">    Battercake battercakeWithEggAndSausage = <span class="keyword">new</span> BattercakeWithEggAndSausage();</span><br><span class="line">    System.out.println(battercakeWithEggAndSausage.getMsg() + <span class="string">",总价格:"</span> + battercakeWithEggAndSausage.getPrice());</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfzmhacdwij319a0bon4q.jpg" alt="image-20200621085001385"></p>
<p>运行结果没有问题。但是，如果用户需要一个加 2 个鸡蛋加 1 根香肠的煎饼，那么用我 们现在的类结构是创建不出来的，也无法自动计算出价格，除非再创建一个类做定制。 如果需求再变，一直加定制显然是不科学的。那么下面我们就用装饰者模式来解决上面 的问题。首先创建一个建煎饼的抽象 Battercake 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Battercake</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getMsg</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个基本的煎饼(或者叫基础套餐)BaseBattercake:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBattercake</span> <span class="keyword">extends</span> <span class="title">Battercake</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">getMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"煎饼"</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，再创建一个扩展套餐的抽象装饰者 BattercakeDecotator 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BattercakeDecorator</span> <span class="keyword">extends</span> <span class="title">Battercake</span> </span>&#123; </span><br><span class="line">  <span class="comment">//静态代理，委派</span></span><br><span class="line">  <span class="keyword">private</span> Battercake battercake;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BattercakeDecorator</span><span class="params">(Battercake battercake)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.battercake = battercake;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.battercake.getMsg();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.battercake.getPrice();</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，创建鸡蛋装饰者 EggDecorator 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EggDecorator</span> <span class="keyword">extends</span> <span class="title">BattercakeDecorator</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">EggDecorator</span><span class="params">(Battercake battercake)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(battercake);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getMsg() + <span class="string">"+1 个鸡蛋"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getPrice() + <span class="number">1</span>;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建香肠装饰者 SausageDecorator 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SausageDecorator</span> <span class="keyword">extends</span> <span class="title">BattercakeDecorator</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SausageDecorator</span><span class="params">(Battercake battercake)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(battercake);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getMsg() + <span class="string">"+1 根香肠"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getPrice() + <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写客户端测试代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BattercakeTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Battercake battercake;</span><br><span class="line">    <span class="comment">//路边摊买一个煎饼</span></span><br><span class="line">    battercake = <span class="keyword">new</span> BaseBattercake(); </span><br><span class="line">    <span class="comment">//煎饼有点小，想再加一个鸡蛋</span></span><br><span class="line">    battercake = <span class="keyword">new</span> EggDecorator(battercake); </span><br><span class="line">    <span class="comment">//再加一个鸡蛋</span></span><br><span class="line">    battercake = <span class="keyword">new</span> EggDecorator(battercake); </span><br><span class="line">    <span class="comment">//很饿，再加根香肠</span></span><br><span class="line">    battercake = <span class="keyword">new</span> SausageDecorator(battercake);</span><br><span class="line">    <span class="comment">//跟静态代理最大区别就是职责不同 </span></span><br><span class="line">    <span class="comment">//静态代理不一定要满足 is-a 的关系 </span></span><br><span class="line">    <span class="comment">//静态代理会做功能增强，同一个职责变得不一样</span></span><br><span class="line">    <span class="comment">//装饰器更多考虑是扩展</span></span><br><span class="line">    System.out.println(battercake.getMsg() + <span class="string">",总价:"</span> + battercake.getPrice()); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfzmohfl19j310006g41p.jpg" alt="image-20200621085704124"></p>
<p>来看一下类图:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfzmott6bwj31290u07ug.jpg" alt="image-20200621085723433"></p>
<h3 id="装饰者模式和适配器模式对比"><a href="#装饰者模式和适配器模式对比" class="headerlink" title="装饰者模式和适配器模式对比"></a><strong>装饰者模式和适配器模式对比</strong></h3><p>装饰者和适配器模式都是包装模式(Wrapper Pattern)，装饰者也是一种特殊的代理模式。</p>
<table>
<thead>
<tr>
<th></th>
<th>装饰者模式</th>
<th>适配器模式</th>
</tr>
</thead>
<tbody><tr>
<td>形式</td>
<td>是一种非常特别的适配器模式</td>
<td>没有层级关系，装饰器模式有层级关系</td>
</tr>
<tr>
<td>定义</td>
<td>装饰者和被装饰者都实现同一个接 口，主要目的是为了扩展之后依旧保 留 OOP 关系</td>
<td>适配器和被适配者没有必然的联系，通 常是采用继承或代理的形式进行包装</td>
</tr>
<tr>
<td>关系</td>
<td>满足 is-a 的关系</td>
<td>满足 has-a 的关系</td>
</tr>
<tr>
<td>功能</td>
<td>注重覆盖、扩展</td>
<td>注重兼容、转换</td>
</tr>
<tr>
<td>设计</td>
<td>前置考虑</td>
<td>后置考虑</td>
</tr>
</tbody></table>
<h3 id="装饰者模式在源码中的应用"><a href="#装饰者模式在源码中的应用" class="headerlink" title="装饰者模式在源码中的应用"></a>装饰者模式在源码中的应用</h3><p>装饰器模式在源码中也应用得非常多，在 JDK 中体现最明显的类就是 IO 相关的类，如 BufferedReader、InputStream、OutputStream，看一下常用的 InputStream 的类结 构图:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfzmw6ewvxj31e00qah43.jpg" alt="image-20200621090427697"></p>
<p>在 Spring 中的 TransactionAwareCacheDecorator 类我们也可以来尝试理解一下，这 个类主要是用来处理事务缓存的，来看一下代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAwareCacheDecorator</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Cache targetCache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TransactionAwareCacheDecorator</span><span class="params">(Cache targetCache)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(targetCache, <span class="string">"Target Cache must not be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.targetCache = targetCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cache <span class="title">getTargetCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.targetCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.targetCache.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getNativeCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.targetCache.getNativeCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ValueWrapper <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.targetCache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(Object key, @Nullable Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.targetCache.get(key, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(Object key, Callable&lt;T&gt; valueLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.targetCache.get(key, valueLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">final</span> Object key, @Nullable <span class="keyword">final</span> Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">            TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> TransactionSynchronizationAdapter() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    TransactionAwareCacheDecorator.<span class="keyword">this</span>.targetCache.put(key, value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.targetCache.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ValueWrapper <span class="title">putIfAbsent</span><span class="params">(Object key, @Nullable Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.targetCache.putIfAbsent(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evict</span><span class="params">(<span class="keyword">final</span> Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">            TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> TransactionSynchronizationAdapter() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    TransactionAwareCacheDecorator.<span class="keyword">this</span>.targetCache.evict(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.targetCache.evict(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">evictIfPresent</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.targetCache.evictIfPresent(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">            TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> TransactionSynchronizationAdapter() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    TransactionAwareCacheDecorator.<span class="keyword">this</span>.targetCache.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.targetCache.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">invalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.targetCache.invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TransactionAwareCacheDecorator 就是对 Cache 的一个包装。再来看一个 MVC 中的 装饰者模式 HttpHeadResponseDecorator 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpHeadResponseDecorator</span> <span class="keyword">extends</span> <span class="title">ServerHttpResponseDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HttpHeadResponseDecorator</span><span class="params">(ServerHttpResponse delegate)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(delegate);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Apply &#123;<span class="doctag">@link</span> Flux#reduce(Object, BiFunction) reduce&#125; on the body, count</span></span><br><span class="line"><span class="comment">    * the number of bytes produced, release data buffers without writing, and</span></span><br><span class="line"><span class="comment">    * set the &#123;<span class="doctag">@literal</span> Content-Length&#125; header.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Mono&lt;Void&gt; <span class="title">writeWith</span><span class="params">(Publisher&lt;? extends DataBuffer&gt; body)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Flux.from(body)</span><br><span class="line">            .reduce(<span class="number">0</span>, (current, buffer) -&gt; &#123;</span><br><span class="line">               <span class="keyword">int</span> next = current + buffer.readableByteCount();</span><br><span class="line">               DataBufferUtils.release(buffer);</span><br><span class="line">               <span class="keyword">return</span> next;</span><br><span class="line">            &#125;)</span><br><span class="line">            .doOnNext(length -&gt; &#123;</span><br><span class="line">               <span class="keyword">if</span> (length &gt; <span class="number">0</span> || getHeaders().getFirst(HttpHeaders.CONTENT_LENGTH) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  getHeaders().setContentLength(length);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .then();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Invoke &#123;<span class="doctag">@link</span> #setComplete()&#125; without writing.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;RFC 7302 allows HTTP HEAD response without content-length and it's not</span></span><br><span class="line"><span class="comment">    * something that can be computed on a streaming response.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Mono&lt;Void&gt; <span class="title">writeAndFlushWith</span><span class="params">(Publisher&lt;? extends Publisher&lt;? extends DataBuffer&gt;&gt; body)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Not feasible to count bytes on potentially streaming response.</span></span><br><span class="line">      <span class="comment">// RFC 7302 allows HEAD without content-length.</span></span><br><span class="line">      <span class="keyword">return</span> setComplete();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，看看 MyBatis 中的一段处理缓存的设计 org.apache.ibatis.cache.Cache 类，找 到它的包定位:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfzn3xs2bdj31bw0oqwkn.jpg" alt="image-20200621091155328"></p>
<p>从名字上来看其实更容易理解了。比如 FifoCache 先入先出算法的缓存;LruCache 最近 最少使用的缓存;TransactionlCache 事务相关的缓存，都是采用装饰者模式。MyBatis 源码在我们后续的课程也会深入讲解，感兴趣的小伙伴可以详细看看这块的源码，也可 以好好学习一下 MyBatis 的命名方式，今天我们还是把重点放到设计模式上。</p>
<h3 id="装饰者模式的优缺点"><a href="#装饰者模式的优缺点" class="headerlink" title="装饰者模式的优缺点"></a><strong>装饰者模式的优缺点</strong></h3><p>优点: </p>
<ol>
<li><p>装饰者是继承的有力补充，比继承灵活，不改变原有对象的情况下动态地给一个对象 扩展功能，即插即用。 </p>
</li>
<li><p>通过使用不同装饰类以及这些装饰类的排列组合，可以实现不同效果。</p>
</li>
<li><p>装饰者完全遵守开闭原则。</p>
</li>
</ol>
<p>缺点:</p>
<ol>
<li><p>会出现更多的代码，更多的类，增加程序复杂性。 </p>
</li>
<li><p>动态装饰时，多层装饰时会更复杂。 那么装饰者模式我们就讲解到这里，希望小伙伴们认真体会，加深理解。</p>
</li>
</ol>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h3 id="观察者模式的应用场景"><a href="#观察者模式的应用场景" class="headerlink" title="观察者模式的应用场景"></a><strong>观察者模式的应用场景</strong></h3><p>观察者模式(Observer Pattern)定义了对象之间的一对多依赖，让多个观察者对象同 时监听一个主体对象，当主体对象发生变化时，它的所有依赖者(观察者)都会收到通 知并更新，属于行为型模式。观察者模式有时也叫做发布订阅模式。观察者模式主要用 于在关联行为之间建立一套触发机制的场景。观察者模式在现实生活应用也非常广泛， 比如:微信朋友圈动态通知、邮件通知、广播通知、桌面程序的事件响应等(如下图)。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfzn9zx6yuj30nq0cu762.jpg" alt="image-20200621091744799"></p>
<h3 id="观察者模式在源码中的应用"><a href="#观察者模式在源码中的应用" class="headerlink" title="观察者模式在源码中的应用"></a>观察者模式在源码中的应用</h3><p>来看一下 Spring 中的 ContextLoaderListener 实现了 ServletContextListener 接口， ServletContextListener 接口又继承了 EventListener，在 JDK 中 EventListener 有非常 广泛的应用。我们可以看一下源代码，ContextLoaderListener:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoaderListener</span> <span class="keyword">extends</span> <span class="title">ContextLoader</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">(WebApplicationContext context)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(context);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">      initWebApplicationContext(event.getServletContext());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">      closeWebApplicationContext(event.getServletContext());</span><br><span class="line">      ContextCleanupListener.cleanupAttributes(event.getServletContext());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ServletContextListener:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletContextListener</span> <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EventListener:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于-Guava-API-轻松落地观察者模式"><a href="#基于-Guava-API-轻松落地观察者模式" class="headerlink" title="基于 Guava API 轻松落地观察者模式"></a><strong>基于 Guava API 轻松落地观察者模式</strong></h3><p>在这里，我还推荐给大家一个实现观察者模式非常好用的框架。API 使用也非常简单，举 个例子，先引入 maven 依赖包:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>20.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建侦听事件 GuavaEvent:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaEvent</span> </span>&#123; </span><br><span class="line">  <span class="meta">@Subscribe</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(String str)</span></span>&#123; </span><br><span class="line">    <span class="comment">//业务逻辑</span></span><br><span class="line">    System.out.println(<span class="string">"执行 subscribe 方法,传入的参数是:"</span> + str); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端测试代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaEventTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    EventBus eventbus = <span class="keyword">new</span> EventBus();</span><br><span class="line">    GuavaEvent guavaEvent = <span class="keyword">new</span> GuavaEvent(); </span><br><span class="line">    eventbus.register(guavaEvent); </span><br><span class="line">    eventbus.post(<span class="string">"Tom"</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="观察者模式的优缺点"><a href="#观察者模式的优缺点" class="headerlink" title="观察者模式的优缺点"></a><strong>观察者模式的优缺点</strong></h3><p>优点:</p>
<ol>
<li><p>观察者和被观察者之间建立了一个抽象的耦合。 </p>
</li>
<li><p>观察者模式支持广播通信。</p>
</li>
</ol>
<p>缺点: </p>
<ol>
<li><p>观察者之间有过多的细节依赖、提高时间消耗及程序的复杂度。 </p>
</li>
<li><p>使用要得当，要避免循环调用。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>软件架构设计的七大原则</title>
    <url>/2020/06/18/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="软件架构设计的七大原则"><a href="#软件架构设计的七大原则" class="headerlink" title="软件架构设计的七大原则"></a>软件架构设计的七大原则</h1><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>开闭原则（Open-Closed Principle, OCP）是指一个软件实体如类、模块和函数应该对 扩展开放，对修改关闭。所谓的开闭，也正是对扩展和修改两个行为的一个原则。强调的是用抽象构建框架，用实现扩展细节。可以提高软件系统的可复用性及可维护性。开闭原则，是面向对象设计中最基础的设计原则。它指导我们如何建立稳定灵活的系统，例如：我们版本更新，我尽可能不修改源代码，但是可以增加新功能。 </p>
<p>在现实生活中对于开闭原则也有体现。比如，很多互联网公司都实行弹性制作息时间，规定每天工作 8 小时。意思就是说，对于每天工作 8 小时这个规定是关闭的，但是你什 么时候来，什么时候走是开放的。早来早走，晚来晚走。 实现开闭原则的核心思想就是面向抽象编程，接下来我们来看一段代码：</p>
<p>以课程体系为例，首先创建一个课程接口 ICourse： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICourse</span> </span>&#123; </span><br><span class="line">  <span class="function">Integer <span class="title">getId</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function">String <span class="title">getName</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function">Double <span class="title">getPrice</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个课程生态有 Java 架构、大数据、人工智能、前端、软件测试等，我们来创建一个 Java 架构课程的类 JavaCourse：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaCourse</span> <span class="keyword">implements</span> <span class="title">ICourse</span></span>&#123; </span><br><span class="line">  <span class="keyword">private</span> Integer Id; </span><br><span class="line">  <span class="keyword">private</span> String name; </span><br><span class="line">  <span class="keyword">private</span> Double price; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JavaCourse</span><span class="params">(Integer id, String name, Double price)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.Id = id; <span class="keyword">this</span>.name = name; <span class="keyword">this</span>.price = price; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.Id; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Double <span class="title">getPrice</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.price; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们要给 Java 架构课程做活动，价格优惠。如果修改 JavaCourse 中的 getPrice() 方法，则会存在一定的风险，可能影响其他地方的调用结果。我们如何在不修改原有代 码前提前下，实现价格优惠这个功能呢？现在，我们再写一个处理优惠逻辑的JavaDiscountCourse 类 （ 思 考 一 下 为 什 么 要 叫 JavaDiscountCourse ， 而 不 叫 DiscountCourse）： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaDiscountCourse</span> <span class="keyword">extends</span> <span class="title">JavaCourse</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JavaDiscountCourse</span><span class="params">(Integer id, String name, Double price)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">super</span>(id, name, price); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Double <span class="title">getOriginPrice</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getPrice(); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Double <span class="title">getPrice</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getPrice() * <span class="number">0.61</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回顾一下，简单一下类结构图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfwkdvm3h7j30os0y2wtr.jpg" alt="image-20200618172057924"></p>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a><strong>依赖倒置原则</strong></h2><p>依赖倒置原则（Dependence Inversion Principle,DIP）是指设计代码结构时，高层模 块不应该依赖底层模块，二者都应该依赖其抽象。抽象不应该依赖细节；细节应该依赖 抽象。通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的 可读性和可维护性，并能够降低修改程序所造成的风险。接下来看一个案例，还是以课 程为例，先来创建一个类 Tom：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tom</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">studyJavaCourse</span><span class="params">()</span></span>&#123; </span><br><span class="line">    System.out.println(<span class="string">"Tom 在学习 Java 的课程"</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">studyPythonCourse</span><span class="params">()</span></span>&#123; </span><br><span class="line">    System.out.println(<span class="string">"Tom 在学习 Python 的课程"</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来调用一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">  Tom tom = <span class="keyword">new</span> Tom(); </span><br><span class="line">  tom.studyJavaCourse(); </span><br><span class="line">  tom.studyPythonCourse(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tom 热爱学习，目前正在学习 Java 课程和 Python 课程。大家都知道，学习也是会上瘾 的。随着学习兴趣的暴涨，现在 Tom 还想学习 AI 人工智能的课程。这个时候，业务扩展，我们的代码要从底层到高层（调用层）一次修改代码。在 Tom 类中增加 studyAICourse()的方法，在高层也要追加调用。如此一来，系统发布以后，实际上是非 常不稳定的，在修改代码的同时也会带来意想不到的风险。接下来我们优化代码，创建 一个课程的抽象 ICourse 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICourse</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后写 JavaCourse 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaCourse</span> <span class="keyword">implements</span> <span class="title">ICourse</span> </span>&#123; </span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    System.out.println(<span class="string">"Tom 在学习 Java 课程"</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再实现 PythonCourse 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">blic <span class="class"><span class="keyword">class</span> <span class="title">PythonCourse</span> <span class="keyword">implements</span> <span class="title">ICourse</span> </span>&#123; </span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    System.out.println(<span class="string">"Tom 在学习 Python 课程"</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改 Tom 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tom</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">(ICourse course)</span></span>&#123; </span><br><span class="line">    course.study(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">  Tom tom = <span class="keyword">new</span> Tom(); </span><br><span class="line">  tom.study(<span class="keyword">new</span> JavaCourse()); </span><br><span class="line">  tom.study(<span class="keyword">new</span> PythonCourse()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这时候再看来代码，Tom 的兴趣无论怎么暴涨，对于新的课程，我只需要新建一个 类，通过传参的方式告诉 Tom，而不需要修改底层代码。实际上这是一种大家非常熟悉 的方式，叫依赖注入。注入的方式还有构造器方式和 setter 方式。我们来看构造器注入 方式： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tom</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> ICourse course; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Tom</span><span class="params">(ICourse course)</span></span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.course = course; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123; </span><br><span class="line">    course.study(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看调用代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">  Tom tom = <span class="keyword">new</span> Tom(<span class="keyword">new</span> JavaCourse()); </span><br><span class="line">  tom.study(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据构造器方式注入，在调用时，每次都要创建实例。那么，如果 Tom 是全局单例，则我们就只能选择用 Setter 方式来注入，继续修改 Tom 类的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tom</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> ICourse course; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCourse</span><span class="params">(ICourse course)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.course = course; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">    course.study(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看调用代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">  Tom tom = <span class="keyword">new</span> Tom(); </span><br><span class="line">  tom.setCourse(<span class="keyword">new</span> JavaCourse()); </span><br><span class="line">  tom.study(); </span><br><span class="line">  tom.setCourse(<span class="keyword">new</span> PythonCourse()); </span><br><span class="line">  tom.study(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们再来看最终的类图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfwkmku4p5j31ew0o0qlr.jpg" alt="image-20200618172919462"></p>
<p>大家要切记：以抽象为基准比以细节为基准搭建起来的架构要稳定得多，因此大家在拿 到需求之后，要面向接口编程，先顶层再细节来设计代码结构。</p>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a><strong>单一职责原则</strong></h2><p>单一职责（Simple Responsibility Pinciple，SRP）是指不要存在多于一个导致类变更的原因。假设我们有一个 Class 负责两个职责，一旦发生需求变更，修改其中一个职责的逻辑代码，有可能会导致另一个职责的功能发生故障。这样一来，这个 Class 存在两个导 </p>
<p>致类变更的原因。如何解决这个问题呢？我们就要给两个职责分别用两个 Class 来实现，进行解耦。后期需求变更维护互不影响。这样的设计，可以降低类的复杂度，提高类的可读 性 ， 提 高 系 统 的 可 维 护 性 ， 降 低 变 更 引 起 的 风 险 。 总 体 来 说 就 是 一 个 Class/Interface/Method 只负责一项职责。接下来，我们来看代码实例，还是用课程举例，我们的课程有直播课和录播课。直播课不能快进和快退，录播可以可以任意的反复观看，功能职责不一样。还是先创建一个 Course 类： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">(String courseName)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"直播课"</span>.equals(courseName))&#123;</span><br><span class="line">      System.out.println(courseName + <span class="string">"不能快进"</span>); </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">      System.out.println(courseName + <span class="string">"可以反复回看"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看代码调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">  Course course = <span class="keyword">new</span> Course(); </span><br><span class="line">  course.study(<span class="string">"直播课"</span>); </span><br><span class="line">  course.study(<span class="string">"录播课"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码来看，Course 类承担了两种处理逻辑。假如，现在要对课程进行加密，那么 直播课和录播课的加密逻辑都不一样，必须要修改代码。而修改代码逻辑势必会相互影 s响容易造成不可控的风险。我们对职责进行分离解耦，来看代码，分别创建两个类ReplayCourse 和 LiveCourse： </p>
<p>LiveCourse 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveCourse</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">(String courseName)</span></span>&#123;</span><br><span class="line">    System.out.println(courseName + <span class="string">"不能快进看"</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReplayCourse 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplayCourse</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">(String courseName)</span></span>&#123; </span><br><span class="line">    System.out.println(courseName + <span class="string">"可以反复回"</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">  LiveCourse liveCourse = <span class="keyword">new</span> LiveCourse(); </span><br><span class="line">  liveCourse.study(<span class="string">"直播课"</span>); </span><br><span class="line">  ReplayCourse replayCourse = <span class="keyword">new</span> ReplayCourse(); replayCourse.study(<span class="string">"录播课"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>业务继续发展，课程要做权限。没有付费的学员可以获取课程基本信息，已经付费的学员可以获得视频流，即学习权限。那么对于控制课程层面上至少有两个职责。我们可以s把展示职责和管理职责分离开来，都实现同一个抽象依赖。设计一个顶层接口,创建 </p>
<p>ICourse 接口： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICourse</span> </span>&#123; </span><br><span class="line">  <span class="comment">//获得基本信息 </span></span><br><span class="line">  <span class="function">String <span class="title">getCourseName</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="comment">//获得视频流 </span></span><br><span class="line">  <span class="keyword">byte</span>[] getCourseVideo(); </span><br><span class="line">  <span class="comment">//学习课程 </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">studyCourse</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="comment">//退款 </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">refundCourse</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以把这个接口拆成两个接口，创建一个接口 ICourseInfo 和 ICourseManager： </p>
<p>ICourseInfo 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICourseInfo</span> </span>&#123; </span><br><span class="line">  <span class="function">String <span class="title">getCourseName</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">byte</span>[] getCourseVideo();                       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ICourseManager 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICourseManager</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">studyCourse</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">refundCourse</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看一下类图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfwkvjzbqcj31940i0tpr.jpg" alt="image-20200618173757300"></p>
<p>下面我们来看一下方法层面的单一职责设计。有时候，我们为了偷懒，通常会把一个方法写成下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">modifyUserInfo</span><span class="params">(String userName,String address)</span></span>&#123; </span><br><span class="line">  userName = <span class="string">"Tom"</span>; </span><br><span class="line">  address = <span class="string">"Changsha"</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可能写成这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">modifyUserInfo</span><span class="params">(String userName,String... fileds)</span></span>&#123; </span><br><span class="line">  userName = <span class="string">"Tom"</span>; </span><br><span class="line">  <span class="comment">// address = "Changsha"; </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">modifyUserInfo</span><span class="params">(String userName,String address,<span class="keyword">boolean</span> bool)</span></span>&#123; </span><br><span class="line">  <span class="keyword">if</span>(bool)&#123; </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  userName = <span class="string">"Tom"</span>; </span><br><span class="line">  address = <span class="string">"Changsha"</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，上面的 modifyUserInfo()方法中都承担了多个职责，既可以修改 userName,也可以修改 address，甚至更多，明显不符合单一职责。那么我们做如下修改，把这个方法拆 成两个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">modifyUserName</span><span class="params">(String userName)</span></span>&#123; </span><br><span class="line">  userName = <span class="string">"Tom"</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">modifyAddress</span><span class="params">(String address)</span></span>&#123; </span><br><span class="line">  address = <span class="string">"Changsha"</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这修改之后，开发起来简单，维护起来也容易。但是，我们在实际开发中会项目依赖，组合，聚合这些关系，还有还有项目的规模，周期，技术人员的水平，对进度的把控，很多类都不符合单一职责。但是，我们在编写代码的过程，尽可能地让接口和方法保持s单一职责，对我们项目后期的维护是有很大帮助的。 </p>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a><strong>接口隔离原则</strong></h2><p>接口隔离原则（Interface Segregation Principle, ISP）是指用多个专门的接口，而不使 用单一的总接口，客户端不应该依赖它不需要的接口。这个原则指导我们在设计接口时 应当注意一下几点： </p>
<ol>
<li><p>一个类对一类的依赖应该建立在最小的接口之上。 </p>
</li>
<li><p>建立单一接口，不要建立庞大臃肿的接口。 </p>
</li>
<li><p>尽量细化接口，接口中的方法尽量少（不是越少越好，一定要适度）。 </p>
</li>
</ol>
<p>接口隔离原则符合我们常说的高内聚低耦合的设计思想，从而使得类具有很好的可读性、 可扩展性和可维护性。我们在设计接口的时候，要多花时间去思考，要考虑业务模型， 包括以后有可能发生变更的地方还要做一些预判。所以，对于抽象，对业务模型的理解是非常重要的。下面我们来看一段代码，写一个动物行为的抽象： </p>
<p>IAnimal 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAnimal</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bird 类实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">implements</span> <span class="title">IAnimal</span> </span>&#123; </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dog 类实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">IAnimal</span> </span>&#123; </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，Bird 的 swim()方法可能只能空着，Dog 的 fly()方法显然不可能的。这时候，我们针对不同动物行为来设计不同的接口，分别设计 IEatAnimal，IFlyAnimal 和 ISwimAnimal 接口，来看代码： </p>
<p>IEatAnimal 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IEatAnimal</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IFlyAnimal 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFlyAnimal</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ISwimAnimal 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISwimAnimal</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;                        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dog 只实现 IEatAnimal 和 ISwimAnimal 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">ISwimAnimal</span>,<span class="title">IEatAnimal</span> </span>&#123; </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看下两种类图的对比，还是非常清晰明了的：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfwl5vy67bj31g80hqngn.jpg" alt="image-20200618174753127"></p>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a><strong>迪米特法则</strong></h2><p>迪米特原则（Law of Demeter LoD）是指一个对象应该对其他对象保持最少的了解，又叫最少知道原则（Least Knowledge Principle,LKP），尽量降低类与类之间的耦合。迪米特原则主要强调只和朋友交流，不和陌生人说话。出现在成员变量、方法的输入、输 出参数中的类都可以称之为成员朋友类，而出现在方法体内部的类不属于朋友类。 </p>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a><strong>里氏替换原则</strong></h2><p>里氏替换原则（Liskov Substitution Principle,LSP）是指如果对每一个类型为 T1 的对 </p>
<p>象 o1,都有类型为 T2 的对象 o2,使得以 T1 定义的所有程序 P 在所有的对象 o1 都替换成 </p>
<p>o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。 </p>
<p>定义看上去还是比较抽象，我们重新理解一下，可以理解为一个软件实体如果适用一个 </p>
<p>父类的话，那一定是适用于其子类，所有引用父类的地方必须能透明地使用其子类的对 </p>
<p>象，子类对象能够替换父类对象，而程序逻辑不变。根据这个理解，我们总结一下： </p>
<p>引申含义：子类可以扩展父类的功能，但不能改变父类原有的功能。 </p>
<ol>
<li><p>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 </p>
</li>
<li><p>子类中可以增加自己特有的方法。 </p>
</li>
<li><p>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入/入参）要比父类 方法的输入参数更宽松。 </p>
</li>
<li><p>当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即 方法的输出/返回值）要比父类更严格或相等。</p>
</li>
</ol>
<p>使用里氏替换原则有以下优点： </p>
<ol>
<li><p>约束继承泛滥，开闭原则的一种体现。 </p>
</li>
<li><p>加强程序的健壮性，同时变更时也可以做到非常好的兼容性，提高程序的维护性、扩展性。降低需求变更时引入的风险。 </p>
</li>
</ol>
<h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a><strong>合成复用原则</strong></h2><p>合成复用原则（Composite/Aggregate Reuse Principle,CARP）是指尽量使用对象组合(has-a)/聚合(contanis-a)，而不是继承关系达到软件复用的目的。可以使系统更加灵 活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。 继承我们叫做白箱复用，相当于把所有的实现细节暴露给子类。组合/聚合也称之为黑箱 复用，对类以外的对象是无法获取到实现细节的。要根据具体的业务场景来做代码设计，其实也都需要遵循 OOP 模型。</p>
<h2 id="经典框架都在用设计模式解决问题"><a href="#经典框架都在用设计模式解决问题" class="headerlink" title="经典框架都在用设计模式解决问题"></a><strong>经典框架都在用设计模式解决问题</strong></h2><p>Spring 就是一个把设计模式用得淋漓尽致的经典框架，其实从类的命名就能看出来，我来一一列举：</p>
<table>
<thead>
<tr>
<th>设计模式名称</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>工厂模式</td>
<td>BeanFactory</td>
</tr>
<tr>
<td>装饰器模式</td>
<td>BeanWrapper</td>
</tr>
<tr>
<td>代理模式</td>
<td>AopProxy</td>
</tr>
<tr>
<td>委派模式</td>
<td>DispatcherServlet</td>
</tr>
<tr>
<td>策略模式</td>
<td>HandlerMapping</td>
</tr>
<tr>
<td>适配器模式</td>
<td>HandlerAdapter</td>
</tr>
<tr>
<td>模板模式</td>
<td>JdbcTemplate</td>
</tr>
<tr>
<td>观察者模式</td>
<td>ContextLoaderListener</td>
</tr>
</tbody></table>
<p>需要特别声明的是，设计模式从来都不是单个设计模式独立使用的。在实际应用中，通 常是多个设计模式混合使用，你中有我，我中有你。我们的课程中，会围绕 Spring 的 IOC、 AOP、MVC、JDBC 这样的思路展开，根据其设计类型来设计讲解顺序:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>英文</th>
</tr>
</thead>
<tbody><tr>
<td>创建型模式</td>
<td>工厂模式</td>
<td>Factory Pattern</td>
</tr>
<tr>
<td></td>
<td>单例模式</td>
<td>Singleton Pattern</td>
</tr>
<tr>
<td></td>
<td>原型模式</td>
<td>Prototype Pattern</td>
</tr>
<tr>
<td>结构型模式</td>
<td>适配器模式</td>
<td>Adapter Pattern</td>
</tr>
<tr>
<td></td>
<td>装饰器模式</td>
<td>Decorator Pattern</td>
</tr>
<tr>
<td></td>
<td>代理模式</td>
<td>Proxy Pattern</td>
</tr>
<tr>
<td>行为性模式</td>
<td>策略模式</td>
<td>Strategy Pattern</td>
</tr>
<tr>
<td></td>
<td>模板模式</td>
<td>Template Pattern</td>
</tr>
<tr>
<td></td>
<td>委派模式</td>
<td>Delegate Pattern</td>
</tr>
<tr>
<td></td>
<td>观察者模式</td>
<td>Observer Pattern</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>轻量级锁</title>
    <url>/2020/06/18/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81/</url>
    <content><![CDATA[<h1 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h1><p>锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。</p>
<h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a><strong>锁升级</strong></h2><p>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。</p>
<p>“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>重量级锁（MutexLock）</title>
    <url>/2020/06/18/%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%88MutexLock%EF%BC%89/</url>
    <content><![CDATA[<h1 id="重量级锁（MutexLock）"><a href="#重量级锁（MutexLock）" class="headerlink" title="重量级锁（MutexLock）"></a>重量级锁（MutexLock）</h1><p>Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为“重量级锁”。JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>锁优化</title>
    <url>/2020/06/18/%E9%94%81%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h1><h2 id="减少锁持有时间"><a href="#减少锁持有时间" class="headerlink" title="减少锁持有时间"></a><strong>减少锁持有时间</strong></h2><p>只用在有线程安全要求的程序上加锁</p>
<h2 id="减小锁粒度"><a href="#减小锁粒度" class="headerlink" title="减小锁粒度"></a><strong>减小锁粒度</strong></h2><p>将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是ConcurrentHashMap。</p>
<h2 id="锁分离"><a href="#锁分离" class="headerlink" title="锁分离"></a><strong>锁分离</strong></h2><p>最常见的锁分离就是读写锁 ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能，具体也请查看[高并发 Java 五] JDK 并发包 1。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如LinkedBlockingQueue 从头部取出，从尾部放数据</p>
<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a><strong>锁粗化</strong></h2><p>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。</p>
<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a><strong>锁消除</strong></h2><p>锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作，多数是因为程序员编码不规范引起。</p>
<p>参考：<a href="https://www.jianshu.com/p/39628e1180a9" target="_blank" rel="noopener">https://www.jianshu.com/p/39628e1180a9</a></p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-ioc运行时序解析</title>
    <url>/2020/06/18/spring-ioc%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%8F%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="spring-ioc运行时序解析"><a href="#spring-ioc运行时序解析" class="headerlink" title="spring-ioc运行时序解析"></a>spring-ioc运行时序解析</h1><h2 id="Spring-核心之-IOC-容器初体验"><a href="#Spring-核心之-IOC-容器初体验" class="headerlink" title="Spring 核心之 IOC 容器初体验"></a>Spring 核心之 IOC 容器初体验</h2><h3 id="再谈-IOC-与-DI"><a href="#再谈-IOC-与-DI" class="headerlink" title="再谈 IOC 与 DI"></a><strong>再谈 IOC 与 DI</strong></h3><p><strong>IOC</strong>(Inversion of Control)控制反转：所谓控制反转，就是把原先我们代码里面需要实现的对象创 建、依赖的代码，反转给容器来帮忙实现。那么必然的我们需要创建一个容器，同时需要一种描述来让 容器知道需要创建的对象与对象的关系。这个描述最具体表现就是我们所看到的配置文件。 </p>
<p><strong>DI</strong>(Dependency Injection)依赖注入：就是指对象是被动接受依赖类而不是自己主动去找，换句话说就 是指对象不是从容器中查找它依赖的类，而是在容器实例化对象的时候主动将它依赖的类注入给它。</p>
<h3 id="Spring-核心容器类图"><a href="#Spring-核心容器类图" class="headerlink" title="Spring 核心容器类图"></a><strong>Spring 核心容器类图</strong></h3><h4 id="1、BeanFactory"><a href="#1、BeanFactory" class="headerlink" title="1、BeanFactory"></a><strong>1、BeanFactory</strong></h4><p>Spring Bean 的创建是典型的工厂模式，这一系列的 Bean 工厂，也即 IOC 容器为开发者管理对象间的依赖关系提供了很多便利和基础服务，在 Spring 中有许多的 IOC 容器的实现供用户选择和使用，其相互关系如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfw7h16t9ej317m0lg7ir.jpg" alt="image-20200618095413402"></p>
<p>其中 <strong>BeanFactory</strong> 作为<strong>最顶层</strong>的一个接口类，它定义了 IOC 容器的基本功能规范，BeanFactory 有三 个重要的子类：<strong>ListableBeanFactory</strong>、<strong>HierarchicalBeanFactory</strong> 和 <strong>AutowireCapableBeanFactory</strong>。 但是从类图中我们可以发现<strong>最终的默认实现类</strong>是 <strong>DefaultListableBeanFactory</strong>，它实现了所有的接口。</p>
<p>那为何要定义这么多层次的接口呢？查阅这些接口的源码和说明发现，每个接口都有它使用的场合，它主要是为了区分在 Spring 内部在操作过程中对象的传递和转化过程时，对对象的数据访问所做的限制。 </p>
<p><strong>ListableBeanFactory</strong> 接口：表示这些 <strong>Bean 是可列表化</strong></p>
<p><strong>HierarchicalBeanFactory</strong> 接口：表示的是 这些 Bean 是<strong>有继承关系</strong>的，也就是每个 Bean 有可能有父 Bean。</p>
<p><strong>AutowireCapableBeanFactory</strong> 接口：定义 Bean 的<strong>自动装配规则</strong>。</p>
<p>这三个接口共同定义了 Bean 的集合、Bean 之间的关系、以及 Bean 行 为。</p>
<p>最基本的 IOC 容器接口 BeanFactory，来看一下它的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2002-2017 the original author or authors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.ResolvableType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The root interface for accessing a Spring bean container.</span></span><br><span class="line"><span class="comment"> * This is the basic client view of a bean container;</span></span><br><span class="line"><span class="comment"> * further interfaces such as &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.config.ConfigurableBeanFactory&#125;</span></span><br><span class="line"><span class="comment"> * are available for specific purposes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \\&lt;p\&gt;This interface is implemented by objects that hold a number of bean definitions,</span></span><br><span class="line"><span class="comment"> * each uniquely identified by a String name. Depending on the bean definition,</span></span><br><span class="line"><span class="comment"> * the factory will return either an independent instance of a contained object</span></span><br><span class="line"><span class="comment"> * (the Prototype design pattern), or a single shared instance (a superior</span></span><br><span class="line"><span class="comment"> * alternative to the Singleton design pattern, in which the instance is a</span></span><br><span class="line"><span class="comment"> * singleton in the scope of the factory). Which type of instance will be returned</span></span><br><span class="line"><span class="comment"> * depends on the bean factory configuration: the API is the same. Since Spring</span></span><br><span class="line"><span class="comment"> * 2.0, further scopes are available depending on the concrete application</span></span><br><span class="line"><span class="comment"> * context (e.g. "request" and "session" scopes in a web environment).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \&lt;p\&gt;The point of this approach is that the BeanFactory is a central registry</span></span><br><span class="line"><span class="comment"> * of application components, and centralizes configuration of application</span></span><br><span class="line"><span class="comment"> * components (no more do individual objects need to read properties files,</span></span><br><span class="line"><span class="comment"> * for example). See chapters 4 and 11 of "Expert One-on-One J2EE Design and</span></span><br><span class="line"><span class="comment"> * Development" for a discussion of the benefits of this approach.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \&lt;p\&gt;Note that it is generally better to rely on Dependency Injection</span></span><br><span class="line"><span class="comment"> * ("push" configuration) to configure application objects through setters</span></span><br><span class="line"><span class="comment"> * or constructors, rather than use any form of "pull" configuration like a</span></span><br><span class="line"><span class="comment"> * BeanFactory lookup. Spring's Dependency Injection functionality is</span></span><br><span class="line"><span class="comment"> * implemented using this BeanFactory interface and its subinterfaces.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \&lt;p\&gt;Normally a BeanFactory will load bean definitions stored in a configuration</span></span><br><span class="line"><span class="comment"> * source (such as an XML document), and use the &#123;<span class="doctag">@code</span> org.springframework.beans&#125;</span></span><br><span class="line"><span class="comment"> * package to configure the beans. However, an implementation could simply return</span></span><br><span class="line"><span class="comment"> * Java objects it creates as necessary directly in Java code. There are no</span></span><br><span class="line"><span class="comment"> * constraints on how the definitions could be stored: LDAP, RDBMS, XML,</span></span><br><span class="line"><span class="comment"> * properties file, etc. Implementations are encouraged to support references</span></span><br><span class="line"><span class="comment"> * amongst beans (Dependency Injection).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \&lt;p\&gt;In contrast to the methods in &#123;<span class="doctag">@link</span> ListableBeanFactory&#125;, all of the</span></span><br><span class="line"><span class="comment"> * operations in this interface will also check parent factories if this is a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> HierarchicalBeanFactory&#125;. If a bean is not found in this factory instance,</span></span><br><span class="line"><span class="comment"> * the immediate parent factory will be asked. Beans in this factory instance</span></span><br><span class="line"><span class="comment"> * are supposed to override beans of the same name in any parent factory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \&lt;p\&gt;Bean factory implementations should support the standard bean lifecycle interfaces</span></span><br><span class="line"><span class="comment"> * as far as possible. The full set of initialization methods and their standard order is:</span></span><br><span class="line"><span class="comment"> * \&lt;ol\&gt;</span></span><br><span class="line"><span class="comment"> * \&lt;li\&gt;BeanNameAware's &#123;<span class="doctag">@code</span> setBeanName&#125;</span></span><br><span class="line"><span class="comment"> * \&lt;li\&gt;BeanClassLoaderAware's &#123;<span class="doctag">@code</span> setBeanClassLoader&#125;</span></span><br><span class="line"><span class="comment"> * \&lt;li\&gt;BeanFactoryAware's &#123;<span class="doctag">@code</span> setBeanFactory&#125;</span></span><br><span class="line"><span class="comment"> * \&lt;li\&gt;EnvironmentAware's &#123;<span class="doctag">@code</span> setEnvironment&#125;</span></span><br><span class="line"><span class="comment"> * \&lt;li\&gt;EmbeddedValueResolverAware's &#123;<span class="doctag">@code</span> setEmbeddedValueResolver&#125;</span></span><br><span class="line"><span class="comment"> * \&lt;li\&gt;ResourceLoaderAware's &#123;<span class="doctag">@code</span> setResourceLoader&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)</span></span><br><span class="line"><span class="comment"> * \&lt;li\&gt;ApplicationEventPublisherAware's &#123;<span class="doctag">@code</span> setApplicationEventPublisher&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)</span></span><br><span class="line"><span class="comment"> * \&lt;li\&gt;MessageSourceAware's &#123;<span class="doctag">@code</span> setMessageSource&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)</span></span><br><span class="line"><span class="comment"> * \&lt;li\&gt;ApplicationContextAware's &#123;<span class="doctag">@code</span> setApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)</span></span><br><span class="line"><span class="comment"> * \&lt;li\&gt;ServletContextAware's &#123;<span class="doctag">@code</span> setServletContext&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in a web application context)</span></span><br><span class="line"><span class="comment"> * \&lt;li\&gt;&#123;<span class="doctag">@code</span> postProcessBeforeInitialization&#125; methods of BeanPostProcessors</span></span><br><span class="line"><span class="comment"> * \&lt;li\&gt;InitializingBean's &#123;<span class="doctag">@code</span> afterPropertiesSet&#125;</span></span><br><span class="line"><span class="comment"> * \&lt;li\&gt;a custom init-method definition</span></span><br><span class="line"><span class="comment"> * \&lt;li\&gt;&#123;<span class="doctag">@code</span> postProcessAfterInitialization&#125; methods of BeanPostProcessors</span></span><br><span class="line"><span class="comment"> * \&lt;/ol\&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \&lt;p\&gt;On shutdown of a bean factory, the following lifecycle methods apply:</span></span><br><span class="line"><span class="comment"> * \&lt;ol\&gt;</span></span><br><span class="line"><span class="comment"> * \&lt;li\&gt;&#123;<span class="doctag">@code</span> postProcessBeforeDestruction&#125; methods of DestructionAwareBeanPostProcessors</span></span><br><span class="line"><span class="comment"> * \&lt;li\&gt;DisposableBean's &#123;<span class="doctag">@code</span> destroy&#125;</span></span><br><span class="line"><span class="comment"> * \&lt;li\&gt;a custom destroy-method definition</span></span><br><span class="line"><span class="comment"> * \&lt;/ol\&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Chris Beams</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 13 April 2001</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanNameAware#setBeanName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanClassLoaderAware#setBeanClassLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanFactoryAware#setBeanFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.ResourceLoaderAware#setResourceLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.ApplicationEventPublisherAware#setApplicationEventPublisher</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.MessageSourceAware#setMessageSource</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.ApplicationContextAware#setApplicationContext</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.context.ServletContextAware#setServletContext</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.config.BeanPostProcessor#postProcessBeforeInitialization</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> InitializingBean#afterPropertiesSet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.support.RootBeanDefinition#getInitMethodName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.config.BeanPostProcessor#postProcessAfterInitialization</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DisposableBean#destroy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.support.RootBeanDefinition#getDestroyMethodName</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//在BeanFactory里只对IOC容器的基本行为作了定义，根本不关心你的Bean是如何定义怎样加载的。</span></span><br><span class="line"><span class="comment">//正如我们只关心工厂里得到什么的产品对象，至于工厂是怎么生产这些对象的，这个基本的接口不关心。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Used to dereference a &#123;<span class="doctag">@link</span> FactoryBean&#125; instance and distinguish it from</span></span><br><span class="line"><span class="comment">    * beans \&lt;i\&gt;created\&lt;/i\&gt; by the FactoryBean. For example, if the bean named</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> myJndiObject&#125; is a FactoryBean, getting &#123;<span class="doctag">@code</span> &amp;myJndiObject&#125;</span></span><br><span class="line"><span class="comment">    * will return the factory, not the instance returned by the factory.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//对FactoryBean的转义定义，因为如果使用bean的名字检索FactoryBean得到的对象是工厂生成的对象，</span></span><br><span class="line">   <span class="comment">//如果需要得到工厂本身，需要转义</span></span><br><span class="line">   String FACTORY_BEAN_PREFIX = <span class="string">"&amp;"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;This method allows a Spring BeanFactory to be used as a replacement for the</span></span><br><span class="line"><span class="comment">    * Singleton or Prototype design pattern. Callers may retain references to</span></span><br><span class="line"><span class="comment">    * returned objects in the case of Singleton beans.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean definition</span></span><br><span class="line"><span class="comment">    * with the specified name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeansException if the bean could not be obtained</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//根据bean的名字，获取在IOC容器中得到bean实例</span></span><br><span class="line">   <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;Behaves the same as &#123;<span class="doctag">@link</span> #getBean(String)&#125;, but provides a measure of type</span></span><br><span class="line"><span class="comment">    * safety by throwing a BeanNotOfRequiredTypeException if the bean is not of the</span></span><br><span class="line"><span class="comment">    * required type. This means that ClassCastException can't be thrown on casting</span></span><br><span class="line"><span class="comment">    * the result correctly, as can happen with &#123;<span class="doctag">@link</span> #getBean(String)&#125;.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> requiredType type the bean must match. Can be an interface or superclass</span></span><br><span class="line"><span class="comment">    * of the actual class, or &#123;<span class="doctag">@code</span> null&#125; for any match. For example, if the value</span></span><br><span class="line"><span class="comment">    * is &#123;<span class="doctag">@code</span> Object.class&#125;, this method will succeed whatever the class of the</span></span><br><span class="line"><span class="comment">    * returned instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no such bean definition</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeanNotOfRequiredTypeException if the bean is not of the required type</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//根据bean的名字和Class类型来得到bean实例，增加了类型安全验证机制。</span></span><br><span class="line">   \&lt;T\&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, @Nullable Class\&lt;T\&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;Allows for specifying explicit constructor arguments / factory method arguments,</span></span><br><span class="line"><span class="comment">    * overriding the specified default arguments (if any) in the bean definition.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment">    * (only applied when creating a new instance as opposed to retrieving an existing one)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no such bean definition</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeanDefinitionStoreException if arguments have been given but</span></span><br><span class="line"><span class="comment">    * the affected bean isn't a prototype</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the bean instance that uniquely matches the given object type, if any.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;This method goes into &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; by-type lookup territory</span></span><br><span class="line"><span class="comment">    * but may also be translated into a conventional by-name lookup based on the name</span></span><br><span class="line"><span class="comment">    * of the given type. For more extensive retrieval operations across sets of beans,</span></span><br><span class="line"><span class="comment">    * use &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; and/or &#123;<span class="doctag">@link</span> BeanFactoryUtils&#125;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> requiredType type the bean must match; can be an interface or superclass.</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> null&#125; is disallowed.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> an instance of the single bean matching the required type</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if no bean of the given type was found</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoUniqueBeanDefinitionException if more than one bean of the given type was found</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> ListableBeanFactory</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   \&lt;T\&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class\&lt;T\&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;Allows for specifying explicit constructor arguments / factory method arguments,</span></span><br><span class="line"><span class="comment">    * overriding the specified default arguments (if any) in the bean definition.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;This method goes into &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; by-type lookup territory</span></span><br><span class="line"><span class="comment">    * but may also be translated into a conventional by-name lookup based on the name</span></span><br><span class="line"><span class="comment">    * of the given type. For more extensive retrieval operations across sets of beans,</span></span><br><span class="line"><span class="comment">    * use &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; and/or &#123;<span class="doctag">@link</span> BeanFactoryUtils&#125;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> requiredType type the bean must match; can be an interface or superclass.</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> null&#125; is disallowed.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment">    * (only applied when creating a new instance as opposed to retrieving an existing one)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no such bean definition</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeanDefinitionStoreException if arguments have been given but</span></span><br><span class="line"><span class="comment">    * the affected bean isn't a prototype</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 4.1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   \&lt;T\&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class\&lt;T\&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Does this bean factory contain a bean definition or externally registered singleton</span></span><br><span class="line"><span class="comment">    * instance with the given name?</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;If the given name is an alias, it will be translated back to the corresponding</span></span><br><span class="line"><span class="comment">    * canonical bean name.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;If this factory is hierarchical, will ask any parent factory if the bean cannot</span></span><br><span class="line"><span class="comment">    * be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;If a bean definition or singleton instance matching the given name is found,</span></span><br><span class="line"><span class="comment">    * this method will return &#123;<span class="doctag">@code</span> true&#125; whether the named bean definition is concrete</span></span><br><span class="line"><span class="comment">    * or abstract, lazy or eager, in scope or not. Therefore, note that a &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">    * return value from this method does not necessarily indicate that &#123;<span class="doctag">@link</span> #getBean&#125;</span></span><br><span class="line"><span class="comment">    * will be able to obtain an instance for the same name.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> whether a bean with the given name is present</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//提供对bean的检索，看看是否在IOC容器有这个名字的bean</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Is this bean a shared singleton? That is, will &#123;<span class="doctag">@link</span> #getBean&#125; always</span></span><br><span class="line"><span class="comment">    * return the same instance?</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;Note: This method returning &#123;<span class="doctag">@code</span> false&#125; does not clearly indicate</span></span><br><span class="line"><span class="comment">    * independent instances. It indicates non-singleton instances, which may correspond</span></span><br><span class="line"><span class="comment">    * to a scoped bean as well. Use the &#123;<span class="doctag">@link</span> #isPrototype&#125; operation to explicitly</span></span><br><span class="line"><span class="comment">    * check for independent instances.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> whether this bean corresponds to a singleton instance</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #isPrototype</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//根据bean名字得到bean实例，并同时判断这个bean是不是单例</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Is this bean a prototype? That is, will &#123;<span class="doctag">@link</span> #getBean&#125; always return</span></span><br><span class="line"><span class="comment">    * independent instances?</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;Note: This method returning &#123;<span class="doctag">@code</span> false&#125; does not clearly indicate</span></span><br><span class="line"><span class="comment">    * a singleton object. It indicates non-independent instances, which may correspond</span></span><br><span class="line"><span class="comment">    * to a scoped bean as well. Use the &#123;<span class="doctag">@link</span> #isSingleton&#125; operation to explicitly</span></span><br><span class="line"><span class="comment">    * check for a shared singleton instance.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> whether this bean will always deliver independent instances</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 2.0.3</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #isSingleton</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Check whether the bean with the given name matches the specified type.</span></span><br><span class="line"><span class="comment">    * More specifically, check whether a &#123;<span class="doctag">@link</span> #getBean&#125; call for the given name</span></span><br><span class="line"><span class="comment">    * would return an object that is assignable to the specified target type.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> typeToMatch the type to match against (as a &#123;<span class="doctag">@code</span> ResolvableType&#125;)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the bean type matches,</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> false&#125; if it doesn't match or cannot be determined yet</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getType</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Check whether the bean with the given name matches the specified type.</span></span><br><span class="line"><span class="comment">    * More specifically, check whether a &#123;<span class="doctag">@link</span> #getBean&#125; call for the given name</span></span><br><span class="line"><span class="comment">    * would return an object that is assignable to the specified target type.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> typeToMatch the type to match against (as a &#123;<span class="doctag">@code</span> Class&#125;)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the bean type matches,</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> false&#125; if it doesn't match or cannot be determined yet</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 2.0.1</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getType</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, @Nullable Class\&lt;?\&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Determine the type of the bean with the given name. More specifically,</span></span><br><span class="line"><span class="comment">    * determine the type of object that &#123;<span class="doctag">@link</span> #getBean&#125; would return for the given name.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;For a &#123;<span class="doctag">@link</span> FactoryBean&#125;, return the type of object that the FactoryBean creates,</span></span><br><span class="line"><span class="comment">    * as exposed by &#123;<span class="doctag">@link</span> FactoryBean#getObjectType()&#125;.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the type of the bean, or &#123;<span class="doctag">@code</span> null&#125; if not determinable</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 1.1.2</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #isTypeMatch</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//得到bean实例的Class类型</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   Class\&lt;?\&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the aliases for the given bean name, if any.</span></span><br><span class="line"><span class="comment">    * All of those aliases point to the same bean when used in a &#123;<span class="doctag">@link</span> #getBean&#125; call.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;If the given name is an alias, the corresponding original bean name</span></span><br><span class="line"><span class="comment">    * and other aliases (if any) will be returned, with the original bean name</span></span><br><span class="line"><span class="comment">    * being the first element in the array.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the bean name to check for aliases</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the aliases, or an empty array if none</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//得到bean的别名，如果根据别名检索，那么其原名也会被检索出来</span></span><br><span class="line">   String[] getAliases(String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 BeanFactory 里只对 IOC 容器的基本行为作了定义，根本不关心你的 Bean 是如何定义怎样加载的。 正如我们只关心工厂里得到什么的产品对象，至于工厂是怎么生产这些对象的，这个基本的接口不关心。 </p>
<p>而要知道工厂是如何产生对象的，我们需要看具体的 IOC 容器实现，Spring 提供了许多 <strong>IOC 容器</strong>的 实 现 。 比 如 <strong>GenericApplicationContext</strong> ， <strong>ClasspathXmlApplicationContext</strong> 等 。 </p>
<p><strong>ApplicationContext</strong> 是 Spring 提供的一个<strong>高级的 IOC 容器</strong>，它除了能够提供 IOC 容器的基本功能 外，还为用户提供了以下的附加服务。从 ApplicationContext 接口的实现，我们看出其特点： </p>
<ol>
<li><p>支持信息源，可以实现国际化。（实现 MessageSource 接口） </p>
</li>
<li><p>访问资源。(实现 ResourcePatternResolver 接口，后面章节会讲到) </p>
</li>
<li><p>支持应用事件。(实现 ApplicationEventPublisher 接口) </p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2002-2014 the original author or authors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.HierarchicalBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.ListableBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.AutowireCapableBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.EnvironmentCapable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.ResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Central interface to provide configuration for an application.</span></span><br><span class="line"><span class="comment"> * This is read-only while the application is running, but may be</span></span><br><span class="line"><span class="comment"> * reloaded if the implementation supports this.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \&lt;p\&gt;An ApplicationContext provides:</span></span><br><span class="line"><span class="comment"> * \&lt;ul\&gt;</span></span><br><span class="line"><span class="comment"> * \&lt;li\&gt;Bean factory methods for accessing application components.</span></span><br><span class="line"><span class="comment"> * Inherited from &#123;<span class="doctag">@link</span> org.springframework.beans.factory.ListableBeanFactory&#125;.</span></span><br><span class="line"><span class="comment"> * \&lt;li\&gt;The ability to load file resources in a generic fashion.</span></span><br><span class="line"><span class="comment"> * Inherited from the &#123;<span class="doctag">@link</span> org.springframework.core.io.ResourceLoader&#125; interface.</span></span><br><span class="line"><span class="comment"> * \&lt;li\&gt;The ability to publish events to registered listeners.</span></span><br><span class="line"><span class="comment"> * Inherited from the &#123;<span class="doctag">@link</span> ApplicationEventPublisher&#125; interface.</span></span><br><span class="line"><span class="comment"> * \&lt;li\&gt;The ability to resolve messages, supporting internationalization.</span></span><br><span class="line"><span class="comment"> * Inherited from the &#123;<span class="doctag">@link</span> MessageSource&#125; interface.</span></span><br><span class="line"><span class="comment"> * \&lt;li\&gt;Inheritance from a parent context. Definitions in a descendant context</span></span><br><span class="line"><span class="comment"> * will always take priority. This means, for example, that a single parent</span></span><br><span class="line"><span class="comment"> * context can be used by an entire web application, while each servlet has</span></span><br><span class="line"><span class="comment"> * its own child context that is independent of that of any other servlet.</span></span><br><span class="line"><span class="comment"> * \&lt;/ul\&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \&lt;p\&gt;In addition to standard &#123;<span class="doctag">@link</span> org.springframework.beans.factory.BeanFactory&#125;</span></span><br><span class="line"><span class="comment"> * lifecycle capabilities, ApplicationContext implementations detect and invoke</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ApplicationContextAware&#125; beans as well as &#123;<span class="doctag">@link</span> ResourceLoaderAware&#125;,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ApplicationEventPublisherAware&#125; and &#123;<span class="doctag">@link</span> MessageSourceAware&#125; beans.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurableApplicationContext</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.BeanFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.core.io.ResourceLoader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//ApplicationContext是Spring提供的一个高级的IOC容器，它除了能够提供IOC容器的基本功能外，还为用户提供了以下的附加服务。</span></span><br><span class="line"><span class="comment">//从ApplicationContext接口的实现，我们看出其特点：</span></span><br><span class="line"><span class="comment">//1、支持信息源，可以实现国际化。（实现 MessageSource 接口）</span></span><br><span class="line"><span class="comment">//2、访问资源。(实现 ResourcePatternResolver 接口，后面章节会讲到)</span></span><br><span class="line"><span class="comment">//3、支持应用事件。(实现 ApplicationEventPublisher 接口)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">EnvironmentCapable</span>, <span class="title">ListableBeanFactory</span>, <span class="title">HierarchicalBeanFactory</span>,</span></span><br><span class="line"><span class="class">      <span class="title">MessageSource</span>, <span class="title">ApplicationEventPublisher</span>, <span class="title">ResourcePatternResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the unique id of this application context.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the unique id of the context, or &#123;<span class="doctag">@code</span> null&#125; if none</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return a name for the deployed application that this context belongs to.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> a name for the deployed application, or the empty String by default</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">String <span class="title">getApplicationName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return a friendly name for this context.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> a display name for this context (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">String <span class="title">getDisplayName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the timestamp when this context was first loaded.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the timestamp (ms) when this context was first loaded</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">long</span> <span class="title">getStartupDate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the parent context, or &#123;<span class="doctag">@code</span> null&#125; if there is no parent</span></span><br><span class="line"><span class="comment">    * and this is the root of the context hierarchy.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the parent context, or &#123;<span class="doctag">@code</span> null&#125; if there is no parent</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">ApplicationContext <span class="title">getParent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Expose AutowireCapableBeanFactory functionality for this context.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;This is not typically used by application code, except for the purpose of</span></span><br><span class="line"><span class="comment">    * initializing bean instances that live outside of the application context,</span></span><br><span class="line"><span class="comment">    * applying the Spring bean lifecycle (fully or partly) to them.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;Alternatively, the internal BeanFactory exposed by the</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> ConfigurableApplicationContext&#125; interface offers access to the</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> AutowireCapableBeanFactory&#125; interface too. The present method mainly</span></span><br><span class="line"><span class="comment">    * serves as a convenient, specific facility on the ApplicationContext interface.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;\&lt;b\&gt;<span class="doctag">NOTE:</span> As of 4.2, this method will consistently throw IllegalStateException</span></span><br><span class="line"><span class="comment">    * after the application context has been closed.\&lt;/b\&gt; In current Spring Framework</span></span><br><span class="line"><span class="comment">    * versions, only refreshable application contexts behave that way; as of 4.2,</span></span><br><span class="line"><span class="comment">    * all application context implementations will be required to comply.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the AutowireCapableBeanFactory for this context</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalStateException if the context does not support the</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> AutowireCapableBeanFactory&#125; interface, or does not hold an</span></span><br><span class="line"><span class="comment">    * autowire-capable bean factory yet (e.g. if &#123;<span class="doctag">@code</span> refresh()&#125; has</span></span><br><span class="line"><span class="comment">    * never been called), or if the context has been closed already</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> ConfigurableApplicationContext#refresh()</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> ConfigurableApplicationContext#getBeanFactory()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">AutowireCapableBeanFactory <span class="title">getAutowireCapableBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、BeanDefinition"><a href="#2、BeanDefinition" class="headerlink" title="2、BeanDefinition"></a><strong>2、BeanDefinition</strong></h4><p>SpringIOC 容器管理了我们定义的各种 <strong>Bean 对象及其相互的关系</strong>，Bean 对象在 Spring 实现中是 以 <strong>BeanDefinition</strong> 来描述的，其继承体系如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfws7fsumcj310y0tg4c6.jpg" alt="image-20200618215133105"></p>
<h4 id="3、BeanDefinitionReader"><a href="#3、BeanDefinitionReader" class="headerlink" title="3、BeanDefinitionReader"></a><strong>3、BeanDefinitionReader</strong></h4><p>Bean 的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。Bean 的解析主要就是对 Spring 配置文件的解析。这个解析过程主要通过BeanDefintionReader 来完成，最后看看 Spring 中 BeanDefintionReader 的类结构图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfws8bzy5dj30te0hugst.jpg" alt="image-20200618215224546"></p>
<h2 id="基于-Xml-的-IOC-容器的初始化"><a href="#基于-Xml-的-IOC-容器的初始化" class="headerlink" title="基于 Xml 的 IOC 容器的初始化"></a>基于 Xml 的 IOC 容器的初始化</h2><p>IOC 容器的初始化包括 BeanDefinition 的 Resource 定位、加载和注册这三个基本的过程。我们以 ApplicationContext 为例讲解，ApplicationContext 系列容器也许是我们最熟悉的，因为 Web 项目中使用的 XmlWebApplicationContext 就属于这个继承体系，还有 ClasspathXmlApplicationContext 等，其继承体系如下图所示:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfxcc75e3jj31700u0qma.jpg" alt="image-20200619092807520"></p>
<p>ApplicationContext 允许上下文嵌套，通过保持父上下文可以维持一个上下文体系。对于 Bean 的查找 可以在这个上下文体系中发生，首先检查当前上下文，其次是父上下文，逐级向上，这样为不同的 Spring 应用提供了一个共享的 Bean 定义环境。</p>
<h3 id="1、寻找入口"><a href="#1、寻找入口" class="headerlink" title="1、寻找入口"></a><strong>1、寻找入口</strong></h3><p>还有一个我们用的比较多的 ClassPathXmlApplicationContext，通过 main()方法启动:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext app = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"application.xml"</span>);</span><br></pre></td></tr></table></figure>

<p>先看其构造函数的调用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> BeansException </span>&#123; </span><br><span class="line">  <span class="keyword">this</span>(<span class="keyword">new</span> String[]&#123;configLocation&#125;, <span class="keyword">true</span>, (ApplicationContext)<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实际调用的构造函数为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, @Nullable ApplicationContext parent)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(parent); </span><br><span class="line">  <span class="keyword">this</span>.setConfigLocations(configLocations); </span><br><span class="line">  <span class="keyword">if</span>(refresh) &#123;</span><br><span class="line">    <span class="keyword">this</span>.refresh(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还 有 像 AnnotationConfigApplicationContext 、 FileSystemXmlApplicationContext 、 XmlWebApplicationContext 等都继承自父容器 AbstractApplicationContext 主要用到了装饰器模式 和策略模式，最终都是调用 refresh()方法。</p>
<h3 id="2、获得配置路径"><a href="#2、获得配置路径" class="headerlink" title="2、获得配置路径"></a><strong>2、获得配置路径</strong></h3><p>通过分析 ClassPathXmlApplicationContext 的源代码可以知道，在创建 ClassPathXmlApplicationContext 容器时，构造方法做以下两项重要工作: 首先，调用父类容器的构造方法(super(parent)方法)为容器设置好 Bean 资源加载器。<br> 然 后 ， 再 调 用 父 类 AbstractRefreshableConfigApplicationContext 的 setConfigLocations(configLocations)方法设置 Bean 配置信息的定位路径。</p>
<p>通过追踪 ClassPathXmlApplicationContext 的继承体系，发现其父类的父类 AbstractApplicationContext 中初始化 IOC 容器所做的主要源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span> <span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span> </span>&#123;</span><br><span class="line">  <span class="comment">//静态初始化块，在整个容器创建过程中只执行一次 </span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">//为了避免应用程序在 Weblogic8.1 关闭时出现类加载异常加载问题，加载 IOC 容 </span></span><br><span class="line">    <span class="comment">//器关闭事件(ContextClosedEvent)类 </span></span><br><span class="line">    ContextClosedEvent<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.resourcePatternResolver = getResourcePatternResolver(); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">(@Nullable ApplicationContext parent)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    setParent(parent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取一个 Spring Source 的加载器用于读入 Spring Bean 配置信息 protected ResourcePatternResolver</span></span><br><span class="line">  getResourcePatternResolver() &#123;</span><br><span class="line">    <span class="comment">//AbstractApplicationContext 继承 DefaultResourceLoader，因此也是一个资源加载器 </span></span><br><span class="line">    <span class="comment">//Spring 资源加载器，其 getResource(String location)方法用于载入资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PathMatchingResourcePatternResolver(<span class="keyword">this</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractApplicationContext 的默认构造方法中有调用 PathMatchingResourcePatternResolver 的 构造方法创建 Spring 资源加载器:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PathMatchingResourcePatternResolver</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123; </span><br><span class="line">  Assert.notNull(resourceLoader, <span class="string">"ResourceLoader must not be null"</span>); </span><br><span class="line">  <span class="comment">//设置 Spring 的资源加载器</span></span><br><span class="line">  <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在设置容器的资源加载器之后，接下来 ClassPathXmlApplicationContext 执行 setConfigLocations() 方法通过调用其父类 AbstractRefreshableConfigApplicationContext 的方法进行对 Bean 配置信息的 定位，该方法的源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理单个资源文件路径为一个字符串的情况</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocation</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//String CONFIG_LOCATION_DELIMITERS = ",; /t/n";</span></span><br><span class="line">  <span class="comment">//即多个资源文件路径之间用” ,; \t\n”分隔，解析成数组形</span></span><br><span class="line">  setConfigLocations(StringUtils.tokenizeToStringArray(location, CONFIG_LOCATION_DELIMITERS));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析 Bean 定义资源文件的路径，处理多个资源文件字符串数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocations</span><span class="params">(@Nullable String... locations)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (locations != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Assert.noNullElements(locations, <span class="string">"Config locations must not be null"</span>); </span><br><span class="line">    <span class="keyword">this</span>.configLocations = <span class="keyword">new</span> String[locations.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i \&lt; locations.length; i++) &#123;</span><br><span class="line">      <span class="comment">// resolvePath 为同一个类中将字符串解析为路径的方法</span></span><br><span class="line">      <span class="keyword">this</span>.configLocations[i] = resolvePath(locations[i]).trim(); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.configLocations = <span class="keyword">null</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这两个方法的源码我们可以看出，我们既可以使用一个字符串来配置多个 Spring Bean 配置信息， 也可以使用字符串数组，即下面两种方式都是可以的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPathResource res = <span class="keyword">new</span> ClassPathResource(<span class="string">"a.xml,b.xml"</span>);</span><br></pre></td></tr></table></figure>

<p>多个资源文件路径之间可以是用” , ; \t\n”等分隔。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPathResource res =<span class="keyword">new</span> ClassPathResource(<span class="keyword">new</span> String[]&#123;<span class="string">"a.xml"</span>,<span class="string">"b.xml"</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>至此，SpringIOC 容器在初始化时将配置的 Bean 配置信息定位为 Spring 封装的 Resource。</p>
<h3 id="3、开始启动"><a href="#3、开始启动" class="headerlink" title="3、开始启动"></a><strong>3、开始启动</strong></h3><p>SpringIOC 容器对 Bean 配置资源的载入是从 refresh()函数开始的，refresh()是一个模板方法，规定了 IOC 容器的启动流程，有些逻辑要交给其子类去实现。它对 Bean 配置资源进行载入 ClassPathXmlApplicationContext 通过调用其父类 AbstractApplicationContext 的 refresh()函数启 动整个 IOC 容器对 Bean 定义的载入过程，现在我们来详细看看 refresh()中的逻辑处理:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">      <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">      <span class="comment">//1、调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">      <span class="comment">//2、告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从</span></span><br><span class="line">      <span class="comment">//子类的refreshBeanFactory()方法启动</span></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">      <span class="comment">//3、为BeanFactory配置容器特性，例如类加载器、事件处理器等</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">         <span class="comment">//4、为容器的某些子类指定特殊的BeanPost事件处理器</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">         <span class="comment">//5、调用所有注册的BeanFactoryPostProcessor的Bean</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">         <span class="comment">//6、为BeanFactory注册BeanPost事件处理器.</span></span><br><span class="line">         <span class="comment">//BeanPostProcessor是Bean后置处理器，用于监听容器触发的事件</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">         <span class="comment">//7、初始化信息源，和国际化相关.</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">         <span class="comment">//8、初始化容器事件传播器.</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">         <span class="comment">//9、调用子类的某些特殊Bean初始化方法</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">         <span class="comment">//10、为事件传播器注册事件监听器.</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">         <span class="comment">//11、初始化所有剩余的单例Bean</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">         <span class="comment">//12、初始化容器的生命周期事件处理器，并发布容器的生命周期事件</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                  <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         <span class="comment">//13、销毁已创建的Bean</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">         <span class="comment">//14、取消refresh操作，重置容器的同步标识。</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         <span class="comment">//15、重设公共缓存</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>refresh()方法主要为 IOC 容器 Bean 的生命周期管理提供条件，Spring IOC 容器载入 Bean 配置信息 从其子类容器的 refreshBeanFactory()方法启动，所以整个 refresh()中 “ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();”这句以后代码的 都是注册容器的信息源和生命周期事件，我们前面说的载入就是从这句代码开始启动。</p>
<p>refresh()方法的主要作用是:在创建 IOC 容器前，如果已经有容器存在，则需要把已有的容器销毁和 关闭，以保证在 refresh 之后使用的是新建立起来的 IOC 容器。它类似于对 IOC 容器的重启，在新建立 好的容器中对容器进行初始化，对 Bean 配置资源进行载入。</p>
<h3 id="4、创建容器"><a href="#4、创建容器" class="headerlink" title="4、创建容器"></a><strong>4、创建容器</strong></h3><p>obtainFreshBeanFactory()方法调用子类容器的 refreshBeanFactory()方法，启动容器载入 Bean 配置 信息的过程，代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the fresh BeanFactory instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refreshBeanFactory()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getBeanFactory()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这里使用了委派设计模式，父类定义了抽象的refreshBeanFactory()方法，具体实现调用子类容器的refreshBeanFactory()方法</span></span><br><span class="line">   refreshBeanFactory();</span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractApplicationContext 类中只抽象定义了 refreshBeanFactory()方法，容器真正调用的是 其子类AbstractRefreshableApplicationContext实现的refreshBeanFactory()方法，方法的源 码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This implementation performs an actual refresh of this context's underlying</span></span><br><span class="line"><span class="comment"> * bean factory, shutting down the previous bean factory (if any) and</span></span><br><span class="line"><span class="comment"> * initializing a fresh bean factory for the next phase of the context's lifecycle.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="comment">//如果已经有容器，销毁容器中的bean，关闭容器</span></span><br><span class="line">   <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">      destroyBeans();</span><br><span class="line">      closeBeanFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//创建IOC容器</span></span><br><span class="line">      DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">      beanFactory.setSerializationId(getId());</span><br><span class="line">      <span class="comment">//对IOC容器进行定制化，如设置启动参数，开启注解的自动装配等</span></span><br><span class="line">      customizeBeanFactory(beanFactory);</span><br><span class="line">      <span class="comment">//调用载入Bean定义的方法，主要这里又使用了一个委派模式，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器</span></span><br><span class="line">      loadBeanDefinitions(beanFactory);</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">         <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中，先判断 BeanFactory 是否存在，如果存在则先销毁 beans 并关闭 beanFactory，接着创建 DefaultListableBeanFactory，并调用 loadBeanDefinitions(beanFactory)装载 bean 定义。</p>
<h3 id="5、载入配置路径"><a href="#5、载入配置路径" class="headerlink" title="5、载入配置路径"></a><strong>5、载入配置路径</strong></h3><p>AbstractRefreshableApplicationContext 中只定义了抽象的 loadBeanDefinitions 方法，容器真正调 用的是其子类 AbstractXmlApplicationContext 对该方法的实现，AbstractXmlApplicationContext 的主要源码如下:<br>loadBeanDefinitions() 方 法 同 样 是 抽 象 方 法 ， 是 由 其 子 类 实 现 的 ， 也 即 在 AbstractXmlApplicationContext 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Loads the bean definitions via an XmlBeanDefinitionReader.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.xml.XmlBeanDefinitionReader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #initBeanDefinitionReader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #loadBeanDefinitions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//实现父类抽象的载入Bean定义方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">   <span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">   <span class="comment">//创建XmlBeanDefinitionReader，即创建Bean读取器，并通过回调设置到容器中去，容  器使用该读取器读取Bean定义资源</span></span><br><span class="line">   XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Configure the bean definition reader with this context's</span></span><br><span class="line">   <span class="comment">// resource loading environment.</span></span><br><span class="line">   <span class="comment">//为Bean读取器设置Spring资源加载器，AbstractXmlApplicationContext的</span></span><br><span class="line">   <span class="comment">//祖先父类AbstractApplicationContext继承DefaultResourceLoader，因此，容器本身也是一个资源加载器</span></span><br><span class="line">   beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">   beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">   <span class="comment">//为Bean读取器设置SAX xml解析器</span></span><br><span class="line">   beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">   <span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">   <span class="comment">//当Bean读取器读取Bean定义的Xml资源文件时，启用Xml的校验机制</span></span><br><span class="line">   initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">   <span class="comment">//Bean读取器真正实现加载的方法</span></span><br><span class="line">   loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the bean definition reader used for loading the bean</span></span><br><span class="line"><span class="comment"> * definitions of this context. Default implementation is empty.</span></span><br><span class="line"><span class="comment"> * \&lt;p\&gt;Can be overridden in subclasses, e.g. for turning off XML validation</span></span><br><span class="line"><span class="comment"> * or using a different XmlBeanDefinitionParser implementation.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> reader the bean definition reader used by this context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.xml.XmlBeanDefinitionReader#setDocumentReaderClass</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBeanDefinitionReader</span><span class="params">(XmlBeanDefinitionReader reader)</span> </span>&#123;</span><br><span class="line">   reader.setValidating(<span class="keyword">this</span>.validating);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the bean definitions with the given XmlBeanDefinitionReader.</span></span><br><span class="line"><span class="comment"> * \&lt;p\&gt;The lifecycle of the bean factory is handled by the &#123;<span class="doctag">@link</span> #refreshBeanFactory&#125;</span></span><br><span class="line"><span class="comment"> * method; hence this method is just supposed to load and/or register bean definitions.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> reader the XmlBeanDefinitionReader to use</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of bean registration errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException if the required XML document isn't found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refreshBeanFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getConfigLocations</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getResources</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getResourcePatternResolver</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//Xml Bean读取器加载Bean定义资源</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">   <span class="comment">//获取Bean定义资源的定位</span></span><br><span class="line">   Resource[] configResources = getConfigResources();</span><br><span class="line">   <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//Xml Bean读取器调用其父类AbstractBeanDefinitionReader读取定位</span></span><br><span class="line">      <span class="comment">//的Bean定义资源</span></span><br><span class="line">      reader.loadBeanDefinitions(configResources);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果子类中获取的Bean定义资源定位为空，则获取FileSystemXmlApplicationContext构造方法中setConfigLocations方法设置的资源</span></span><br><span class="line">   String[] configLocations = getConfigLocations();</span><br><span class="line">   <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//Xml Bean读取器调用其父类AbstractBeanDefinitionReader读取定位</span></span><br><span class="line">      <span class="comment">//的Bean定义资源</span></span><br><span class="line">      reader.loadBeanDefinitions(configLocations);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an array of Resource objects, referring to the XML bean definition</span></span><br><span class="line"><span class="comment"> * files that this context should be built with.</span></span><br><span class="line"><span class="comment"> * \&lt;p\&gt;The default implementation returns &#123;<span class="doctag">@code</span> null&#125;. Subclasses can override</span></span><br><span class="line"><span class="comment"> * this to provide pre-built Resource objects rather than location Strings.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an array of Resource objects, or &#123;<span class="doctag">@code</span> null&#125; if none</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getConfigLocations()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//这里又使用了一个委托模式，调用子类的获取Bean定义资源定位的方法</span></span><br><span class="line"><span class="comment">//该方法在ClassPathXmlApplicationContext中进行实现，对于我们</span></span><br><span class="line"><span class="comment">//举例分析源码的FileSystemXmlApplicationContext没有使用该方法</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Resource[] getConfigResources() &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以 XmlBean 读取器的其中一种策略 XmlBeanDefinitionReader 为例。XmlBeanDefinitionReader 调 用其父类AbstractBeanDefinitionReader的 reader.loadBeanDefinitions()方法读取Bean配置资源。 由于我们使用 ClassPathXmlApplicationContext 作为例子分析，因此 getConfigResources 的返回值 为 null，因此程序执行 reader.loadBeanDefinitions(configLocations)分支。</p>
<h3 id="6、分配路径处理策略"><a href="#6、分配路径处理策略" class="headerlink" title="6、分配路径处理策略"></a><strong>6、分配路径处理策略</strong></h3><p>在 XmlBeanDefinitionReader 的抽象父类 AbstractBeanDefinitionReader 中定义了载入过程。</p>
<p>AbstractBeanDefinitionReader 的 loadBeanDefinitions()方法源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">   Assert.notNull(resources, <span class="string">"Resource array must not be null"</span>);</span><br><span class="line">   <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">      counter += loadBeanDefinitions(resource);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载方法，调用下面的loadBeanDefinitions(String, Set\&lt;Resource\&gt;);方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> loadBeanDefinitions(location, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load bean definitions from the specified resource location.</span></span><br><span class="line"><span class="comment"> * \&lt;p\&gt;The location can also be a location pattern, provided that the</span></span><br><span class="line"><span class="comment"> * ResourceLoader of this bean definition reader is a ResourcePatternResolver.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> location the resource location, to be loaded with the ResourceLoader</span></span><br><span class="line"><span class="comment"> * (or ResourcePatternResolver) of this bean definition reader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> actualResources a Set to be filled with the actual Resource objects</span></span><br><span class="line"><span class="comment"> * that have been resolved during the loading process. May be &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * to indicate that the caller is not interested in those Resource objects.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getResourceLoader()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #loadBeanDefinitions(org.springframework.core.io.Resource)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #loadBeanDefinitions(org.springframework.core.io.Resource[])</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, @Nullable Set\&lt;Resource\&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">   <span class="comment">//获取在IoC容器初始化过程中设置的资源加载器</span></span><br><span class="line">   ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">   <span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">            <span class="string">"Cannot import bean definitions from location ["</span> + location + <span class="string">"]: no ResourceLoader available"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">      <span class="comment">// Resource pattern matching available.</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//将指定位置的Bean定义资源文件解析为Spring IOC容器封装的资源</span></span><br><span class="line">         <span class="comment">//加载多个指定位置的Bean定义资源文件</span></span><br><span class="line">         Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">         <span class="comment">//委派调用其子类XmlBeanDefinitionReader的方法，实现加载功能</span></span><br><span class="line">         <span class="keyword">int</span> loadCount = loadBeanDefinitions(resources);</span><br><span class="line">         <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">               actualResources.add(resource);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Loaded "</span> + loadCount + <span class="string">" bean definitions from location pattern ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> loadCount;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">               <span class="string">"Could not resolve bean definition resource pattern ["</span> + location + <span class="string">"]"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Can only load single resources by absolute URL.</span></span><br><span class="line">      <span class="comment">//将指定位置的Bean定义资源文件解析为Spring IOC容器封装的资源</span></span><br><span class="line">      <span class="comment">//加载单个指定位置的Bean定义资源文件</span></span><br><span class="line">      Resource resource = resourceLoader.getResource(location);</span><br><span class="line">      <span class="comment">//委派调用其子类XmlBeanDefinitionReader的方法，实现加载功能</span></span><br><span class="line">      <span class="keyword">int</span> loadCount = loadBeanDefinitions(resource);</span><br><span class="line">      <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">         actualResources.add(resource);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"Loaded "</span> + loadCount + <span class="string">" bean definitions from location ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> loadCount;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载方法，调用loadBeanDefinitions(String);</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">   Assert.notNull(locations, <span class="string">"Location array must not be null"</span>);</span><br><span class="line">   <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line">      counter += loadBeanDefinitions(location);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractRefreshableConfigApplicationContext 的 loadBeanDefinitions(Resource…resources) 方 法实际上是调用 AbstractBeanDefinitionReader 的 loadBeanDefinitions()方法。<br>从对 AbstractBeanDefinitionReader 的 loadBeanDefinitions()方法源码分析可以看出该方法就做了 两件事:</p>
<p>首先，调用资源加载器的获取资源方法 resourceLoader.getResource(location)，获取到要加载的资源。 其次，真正执行加载功能是其子类 XmlBeanDefinitionReader 的 loadBeanDefinitions()方法。在 loadBeanDefinitions()方法中调用了 AbstractApplicationContext 的 getResources()方法，跟进去之 后发现 getResources()方法其实定义在 ResourcePatternResolver 中，此时，我们有必要来看一下 ResourcePatternResolver 的全类图:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg06klftj0j30xg0u0as9.jpg" alt="image-20200621202516102"></p>
<p>从上面可以看到 ResourceLoader 与 ApplicationContext 的继承关系，可以看出其实际调用的是 DefaultResourceLoader 中 的 getSource() 方 法 定 位 Resource ， 因 为 ClassPathXmlApplicationContext 本身就是 DefaultResourceLoader 的实现类，所以此时又回到了 ClassPathXmlApplicationContext 中来。</p>
<h3 id="7、解析配置文件路径"><a href="#7、解析配置文件路径" class="headerlink" title="7、解析配置文件路径"></a><strong>7、解析配置文件路径</strong></h3><p>XmlBeanDefinitionReader 通 过 调 用 ClassPathXmlApplicationContext 的父类DefaultResourceLoader 的 getResource()方法获取要加载的资源，其源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Resource的具体实现方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">   Assert.notNull(location, <span class="string">"Location must not be null"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (ProtocolResolver protocolResolver : <span class="keyword">this</span>.protocolResolvers) &#123;</span><br><span class="line">      Resource resource = protocolResolver.resolve(location, <span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> resource;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果是类路径的方式，那需要使用ClassPathResource 来得到bean 文件的资源对象</span></span><br><span class="line">   <span class="keyword">if</span> (location.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Try to parse the location as a URL...</span></span><br><span class="line">         <span class="comment">// 如果是URL 方式，使用UrlResource 作为bean 文件的资源对象</span></span><br><span class="line">         URL url = <span class="keyword">new</span> URL(location);</span><br><span class="line">         <span class="keyword">return</span> (ResourceUtils.isFileURL(url) ? <span class="keyword">new</span> FileUrlResource(url) : <span class="keyword">new</span> UrlResource(url));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line">         <span class="comment">// No URL -\&gt; resolve as resource path.</span></span><br><span class="line">         <span class="comment">//如果既不是classpath标识，又不是URL标识的Resource定位，则调用</span></span><br><span class="line">         <span class="comment">//容器本身的getResourceByPath方法获取Resource</span></span><br><span class="line">         <span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DefaultResourceLoader 提供了 getResourceByPath()方法的实现，就是为了处理既不是 classpath 标识，又不是 URL 标识的 Resource 定位这种情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Resource <span class="title">getResourceByPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ClassPathContextResource(path, getClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ClassPathResource 中完成了对整个路径的解析。这样，就可以从类路径上对 IOC 配置文件进行加 载，当然我们可以按照这个逻辑从任何地方加载，在 Spring 中我们看到它提供的各种资源抽象，比如 ClassPathResource、URLResource、FileSystemResource 等来供我们使用。上面我们看到的是定位Resource 的一个过程，而这只是加载过程的一部分。例如 FileSystemXmlApplication 容器就重写了 getResourceByPath()方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resolve resource paths as file system paths.</span></span><br><span class="line"><span class="comment"> * \&lt;p\&gt;Note: Even if a given path starts with a slash, it will get</span></span><br><span class="line"><span class="comment"> * interpreted as relative to the current VM working directory.</span></span><br><span class="line"><span class="comment"> * This is consistent with the semantics in a Servlet container.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path path to the resource</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Resource handle</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.context.support.XmlWebApplicationContext#getResourceByPath</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Resource <span class="title">getResourceByPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (path.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">      path = path.substring(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//这里使用文件系统资源对象来定义bean 文件</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> FileSystemResource(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过子类的覆盖，巧妙地完成了将类路径变为文件路径的转换。</p>
<h3 id="8、开始读取配置内容"><a href="#8、开始读取配置内容" class="headerlink" title="8、开始读取配置内容"></a><strong>8、开始读取配置内容</strong></h3><p>继续回到 XmlBeanDefinitionReader 的 loadBeanDefinitions(Resource …)方法看到代表 bean 文件 的资源定义以后的载入过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load bean definitions from the specified XML file.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource the resource descriptor for the XML file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//XmlBeanDefinitionReader加载资源的入口方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">   <span class="comment">//将读入的XML资源进行特殊编码处理</span></span><br><span class="line">   <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load bean definitions from the specified XML file.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> encodedResource the resource descriptor for the XML file,</span></span><br><span class="line"><span class="comment"> * allowing to specify an encoding to use for parsing the file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//这里是载入XML形式Bean定义资源文件方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">   Assert.notNull(encodedResource, <span class="string">"EncodedResource must not be null"</span>);</span><br><span class="line">   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(<span class="string">"Loading XML bean definitions from "</span> + encodedResource.getResource());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Set\&lt;EncodedResource\&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">   <span class="keyword">if</span> (currentResources == <span class="keyword">null</span>) &#123;</span><br><span class="line">      currentResources = <span class="keyword">new</span> HashSet\&lt;\&gt;(<span class="number">4</span>);</span><br><span class="line">      <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">            <span class="string">"Detected cyclic loading of "</span> + encodedResource + <span class="string">" - check your import definitions!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//将资源文件转为InputStream的IO流</span></span><br><span class="line">      InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//从InputStream中得到XML的解析源</span></span><br><span class="line">         InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">         <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//这里是具体的读取过程</span></span><br><span class="line">         <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">//关闭从Resource中得到的IO流</span></span><br><span class="line">         inputStream.close();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">            <span class="string">"IOException parsing XML document from "</span> + encodedResource.getResource(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      currentResources.remove(encodedResource);</span><br><span class="line">      <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">         <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load bean definitions from the specified XML file.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputSource the SAX InputSource to read from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(InputSource inputSource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> loadBeanDefinitions(inputSource, <span class="string">"resource loaded through SAX InputSource"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load bean definitions from the specified XML file.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputSource the SAX InputSource to read from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resourceDescription a description of the resource</span></span><br><span class="line"><span class="comment"> * (can be &#123;<span class="doctag">@code</span> null&#125; or empty)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(InputSource inputSource, @Nullable String resourceDescription)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, <span class="keyword">new</span> DescriptiveResource(resourceDescription));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Actually load bean definitions from the specified XML file.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputSource the SAX InputSource to read from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource the resource descriptor for the XML file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doLoadDocument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #registerBeanDefinitions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//从特定XML文件中实际载入Bean定义资源的方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//将XML文件转换为DOM对象，解析过程由documentLoader实现</span></span><br><span class="line">      Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">      <span class="comment">//这里是启动对Bean定义解析的详细过程，该解析过程会用到Spring的Bean配置规则</span></span><br><span class="line">      <span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (SAXParseException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">            <span class="string">"Line "</span> + ex.getLineNumber() + <span class="string">" in XML document from "</span> + resource + <span class="string">" is invalid"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (SAXException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">            <span class="string">"XML document from "</span> + resource + <span class="string">" is invalid"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ParserConfigurationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">            <span class="string">"Parser configuration exception parsing XML from "</span> + resource, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">            <span class="string">"IOException parsing XML document from "</span> + resource, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">            <span class="string">"Unexpected exception parsing XML document from "</span> + resource, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过源码分析，载入 Bean 配置信息的最后一步是将 Bean 配置信息转换为 Document 对象，该过程由documentLoader()方法实现。</p>
<h3 id="9、准备文档对象"><a href="#9、准备文档对象" class="headerlink" title="9、准备文档对象"></a><strong>9、准备文档对象</strong></h3><p>DocumentLoader 将 Bean 配置资源转换成 Document 对象的源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the &#123;<span class="doctag">@link</span> Document&#125; at the supplied &#123;<span class="doctag">@link</span> InputSource&#125; using the standard JAXP-configured</span></span><br><span class="line"><span class="comment"> * XML parser.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//使用标准的JAXP将载入的Bean定义资源转换成document对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Document <span class="title">loadDocument</span><span class="params">(InputSource inputSource, EntityResolver entityResolver,</span></span></span><br><span class="line"><span class="function"><span class="params">      ErrorHandler errorHandler, <span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建文件解析器工厂</span></span><br><span class="line">   DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Using JAXP provider ["</span> + factory.getClass().getName() + <span class="string">"]"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//创建文档解析器</span></span><br><span class="line">   DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);</span><br><span class="line">   <span class="comment">//解析Spring的Bean定义资源</span></span><br><span class="line">   <span class="keyword">return</span> builder.parse(inputSource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create the &#123;<span class="doctag">@link</span> DocumentBuilderFactory&#125; instance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> validationMode the type of validation: &#123;<span class="doctag">@link</span> XmlValidationModeDetector#VALIDATION_DTD DTD&#125;</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@link</span> XmlValidationModeDetector#VALIDATION_XSD XSD&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> namespaceAware whether the returned factory is to provide support for XML namespaces</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the JAXP DocumentBuilderFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ParserConfigurationException if we failed to build a proper DocumentBuilderFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DocumentBuilderFactory <span class="title">createDocumentBuilderFactory</span><span class="params">(<span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> ParserConfigurationException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建文档解析工厂</span></span><br><span class="line">   DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">   factory.setNamespaceAware(namespaceAware);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//设置解析XML的校验</span></span><br><span class="line">   <span class="keyword">if</span> (validationMode != XmlValidationModeDetector.VALIDATION_NONE) &#123;</span><br><span class="line">      factory.setValidating(<span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">if</span> (validationMode == XmlValidationModeDetector.VALIDATION_XSD) &#123;</span><br><span class="line">         <span class="comment">// Enforce namespace aware for XSD...</span></span><br><span class="line">         factory.setNamespaceAware(<span class="keyword">true</span>);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            ParserConfigurationException pcex = <span class="keyword">new</span> ParserConfigurationException(</span><br><span class="line">                  <span class="string">"Unable to validate using XSD: Your JAXP provider ["</span> + factory +</span><br><span class="line">                  <span class="string">"] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? "</span> +</span><br><span class="line">                  <span class="string">"Upgrade to Apache Xerces (or Java 1.5) for full XSD support."</span>);</span><br><span class="line">            pcex.initCause(ex);</span><br><span class="line">            <span class="keyword">throw</span> pcex;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的解析过程是调用 JavaEE 标准的 JAXP 标准进行处理。至此 Spring IOC 容器根据定位的 Bean 配 置信息，将其加载读入并转换成为 Document 对象过程完成。接下来我们要继续分析 Spring IOC 容器 将载入的 Bean 配置信息转换为 Document 对象之后，是如何将其解析为 Spring IOC 管理的 Bean 对象 并将其注册到容器中的。</p>
<h3 id="10、分配解析策略"><a href="#10、分配解析策略" class="headerlink" title="10、分配解析策略"></a><strong>10、分配解析策略</strong></h3><p>XmlBeanDefinitionReader 类中的 doLoadBeanDefinition()方法是从特定 XML 文件中实际载入 Bean 配置资源的方法，该方法在载入 Bean 配置资源之后将其转换为 Document 对象，接下来调用 registerBeanDefinitions() 启 动 Spring IOC 容 器 对 Bean 定 义 的 解 析 过 程 ， registerBeanDefinitions()方法源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register the bean definitions contained in the given DOM document.</span></span><br><span class="line"><span class="comment"> * Called by &#123;<span class="doctag">@code</span> loadBeanDefinitions&#125;.</span></span><br><span class="line"><span class="comment"> * \&lt;p\&gt;Creates a new instance of the parser class and invokes</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> registerBeanDefinitions&#125; on it.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> doc the DOM document</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource the resource descriptor (for context information)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of parsing errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #loadBeanDefinitions</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setDocumentReaderClass</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanDefinitionDocumentReader#registerBeanDefinitions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//按照Spring的Bean语义要求将Bean定义资源解析并转换为容器内部数据结构</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">   <span class="comment">//得到BeanDefinitionDocumentReader来对xml格式的BeanDefinition解析</span></span><br><span class="line">   BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">   <span class="comment">//获得容器中注册的Bean数量</span></span><br><span class="line">   <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">   <span class="comment">//解析过程入口，这里使用了委派模式，BeanDefinitionDocumentReader只是个接口,</span></span><br><span class="line">   <span class="comment">//具体的解析实现过程有实现类DefaultBeanDefinitionDocumentReader完成</span></span><br><span class="line">   documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">   <span class="comment">//统计解析的Bean数量</span></span><br><span class="line">   <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bean 配置资源的载入解析分为以下两个过程:<br>首先，通过调用 XML 解析器将 Bean 配置信息转换得到 Document 对象，但是这些 Document 对象 并没有按照 Spring 的 Bean 规则进行解析。这一步是载入的过程<br>其次，在完成通用的 XML 解析之后，按照 Spring Bean 的定义规则对 Document 对象进行解析，其 解 析 过 程 是 在 接 口 BeanDefinitionDocumentReader 的 实 现 类 DefaultBeanDefinitionDocumentReader 中实现。</p>
<h3 id="11、将配置载入内存"><a href="#11、将配置载入内存" class="headerlink" title="11、将配置载入内存"></a><strong>11、将配置载入内存</strong></h3><p>BeanDefinitionDocumentReader 接 口 通 过 registerBeanDefinitions() 方 法 调 用 其 实 现 类 DefaultBeanDefinitionDocumentReader 对 Document 对象进行解析，解析的代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This implementation parses bean definitions according to the "spring-beans" XSD</span></span><br><span class="line"><span class="comment"> * (or DTD, historically).</span></span><br><span class="line"><span class="comment"> * \&lt;p\&gt;Opens a DOM Document; then initializes the default settings</span></span><br><span class="line"><span class="comment"> * specified at the &#123;<span class="doctag">@code</span> \&lt;beans/\&gt;&#125; level; then parses the contained bean definitions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//根据Spring DTD对Bean的定义规则解析Bean定义Document对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//获得XML描述符</span></span><br><span class="line">   <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">   logger.debug(<span class="string">"Loading bean definitions"</span>);</span><br><span class="line">   <span class="comment">//获得Document的根元素</span></span><br><span class="line">   Element root = doc.getDocumentElement();</span><br><span class="line">   doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the descriptor for the XML resource that this parser works on.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> XmlReaderContext <span class="title">getReaderContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Assert.state(<span class="keyword">this</span>.readerContext != <span class="keyword">null</span>, <span class="string">"No XmlReaderContext available"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.readerContext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoke the &#123;<span class="doctag">@link</span> org.springframework.beans.factory.parsing.SourceExtractor&#125;</span></span><br><span class="line"><span class="comment"> * to pull the source metadata from the supplied &#123;<span class="doctag">@link</span> Element&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">extractSource</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> getReaderContext().extractSource(ele);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register each bean definition within the given root &#123;<span class="doctag">@code</span> \&lt;beans/\&gt;&#125; element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Any nested \&lt;beans\&gt; elements will cause recursion in this method. In</span></span><br><span class="line">   <span class="comment">// order to propagate and preserve \&lt;beans\&gt; default-* attributes correctly,</span></span><br><span class="line">   <span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line">   <span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line">   <span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line">   <span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//具体的解析过程由BeanDefinitionParserDelegate实现，</span></span><br><span class="line">   <span class="comment">//BeanDefinitionParserDelegate中定义了Spring Bean定义XML文件的各种元素</span></span><br><span class="line">   BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">   <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">         String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">               profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">         <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">               logger.info(<span class="string">"Skipped XML bean definition file due to specified profiles ["</span> + profileSpec +</span><br><span class="line">                     <span class="string">"] not matching: "</span> + getReaderContext().getResource());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//在解析Bean定义之前，进行自定义的解析，增强解析过程的可扩展性</span></span><br><span class="line">   preProcessXml(root);</span><br><span class="line">   <span class="comment">//从Document的根元素开始进行Bean定义的Document对象</span></span><br><span class="line">   parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">   <span class="comment">//在解析Bean定义之后，进行自定义的解析，增加解析过程的可扩展性</span></span><br><span class="line">   postProcessXml(root);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建BeanDefinitionParserDelegate，用于完成真正的解析过程</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanDefinitionParserDelegate <span class="title">createDelegate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      XmlReaderContext readerContext, Element root, @Nullable BeanDefinitionParserDelegate parentDelegate)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   BeanDefinitionParserDelegate delegate = <span class="keyword">new</span> BeanDefinitionParserDelegate(readerContext);</span><br><span class="line">   <span class="comment">//BeanDefinitionParserDelegate初始化Document根元素</span></span><br><span class="line">   delegate.initDefaults(root, parentDelegate);</span><br><span class="line">   <span class="keyword">return</span> delegate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse the elements at the root level in the document:</span></span><br><span class="line"><span class="comment"> * "import", "alias", "bean".</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root the DOM root element of the document</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//使用Spring的Bean规则从Document的根元素开始进行Bean定义的Document对象</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//Bean定义的Document对象使用了Spring默认的XML命名空间</span></span><br><span class="line">   <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      <span class="comment">//获取Bean定义的Document对象根元素的所有子节点</span></span><br><span class="line">      NodeList nl = root.getChildNodes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i \&lt; nl.getLength(); i++) &#123;</span><br><span class="line">         Node node = nl.item(i);</span><br><span class="line">         <span class="comment">//获得Document节点是XML元素节点</span></span><br><span class="line">         <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">            Element ele = (Element) node;</span><br><span class="line">            <span class="comment">//Bean定义的Document的元素节点使用的是Spring默认的XML命名空间</span></span><br><span class="line">            <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">               <span class="comment">//使用Spring的Bean规则解析元素节点</span></span><br><span class="line">               parseDefaultElement(ele, delegate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//没有使用Spring默认的XML命名空间，则使用用户自定义的解//析规则解析元素节点</span></span><br><span class="line">               delegate.parseCustomElement(ele);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//Document的根节点没有使用Spring默认的命名空间，则使用用户自定义的</span></span><br><span class="line">      <span class="comment">//解析规则解析Document根节点</span></span><br><span class="line">      delegate.parseCustomElement(root);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Spring的Bean规则解析Document元素节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//如果元素节点是\&lt;Import\&gt;导入元素，进行导入解析</span></span><br><span class="line">   <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">      importBeanDefinitionResource(ele);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果元素节点是\&lt;Alias\&gt;别名元素，进行别名解析</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">      processAliasRegistration(ele);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//元素节点既不是导入元素，也不是别名元素，即普通的\&lt;Bean\&gt;元素，</span></span><br><span class="line">   <span class="comment">//按照Spring的Bean规则解析元素</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">      processBeanDefinition(ele, delegate);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// recurse</span></span><br><span class="line">      doRegisterBeanDefinitions(ele);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse an "import" element and load the bean definitions</span></span><br><span class="line"><span class="comment"> * from the given resource into the bean factory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//解析\&lt;Import\&gt;导入元素，从给定的导入路径加载Bean定义资源到Spring IoC容器中</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">importBeanDefinitionResource</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//获取给定的导入元素的location属性</span></span><br><span class="line">   String location = ele.getAttribute(RESOURCE_ATTRIBUTE);</span><br><span class="line">   <span class="comment">//如果导入元素的location属性值为空，则没有导入任何资源，直接返回</span></span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(location)) &#123;</span><br><span class="line">      getReaderContext().error(<span class="string">"Resource location must not be empty"</span>, ele);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Resolve system properties: e.g. "$&#123;user.dir&#125;"</span></span><br><span class="line">   <span class="comment">//使用系统变量值解析location属性值</span></span><br><span class="line">   location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location);</span><br><span class="line"></span><br><span class="line">   Set\&lt;Resource\&gt; actualResources = <span class="keyword">new</span> LinkedHashSet\&lt;\&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Discover whether the location is an absolute or relative URI</span></span><br><span class="line">   <span class="comment">//标识给定的导入元素的location是否是绝对路径</span></span><br><span class="line">   <span class="keyword">boolean</span> absoluteLocation = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (URISyntaxException ex) &#123;</span><br><span class="line">      <span class="comment">// cannot convert to an URI, considering the location relative</span></span><br><span class="line">      <span class="comment">// unless it is the well-known Spring prefix "classpath*:"</span></span><br><span class="line">      <span class="comment">//给定的导入元素的location不是绝对路径</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Absolute or relative?</span></span><br><span class="line">   <span class="comment">//给定的导入元素的location是绝对路径</span></span><br><span class="line">   <span class="keyword">if</span> (absoluteLocation) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//使用资源读入器加载给定路径的Bean定义资源</span></span><br><span class="line">         <span class="keyword">int</span> importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources);</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Imported "</span> + importCount + <span class="string">" bean definitions from URL location ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         getReaderContext().error(</span><br><span class="line">               <span class="string">"Failed to import bean definitions from URL location ["</span> + location + <span class="string">"]"</span>, ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// No URL -\&gt; considering resource location as relative to the current file.</span></span><br><span class="line">      <span class="comment">//给定的导入元素的location是相对路径</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">int</span> importCount;</span><br><span class="line">         <span class="comment">//将给定导入元素的location封装为相对路径资源</span></span><br><span class="line">         Resource relativeResource = getReaderContext().getResource().createRelative(location);</span><br><span class="line">         <span class="comment">//封装的相对路径资源存在</span></span><br><span class="line">         <span class="keyword">if</span> (relativeResource.exists()) &#123;</span><br><span class="line">            <span class="comment">//使用资源读入器加载Bean定义资源</span></span><br><span class="line">            importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);</span><br><span class="line">            actualResources.add(relativeResource);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//封装的相对路径资源不存在</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//获取Spring IOC容器资源读入器的基本路径</span></span><br><span class="line">            String baseLocation = getReaderContext().getResource().getURL().toString();</span><br><span class="line">            <span class="comment">//根据Spring IOC容器资源读入器的基本路径加载给定导入路径的资源</span></span><br><span class="line">            importCount = getReaderContext().getReader().loadBeanDefinitions(</span><br><span class="line">                  StringUtils.applyRelativePath(baseLocation, location), actualResources);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Imported "</span> + importCount + <span class="string">" bean definitions from relative location ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">         getReaderContext().error(<span class="string">"Failed to resolve current resource location"</span>, ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         getReaderContext().error(<span class="string">"Failed to import bean definitions from relative location ["</span> + location + <span class="string">"]"</span>,</span><br><span class="line">               ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   Resource[] actResArray = actualResources.toArray(<span class="keyword">new</span> Resource[actualResources.size()]);</span><br><span class="line">   <span class="comment">//在解析完\&lt;Import\&gt;元素之后，发送容器导入其他资源处理完成事件</span></span><br><span class="line">   getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process the given alias element, registering the alias with the registry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//解析\&lt;Alias\&gt;别名元素，为Bean向Spring IoC容器注册别名</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAliasRegistration</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//获取\&lt;Alias\&gt;别名元素中name的属性值</span></span><br><span class="line">   String name = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">   <span class="comment">//获取\&lt;Alias\&gt;别名元素中alias的属性值</span></span><br><span class="line">   String alias = ele.getAttribute(ALIAS_ATTRIBUTE);</span><br><span class="line">   <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line">   <span class="comment">//\&lt;alias\&gt;别名元素的name属性值为空</span></span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(name)) &#123;</span><br><span class="line">      getReaderContext().error(<span class="string">"Name must not be empty"</span>, ele);</span><br><span class="line">      valid = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//\&lt;alias\&gt;别名元素的alias属性值为空</span></span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(alias)) &#123;</span><br><span class="line">      getReaderContext().error(<span class="string">"Alias must not be empty"</span>, ele);</span><br><span class="line">      valid = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//向容器的资源读入器注册别名</span></span><br><span class="line">         getReaderContext().getRegistry().registerAlias(name, alias);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">         getReaderContext().error(<span class="string">"Failed to register alias '"</span> + alias +</span><br><span class="line">               <span class="string">"' for bean with name '"</span> + name + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//在解析完\&lt;Alias\&gt;元素之后，发送容器别名处理完成事件</span></span><br><span class="line">      getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process the given bean element, parsing the bean definition</span></span><br><span class="line"><span class="comment"> * and registering it with the registry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//解析Bean定义资源Document对象的普通元素</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">   <span class="comment">// BeanDefinitionHolder是对BeanDefinition的封装，即Bean定义的封装类</span></span><br><span class="line">   <span class="comment">//对Document对象中\&lt;Bean\&gt;元素的解析由BeanDefinitionParserDelegate实现</span></span><br><span class="line">   <span class="comment">// BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span></span><br><span class="line">   <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">         <span class="comment">//向Spring IOC容器注册解析得到的Bean定义，这是Bean定义向IOC容器注册的入口</span></span><br><span class="line">         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">               bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Send registration event.</span></span><br><span class="line">      <span class="comment">//在完成向Spring IOC容器注册解析得到的Bean定义之后，发送注册事件</span></span><br><span class="line">      getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allow the XML to be extensible by processing any custom element types first,</span></span><br><span class="line"><span class="comment"> * before we start to process the bean definitions. This method is a natural</span></span><br><span class="line"><span class="comment"> * extension point for any other custom pre-processing of the XML.</span></span><br><span class="line"><span class="comment"> * \&lt;p\&gt;The default implementation is empty. Subclasses can override this method to</span></span><br><span class="line"><span class="comment"> * convert custom elements into standard Spring bean definitions, for example.</span></span><br><span class="line"><span class="comment"> * Implementors have access to the parser's bean definition reader and the</span></span><br><span class="line"><span class="comment"> * underlying XML resource, through the corresponding accessors.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getReaderContext()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">preProcessXml</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allow the XML to be extensible by processing any custom element types last,</span></span><br><span class="line"><span class="comment"> * after we finished processing the bean definitions. This method is a natural</span></span><br><span class="line"><span class="comment"> * extension point for any other custom post-processing of the XML.</span></span><br><span class="line"><span class="comment"> * \&lt;p\&gt;The default implementation is empty. Subclasses can override this method to</span></span><br><span class="line"><span class="comment"> * convert custom elements into standard Spring bean definitions, for example.</span></span><br><span class="line"><span class="comment"> * Implementors have access to the parser's bean definition reader and the</span></span><br><span class="line"><span class="comment"> * underlying XML resource, through the corresponding accessors.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getReaderContext()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessXml</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述 Spring IOC 容器对载入的 Bean 定义 Document 解析可以看出，我们使用 Spring 时，在 Spring 配置文件中可以使用&lt;import&gt;元素来导入 IOC 容器所需要的其他资源，Spring IOC 容器在解 析时会首先将指定导入的资源加载进容器中。使用&lt;ailas&gt;别名时，Spring IOC 容器首先将别名元素所 定义的别名注册到容器中。</p>
<p>对于既不是&lt;import&gt;元素，又不是&lt;alias&gt;元素的元素，即 Spring 配置文件中普通的&lt;bean&gt;元素的 解析由 BeanDefinitionParserDelegate 类的 parseBeanDefinitionElement()方法来实现。这个解析的 过程非常复杂，我们在 mini 版本的时候，就用 properties 文件代替了。</p>
<h3 id="12、载入-lt-bean-gt-元素"><a href="#12、载入-lt-bean-gt-元素" class="headerlink" title="12、载入&lt;bean&gt;元素"></a><strong>12、载入&lt;bean&gt;元素</strong></h3><p>Bean 配置信息中的&lt;import&gt;和&lt;alias&gt;元素解析在 DefaultBeanDefinitionDocumentReader 中已 经完成，对 Bean 配置信息中使用最多的&lt;bean&gt;元素交由 BeanDefinitionParserDelegate 来解析， 其解析实现的源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parses the supplied &#123;<span class="doctag">@code</span> \&lt;bean\&gt;&#125; element. May return &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * if there were errors during parse. Errors are reported to the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.parsing.ProblemReporter&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//解析\&lt;Bean\&gt;元素的入口</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> parseBeanDefinitionElement(ele, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parses the supplied &#123;<span class="doctag">@code</span> \&lt;bean\&gt;&#125; element. May return &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * if there were errors during parse. Errors are reported to the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.parsing.ProblemReporter&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//解析Bean定义资源文件中的\&lt;Bean\&gt;元素，这个方法中主要处理\&lt;Bean\&gt;元素的id，name和别名属性</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, @Nullable BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//获取\&lt;Bean\&gt;元素中的id属性值</span></span><br><span class="line">   String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">   <span class="comment">//获取\&lt;Bean\&gt;元素中的name属性值</span></span><br><span class="line">   String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取\&lt;Bean\&gt;元素中的alias属性值</span></span><br><span class="line">   List\&lt;String\&gt; aliases = <span class="keyword">new</span> ArrayList\&lt;\&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//将\&lt;Bean\&gt;元素中的所有name属性值存放到别名中</span></span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">      String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">      aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   String beanName = id;</span><br><span class="line">   <span class="comment">//如果\&lt;Bean\&gt;元素中没有配置id属性时，将别名中的第一个值赋值给beanName</span></span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">      beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"No XML 'id' specified - using '"</span> + beanName +</span><br><span class="line">               <span class="string">"' as bean name and "</span> + aliases + <span class="string">" as aliases"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//检查\&lt;Bean\&gt;元素所配置的id或者name的唯一性，containingBean标识\&lt;Bean\&gt;</span></span><br><span class="line">   <span class="comment">//元素中是否包含子\&lt;Bean\&gt;元素</span></span><br><span class="line">   <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//检查\&lt;Bean\&gt;元素所配置的id、name或者别名是否重复</span></span><br><span class="line">      checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//详细对\&lt;Bean\&gt;元素中配置的Bean定义进行解析的地方</span></span><br><span class="line">   AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">   <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//如果\&lt;Bean\&gt;元素中没有配置id、别名或者name，且没有包含子元素</span></span><br><span class="line">               <span class="comment">//\&lt;Bean\&gt;元素，为解析的Bean生成一个唯一beanName并注册</span></span><br><span class="line">               beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                     beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//如果\&lt;Bean\&gt;元素中没有配置id、别名或者name，且包含了子元素</span></span><br><span class="line">               <span class="comment">//\&lt;Bean\&gt;元素，为解析的Bean使用别名向IOC容器注册</span></span><br><span class="line">               beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">               <span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line">               <span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line">               <span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line">               <span class="comment">//为解析的Bean使用别名注册时，为了向后兼容</span></span><br><span class="line">               <span class="comment">//Spring1.2/2.0，给别名添加类名后缀</span></span><br><span class="line">               String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">               <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     beanName.startsWith(beanClassName) &amp;&amp; beanName.length() \&gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                     !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                  aliases.add(beanClassName);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">               logger.debug(<span class="string">"Neither XML 'id' nor 'name' specified - "</span> +</span><br><span class="line">                     <span class="string">"using generated bean name ["</span> + beanName + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            error(ex.getMessage(), ele);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//当解析出错时，返回null</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Validate that the specified bean name and aliases have not been used already</span></span><br><span class="line"><span class="comment"> * within the current level of beans element nesting.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkNameUniqueness</span><span class="params">(String beanName, List\&lt;String\&gt; aliases, Element beanElement)</span> </span>&#123;</span><br><span class="line">   String foundName = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasText(beanName) &amp;&amp; <span class="keyword">this</span>.usedNames.contains(beanName)) &#123;</span><br><span class="line">      foundName = beanName;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (foundName == <span class="keyword">null</span>) &#123;</span><br><span class="line">      foundName = CollectionUtils.findFirstMatch(<span class="keyword">this</span>.usedNames, aliases);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (foundName != <span class="keyword">null</span>) &#123;</span><br><span class="line">      error(<span class="string">"Bean name '"</span> + foundName + <span class="string">"' is already used in this \&lt;beans\&gt; element"</span>, beanElement);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.usedNames.add(beanName);</span><br><span class="line">   <span class="keyword">this</span>.usedNames.addAll(aliases);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse the bean definition itself, without regard to name or aliases. May return</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> null&#125; if problems occurred during the parsing of the bean definition.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//详细对\&lt;Bean\&gt;元素中配置的Bean定义其他属性进行解析</span></span><br><span class="line"><span class="comment">//由于上面的方法中已经对Bean的id、name和别名等属性进行了处理</span></span><br><span class="line"><span class="comment">//该方法中主要处理除这三个以外的其他属性数据</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Element ele, String beanName, @Nullable BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//记录解析的\&lt;Bean\&gt;</span></span><br><span class="line">   <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">   <span class="comment">//这里只读取\&lt;Bean\&gt;元素中配置的class名字，然后载入到BeanDefinition中去</span></span><br><span class="line">   <span class="comment">//只是记录配置的class名字，不做实例化，对象的实例化在依赖注入时完成</span></span><br><span class="line">   String className = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//如果\&lt;Bean\&gt;元素中配置了parent属性，则获取parent属性的值</span></span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">      className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">   &#125;</span><br><span class="line">   String parent = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">      parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//根据\&lt;Bean\&gt;元素配置的class名称和parent属性值创建BeanDefinition</span></span><br><span class="line">      <span class="comment">//为载入Bean定义信息做准备</span></span><br><span class="line">      AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//对当前的\&lt;Bean\&gt;元素中配置的一些属性进行解析和设置，如配置的单态(singleton)属性等</span></span><br><span class="line">      parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">      <span class="comment">//为\&lt;Bean\&gt;元素解析的Bean设置description信息</span></span><br><span class="line">      bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//对\&lt;Bean\&gt;元素的meta(元信息)属性解析</span></span><br><span class="line">      parseMetaElements(ele, bd);</span><br><span class="line">      <span class="comment">//对\&lt;Bean\&gt;元素的lookup-method属性解析</span></span><br><span class="line">      parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">      <span class="comment">//对\&lt;Bean\&gt;元素的replaced-method属性解析</span></span><br><span class="line">      parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//解析\&lt;Bean\&gt;元素的构造方法设置</span></span><br><span class="line">      parseConstructorArgElements(ele, bd);</span><br><span class="line">      <span class="comment">//解析\&lt;Bean\&gt;元素的\&lt;property\&gt;设置</span></span><br><span class="line">      parsePropertyElements(ele, bd);</span><br><span class="line">      <span class="comment">//解析\&lt;Bean\&gt;元素的qualifier属性</span></span><br><span class="line">      parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//为当前解析的Bean设置所需的资源和依赖对象</span></span><br><span class="line">      bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">      bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> bd;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">      error(<span class="string">"Bean class ["</span> + className + <span class="string">"] not found"</span>, ele, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (NoClassDefFoundError err) &#123;</span><br><span class="line">      error(<span class="string">"Class that bean class ["</span> + className + <span class="string">"] depends on not found"</span>, ele, err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      error(<span class="string">"Unexpected failure during bean definition parsing"</span>, ele, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//解析\&lt;Bean\&gt;元素出错时，返回null</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要使用过 Spring，对 Spring 配置文件比较熟悉的人，通过对上述源码的分析，就会明白我们在 Spring 配置文件中&lt;Bean&gt;元素的中配置的属性就是通过该方法解析和设置到 Bean 中去的。 注意:在解析&lt;Bean&gt;元素过程中没有创建和实例化 Bean 对象，只是创建了 Bean 对象的定义类 BeanDefinition，将&lt;Bean&gt;元素中的配置信息设置到 BeanDefinition 中作为记录，当依赖注入时才 使用这些记录信息创建和实例化具体的 Bean 对象。 上面方法中一些对一些配置如元信息(meta)、qualifier 等的解析，我们在 Spring 中配置时使用的也不 多，我们在使用 Spring 的&lt;Bean&gt;元素时，配置最多的是&lt;property&gt;属性，因此我们下面继续分析源 码，了解 Bean 的属性在解析时是如何设置的。</p>
<h3 id="13、载入-lt-property-gt-元素"><a href="#13、载入-lt-property-gt-元素" class="headerlink" title="13、载入&lt;property&gt;元素"></a>13、载入&lt;property&gt;元素</h3><p>BeanDefinitionParserDelegate 在解析&lt;Bean&gt;调用 parsePropertyElements()方法解析&lt;Bean&gt;元 素中的&lt;property&gt;属性子元素，解析源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse property sub-elements of the given bean element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//解析\&lt;Bean\&gt;元素中的\&lt;property\&gt;子元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parsePropertyElements</span><span class="params">(Element beanEle, BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//获取\&lt;Bean\&gt;元素中所有的子元素</span></span><br><span class="line">   NodeList nl = beanEle.getChildNodes();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i \&lt; nl.getLength(); i++) &#123;</span><br><span class="line">      Node node = nl.item(i);</span><br><span class="line">      <span class="comment">//如果子元素是\&lt;property\&gt;子元素，则调用解析\&lt;property\&gt;子元素方法解析</span></span><br><span class="line">      <span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) &#123;</span><br><span class="line">         parsePropertyElement((Element) node, bd);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse qualifier sub-elements of the given bean element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseQualifierElements</span><span class="params">(Element beanEle, AbstractBeanDefinition bd)</span> </span>&#123;</span><br><span class="line">   NodeList nl = beanEle.getChildNodes();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i \&lt; nl.getLength(); i++) &#123;</span><br><span class="line">      Node node = nl.item(i);</span><br><span class="line">      <span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, QUALIFIER_ELEMENT)) &#123;</span><br><span class="line">         parseQualifierElement((Element) node, bd);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse lookup-override sub-elements of the given bean element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseLookupOverrideSubElements</span><span class="params">(Element beanEle, MethodOverrides overrides)</span> </span>&#123;</span><br><span class="line">   NodeList nl = beanEle.getChildNodes();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i \&lt; nl.getLength(); i++) &#123;</span><br><span class="line">      Node node = nl.item(i);</span><br><span class="line">      <span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, LOOKUP_METHOD_ELEMENT)) &#123;</span><br><span class="line">         Element ele = (Element) node;</span><br><span class="line">         String methodName = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">         String beanRef = ele.getAttribute(BEAN_ELEMENT);</span><br><span class="line">         LookupOverride override = <span class="keyword">new</span> LookupOverride(methodName, beanRef);</span><br><span class="line">         override.setSource(extractSource(ele));</span><br><span class="line">         overrides.addOverride(override);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse replaced-method sub-elements of the given bean element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseReplacedMethodSubElements</span><span class="params">(Element beanEle, MethodOverrides overrides)</span> </span>&#123;</span><br><span class="line">   NodeList nl = beanEle.getChildNodes();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i \&lt; nl.getLength(); i++) &#123;</span><br><span class="line">      Node node = nl.item(i);</span><br><span class="line">      <span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, REPLACED_METHOD_ELEMENT)) &#123;</span><br><span class="line">         Element replacedMethodEle = (Element) node;</span><br><span class="line">         String name = replacedMethodEle.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">         String callback = replacedMethodEle.getAttribute(REPLACER_ATTRIBUTE);</span><br><span class="line">         ReplaceOverride replaceOverride = <span class="keyword">new</span> ReplaceOverride(name, callback);</span><br><span class="line">         <span class="comment">// Look for arg-type match elements.</span></span><br><span class="line">         List\&lt;Element\&gt; argTypeEles = DomUtils.getChildElementsByTagName(replacedMethodEle, ARG_TYPE_ELEMENT);</span><br><span class="line">         <span class="keyword">for</span> (Element argTypeEle : argTypeEles) &#123;</span><br><span class="line">            String match = argTypeEle.getAttribute(ARG_TYPE_MATCH_ATTRIBUTE);</span><br><span class="line">            match = (StringUtils.hasText(match) ? match : DomUtils.getTextValue(argTypeEle));</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(match)) &#123;</span><br><span class="line">               replaceOverride.addTypeIdentifier(match);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         replaceOverride.setSource(extractSource(replacedMethodEle));</span><br><span class="line">         overrides.addOverride(replaceOverride);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse a constructor-arg element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseConstructorArgElement</span><span class="params">(Element ele, BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">   String indexAttr = ele.getAttribute(INDEX_ATTRIBUTE);</span><br><span class="line">   String typeAttr = ele.getAttribute(TYPE_ATTRIBUTE);</span><br><span class="line">   String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasLength(indexAttr)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">int</span> index = Integer.parseInt(indexAttr);</span><br><span class="line">         <span class="keyword">if</span> (index \&lt; <span class="number">0</span>) &#123;</span><br><span class="line">            error(<span class="string">"'index' cannot be lower than 0"</span>, ele);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> ConstructorArgumentEntry(index));</span><br><span class="line">               Object value = parsePropertyValue(ele, bd, <span class="keyword">null</span>);</span><br><span class="line">               ConstructorArgumentValues.ValueHolder valueHolder = <span class="keyword">new</span> ConstructorArgumentValues.ValueHolder(value);</span><br><span class="line">               <span class="keyword">if</span> (StringUtils.hasLength(typeAttr)) &#123;</span><br><span class="line">                  valueHolder.setType(typeAttr);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">                  valueHolder.setName(nameAttr);</span><br><span class="line">               &#125;</span><br><span class="line">               valueHolder.setSource(extractSource(ele));</span><br><span class="line">               <span class="keyword">if</span> (bd.getConstructorArgumentValues().hasIndexedArgumentValue(index)) &#123;</span><br><span class="line">                  error(<span class="string">"Ambiguous constructor-arg entries for index "</span> + index, ele);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                  bd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (NumberFormatException ex) &#123;</span><br><span class="line">         error(<span class="string">"Attribute 'index' of tag 'constructor-arg' must be an integer"</span>, ele);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> ConstructorArgumentEntry());</span><br><span class="line">         Object value = parsePropertyValue(ele, bd, <span class="keyword">null</span>);</span><br><span class="line">         ConstructorArgumentValues.ValueHolder valueHolder = <span class="keyword">new</span> ConstructorArgumentValues.ValueHolder(value);</span><br><span class="line">         <span class="keyword">if</span> (StringUtils.hasLength(typeAttr)) &#123;</span><br><span class="line">            valueHolder.setType(typeAttr);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">            valueHolder.setName(nameAttr);</span><br><span class="line">         &#125;</span><br><span class="line">         valueHolder.setSource(extractSource(ele));</span><br><span class="line">         bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse a property element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//解析\&lt;property\&gt;元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parsePropertyElement</span><span class="params">(Element ele, BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//获取\&lt;property\&gt;元素的名字</span></span><br><span class="line">   String propertyName = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasLength(propertyName)) &#123;</span><br><span class="line">      error(<span class="string">"Tag 'property' must have a 'name' attribute"</span>, ele);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> PropertyEntry(propertyName));</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//如果一个Bean中已经有同名的property存在，则不进行解析，直接返回。</span></span><br><span class="line">      <span class="comment">//即如果在同一个Bean中配置同名的property，则只有第一个起作用</span></span><br><span class="line">      <span class="keyword">if</span> (bd.getPropertyValues().contains(propertyName)) &#123;</span><br><span class="line">         error(<span class="string">"Multiple 'property' definitions for property '"</span> + propertyName + <span class="string">"'"</span>, ele);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//解析获取property的值</span></span><br><span class="line">      Object val = parsePropertyValue(ele, bd, propertyName);</span><br><span class="line">      <span class="comment">//根据property的名字和值创建property实例</span></span><br><span class="line">      PropertyValue pv = <span class="keyword">new</span> PropertyValue(propertyName, val);</span><br><span class="line">      <span class="comment">//解析\&lt;property\&gt;元素中的属性</span></span><br><span class="line">      parseMetaElements(ele, pv);</span><br><span class="line">      pv.setSource(extractSource(ele));</span><br><span class="line">      bd.getPropertyValues().addPropertyValue(pv);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse a qualifier element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseQualifierElement</span><span class="params">(Element ele, AbstractBeanDefinition bd)</span> </span>&#123;</span><br><span class="line">   String typeName = ele.getAttribute(TYPE_ATTRIBUTE);</span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasLength(typeName)) &#123;</span><br><span class="line">      error(<span class="string">"Tag 'qualifier' must have a 'type' attribute"</span>, ele);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> QualifierEntry(typeName));</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      AutowireCandidateQualifier qualifier = <span class="keyword">new</span> AutowireCandidateQualifier(typeName);</span><br><span class="line">      qualifier.setSource(extractSource(ele));</span><br><span class="line">      String value = ele.getAttribute(VALUE_ATTRIBUTE);</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasLength(value)) &#123;</span><br><span class="line">         qualifier.setAttribute(AutowireCandidateQualifier.VALUE_KEY, value);</span><br><span class="line">      &#125;</span><br><span class="line">      NodeList nl = ele.getChildNodes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i \&lt; nl.getLength(); i++) &#123;</span><br><span class="line">         Node node = nl.item(i);</span><br><span class="line">         <span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, QUALIFIER_ATTRIBUTE_ELEMENT)) &#123;</span><br><span class="line">            Element attributeEle = (Element) node;</span><br><span class="line">            String attributeName = attributeEle.getAttribute(KEY_ATTRIBUTE);</span><br><span class="line">            String attributeValue = attributeEle.getAttribute(VALUE_ATTRIBUTE);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(attributeName) &amp;&amp; StringUtils.hasLength(attributeValue)) &#123;</span><br><span class="line">               BeanMetadataAttribute attribute = <span class="keyword">new</span> BeanMetadataAttribute(attributeName, attributeValue);</span><br><span class="line">               attribute.setSource(extractSource(attributeEle));</span><br><span class="line">               qualifier.addMetadataAttribute(attribute);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               error(<span class="string">"Qualifier 'attribute' tag must have a 'name' and 'value'"</span>, attributeEle);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      bd.addQualifier(qualifier);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the value of a property element. May be a list etc.</span></span><br><span class="line"><span class="comment"> * Also used for constructor arguments, "propertyName" being null in this case.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//解析获取property值</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">parsePropertyValue</span><span class="params">(Element ele, BeanDefinition bd, @Nullable String propertyName)</span> </span>&#123;</span><br><span class="line">   String elementName = (propertyName != <span class="keyword">null</span>) ?</span><br><span class="line">               <span class="string">"\&lt;property\&gt; element for property '"</span> + propertyName + <span class="string">"'"</span> :</span><br><span class="line">               <span class="string">"\&lt;constructor-arg\&gt; element"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Should only have one child element: ref, value, list, etc.</span></span><br><span class="line">   <span class="comment">//获取\&lt;property\&gt;的所有子元素，只能是其中一种类型:ref,value,list,etc等</span></span><br><span class="line">   NodeList nl = ele.getChildNodes();</span><br><span class="line">   Element subElement = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i \&lt; nl.getLength(); i++) &#123;</span><br><span class="line">      Node node = nl.item(i);</span><br><span class="line">      <span class="comment">//子元素不是description和meta属性</span></span><br><span class="line">      <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp;</span><br><span class="line">            !nodeNameEquals(node, META_ELEMENT)) &#123;</span><br><span class="line">         <span class="comment">// Child element is what we're looking for.</span></span><br><span class="line">         <span class="keyword">if</span> (subElement != <span class="keyword">null</span>) &#123;</span><br><span class="line">            error(elementName + <span class="string">" must not contain more than one sub-element"</span>, ele);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当前\&lt;property\&gt;元素包含有子元素</span></span><br><span class="line">            subElement = (Element) node;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//判断property的属性值是ref还是value，不允许既是ref又是value</span></span><br><span class="line">   <span class="keyword">boolean</span> hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);</span><br><span class="line">   <span class="keyword">boolean</span> hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);</span><br><span class="line">   <span class="keyword">if</span> ((hasRefAttribute &amp;&amp; hasValueAttribute) ||</span><br><span class="line">         ((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement != <span class="keyword">null</span>)) &#123;</span><br><span class="line">      error(elementName +</span><br><span class="line">            <span class="string">" is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element"</span>, ele);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//如果属性是ref，创建一个ref的数据对象RuntimeBeanReference</span></span><br><span class="line">   <span class="comment">//这个对象封装了ref信息</span></span><br><span class="line">   <span class="keyword">if</span> (hasRefAttribute) &#123;</span><br><span class="line">      String refName = ele.getAttribute(REF_ATTRIBUTE);</span><br><span class="line">      <span class="keyword">if</span> (!StringUtils.hasText(refName)) &#123;</span><br><span class="line">         error(elementName + <span class="string">" contains empty 'ref' attribute"</span>, ele);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//一个指向运行时所依赖对象的引用</span></span><br><span class="line">      RuntimeBeanReference ref = <span class="keyword">new</span> RuntimeBeanReference(refName);</span><br><span class="line">      <span class="comment">//设置这个ref的数据对象是被当前的property对象所引用</span></span><br><span class="line">      ref.setSource(extractSource(ele));</span><br><span class="line">      <span class="keyword">return</span> ref;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果属性是value，创建一个value的数据对象TypedStringValue</span></span><br><span class="line">   <span class="comment">//这个对象封装了value信息</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (hasValueAttribute) &#123;</span><br><span class="line">      <span class="comment">//一个持有String类型值的对象</span></span><br><span class="line">      TypedStringValue valueHolder = <span class="keyword">new</span> TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));</span><br><span class="line">      <span class="comment">//设置这个value数据对象是被当前的property对象所引用</span></span><br><span class="line">      valueHolder.setSource(extractSource(ele));</span><br><span class="line">      <span class="keyword">return</span> valueHolder;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果当前\&lt;property\&gt;元素还有子元素</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (subElement != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//解析\&lt;property\&gt;的子元素</span></span><br><span class="line">      <span class="keyword">return</span> parsePropertySubElement(subElement, bd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Neither child element nor "ref" or "value" attribute found.</span></span><br><span class="line">      <span class="comment">//propery属性中既不是ref，也不是value属性，解析出错返回null</span></span><br><span class="line">      error(elementName + <span class="string">" must specify a ref or value"</span>, ele);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">parsePropertySubElement</span><span class="params">(Element ele, @Nullable BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> parsePropertySubElement(ele, bd, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse a value, ref or collection sub-element of a property or</span></span><br><span class="line"><span class="comment"> * constructor-arg element.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ele subelement of property element; we don't know which yet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultValueType the default type (class name) for any</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> \&lt;value\&gt;&#125; tag that might be created</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//解析\&lt;property\&gt;元素中ref,value或者集合等子元素</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">parsePropertySubElement</span><span class="params">(Element ele, @Nullable BeanDefinition bd, @Nullable String defaultValueType)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//如果\&lt;property\&gt;没有使用Spring默认的命名空间，则使用用户自定义的规则解析内嵌元素</span></span><br><span class="line">   <span class="keyword">if</span> (!isDefaultNamespace(ele)) &#123;</span><br><span class="line">      <span class="keyword">return</span> parseNestedCustomElement(ele, bd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果子元素是bean，则使用解析\&lt;Bean\&gt;元素的方法解析</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">      BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);</span><br><span class="line">      <span class="keyword">if</span> (nestedBd != <span class="keyword">null</span>) &#123;</span><br><span class="line">         nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> nestedBd;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果子元素是ref，ref中只能有以下3个属性：bean、local、parent</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, REF_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// A generic reference to any name of any bean.</span></span><br><span class="line">      <span class="comment">//可以不再同一个Spring配置文件中，具体请参考Spring对ref的配置规则</span></span><br><span class="line">      String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);</span><br><span class="line">      <span class="keyword">boolean</span> toParent = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (!StringUtils.hasLength(refName)) &#123;</span><br><span class="line">         <span class="comment">// A reference to the id of another bean in a parent context.</span></span><br><span class="line">         <span class="comment">//获取\&lt;property\&gt;元素中parent属性值，引用父级容器中的Bean</span></span><br><span class="line">         refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);</span><br><span class="line">         toParent = <span class="keyword">true</span>;</span><br><span class="line">         <span class="keyword">if</span> (!StringUtils.hasLength(refName)) &#123;</span><br><span class="line">            error(<span class="string">"'bean' or 'parent' is required for \&lt;ref\&gt; element"</span>, ele);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!StringUtils.hasText(refName)) &#123;</span><br><span class="line">         error(<span class="string">"\&lt;ref\&gt; element contains empty target attribute"</span>, ele);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//创建ref类型数据，指向被引用的对象</span></span><br><span class="line">      RuntimeBeanReference ref = <span class="keyword">new</span> RuntimeBeanReference(refName, toParent);</span><br><span class="line">      <span class="comment">//设置引用类型值是被当前子元素所引用</span></span><br><span class="line">      ref.setSource(extractSource(ele));</span><br><span class="line">      <span class="keyword">return</span> ref;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果子元素是\&lt;idref\&gt;，使用解析ref元素的方法解析</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, IDREF_ELEMENT)) &#123;</span><br><span class="line">      <span class="keyword">return</span> parseIdRefElement(ele);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果子元素是\&lt;value\&gt;，使用解析value元素的方法解析</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, VALUE_ELEMENT)) &#123;</span><br><span class="line">      <span class="keyword">return</span> parseValueElement(ele, defaultValueType);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果子元素是null，为\&lt;property\&gt;设置一个封装null值的字符串数据</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, NULL_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// It's a distinguished null value. Let's wrap it in a TypedStringValue</span></span><br><span class="line">      <span class="comment">// object in order to preserve the source location.</span></span><br><span class="line">      TypedStringValue nullHolder = <span class="keyword">new</span> TypedStringValue(<span class="keyword">null</span>);</span><br><span class="line">      nullHolder.setSource(extractSource(ele));</span><br><span class="line">      <span class="keyword">return</span> nullHolder;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果子元素是\&lt;array\&gt;，使用解析array集合子元素的方法解析</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, ARRAY_ELEMENT)) &#123;</span><br><span class="line">      <span class="keyword">return</span> parseArrayElement(ele, bd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果子元素是\&lt;list\&gt;，使用解析list集合子元素的方法解析</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, LIST_ELEMENT)) &#123;</span><br><span class="line">      <span class="keyword">return</span> parseListElement(ele, bd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果子元素是\&lt;set\&gt;，使用解析set集合子元素的方法解析</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, SET_ELEMENT)) &#123;</span><br><span class="line">      <span class="keyword">return</span> parseSetElement(ele, bd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果子元素是\&lt;map\&gt;，使用解析map集合子元素的方法解析</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, MAP_ELEMENT)) &#123;</span><br><span class="line">      <span class="keyword">return</span> parseMapElement(ele, bd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果子元素是\&lt;props\&gt;，使用解析props集合子元素的方法解析</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, PROPS_ELEMENT)) &#123;</span><br><span class="line">      <span class="keyword">return</span> parsePropsElement(ele);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//既不是ref，又不是value，也不是集合，则子元素配置错误，返回null</span></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      error(<span class="string">"Unknown property sub-element: ["</span> + ele.getNodeName() + <span class="string">"]"</span>, ele);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过对上述源码的分析，我们可以了解在 Spring 配置文件中，&lt;Bean&gt;元素中&lt;property&gt;元素的相关 配置是如何处理的:</p>
<ol>
<li><p>ref 被封装为指向依赖对象一个引用。</p>
</li>
<li><p>value 配置都会封装成一个字符串类型的对象。</p>
</li>
<li><p>ref 和 value 都通过“解析的数据类型属性值.setSource(extractSource(ele));”方法将属性值/引用 与所引用的属性关联起来。</p>
</li>
</ol>
<p>在方法的最后对于&lt;property&gt;元素的子元素通过 parsePropertySubElement ()方法解析，我们继续分 析该方法的源码，了解其解析过程。</p>
<h3 id="14、载入-lt-property-gt-的子元素"><a href="#14、载入-lt-property-gt-的子元素" class="headerlink" title="14、载入&lt;property&gt;的子元素"></a><strong>14、载入&lt;property&gt;的子元素</strong></h3><p>在 BeanDefinitionParserDelegate 类中的 parsePropertySubElement()方法对&lt;property&gt;中的子元 素解析，源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse a value, ref or collection sub-element of a property or</span></span><br><span class="line"><span class="comment"> * constructor-arg element.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ele subelement of property element; we don't know which yet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultValueType the default type (class name) for any</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> \&lt;value\&gt;&#125; tag that might be created</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//解析\&lt;property\&gt;元素中ref,value或者集合等子元素</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">parsePropertySubElement</span><span class="params">(Element ele, @Nullable BeanDefinition bd, @Nullable String defaultValueType)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//如果\&lt;property\&gt;没有使用Spring默认的命名空间，则使用用户自定义的规则解析内嵌元素</span></span><br><span class="line">   <span class="keyword">if</span> (!isDefaultNamespace(ele)) &#123;</span><br><span class="line">      <span class="keyword">return</span> parseNestedCustomElement(ele, bd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果子元素是bean，则使用解析\&lt;Bean\&gt;元素的方法解析</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">      BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);</span><br><span class="line">      <span class="keyword">if</span> (nestedBd != <span class="keyword">null</span>) &#123;</span><br><span class="line">         nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> nestedBd;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果子元素是ref，ref中只能有以下3个属性：bean、local、parent</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, REF_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// A generic reference to any name of any bean.</span></span><br><span class="line">      <span class="comment">//可以不再同一个Spring配置文件中，具体请参考Spring对ref的配置规则</span></span><br><span class="line">      String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);</span><br><span class="line">      <span class="keyword">boolean</span> toParent = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (!StringUtils.hasLength(refName)) &#123;</span><br><span class="line">         <span class="comment">// A reference to the id of another bean in a parent context.</span></span><br><span class="line">         <span class="comment">//获取\&lt;property\&gt;元素中parent属性值，引用父级容器中的Bean</span></span><br><span class="line">         refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);</span><br><span class="line">         toParent = <span class="keyword">true</span>;</span><br><span class="line">         <span class="keyword">if</span> (!StringUtils.hasLength(refName)) &#123;</span><br><span class="line">            error(<span class="string">"'bean' or 'parent' is required for \&lt;ref\&gt; element"</span>, ele);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!StringUtils.hasText(refName)) &#123;</span><br><span class="line">         error(<span class="string">"\&lt;ref\&gt; element contains empty target attribute"</span>, ele);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//创建ref类型数据，指向被引用的对象</span></span><br><span class="line">      RuntimeBeanReference ref = <span class="keyword">new</span> RuntimeBeanReference(refName, toParent);</span><br><span class="line">      <span class="comment">//设置引用类型值是被当前子元素所引用</span></span><br><span class="line">      ref.setSource(extractSource(ele));</span><br><span class="line">      <span class="keyword">return</span> ref;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果子元素是\&lt;idref\&gt;，使用解析ref元素的方法解析</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, IDREF_ELEMENT)) &#123;</span><br><span class="line">      <span class="keyword">return</span> parseIdRefElement(ele);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果子元素是\&lt;value\&gt;，使用解析value元素的方法解析</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, VALUE_ELEMENT)) &#123;</span><br><span class="line">      <span class="keyword">return</span> parseValueElement(ele, defaultValueType);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果子元素是null，为\&lt;property\&gt;设置一个封装null值的字符串数据</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, NULL_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// It's a distinguished null value. Let's wrap it in a TypedStringValue</span></span><br><span class="line">      <span class="comment">// object in order to preserve the source location.</span></span><br><span class="line">      TypedStringValue nullHolder = <span class="keyword">new</span> TypedStringValue(<span class="keyword">null</span>);</span><br><span class="line">      nullHolder.setSource(extractSource(ele));</span><br><span class="line">      <span class="keyword">return</span> nullHolder;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果子元素是\&lt;array\&gt;，使用解析array集合子元素的方法解析</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, ARRAY_ELEMENT)) &#123;</span><br><span class="line">      <span class="keyword">return</span> parseArrayElement(ele, bd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果子元素是\&lt;list\&gt;，使用解析list集合子元素的方法解析</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, LIST_ELEMENT)) &#123;</span><br><span class="line">      <span class="keyword">return</span> parseListElement(ele, bd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果子元素是\&lt;set\&gt;，使用解析set集合子元素的方法解析</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, SET_ELEMENT)) &#123;</span><br><span class="line">      <span class="keyword">return</span> parseSetElement(ele, bd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果子元素是\&lt;map\&gt;，使用解析map集合子元素的方法解析</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, MAP_ELEMENT)) &#123;</span><br><span class="line">      <span class="keyword">return</span> parseMapElement(ele, bd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果子元素是\&lt;props\&gt;，使用解析props集合子元素的方法解析</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, PROPS_ELEMENT)) &#123;</span><br><span class="line">      <span class="keyword">return</span> parsePropsElement(ele);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//既不是ref，又不是value，也不是集合，则子元素配置错误，返回null</span></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      error(<span class="string">"Unknown property sub-element: ["</span> + ele.getNodeName() + <span class="string">"]"</span>, ele);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述源码分析，我们明白了在 Spring 配置文件中，对&lt;property&gt;元素中配置的 array、list、set、 map、prop 等各种集合子元素的都通过上述方法解析，生成对应的数据对象，比如 ManagedList、 ManagedArray、ManagedSet 等，这些 Managed 类是 Spring 对象 BeanDefiniton 的数据封装，对 集合数据类型的具体解析有各自的解析方法实现，解析方法的命名非常规范，一目了然，我们对&lt;list&gt; 集合元素的解析方法进行源码分析，了解其实现过程。</p>
<h3 id="15、载入-lt-list-gt-的子元素"><a href="#15、载入-lt-list-gt-的子元素" class="headerlink" title="15、载入&lt;list&gt;的子元素"></a><strong>15、载入&lt;list&gt;的子元素</strong></h3><p>在 BeanDefinitionParserDelegate 类中的 parseListElement()方法就是具体实现解析&lt;property&gt;元 素中的&lt;list&gt;集合子元素，源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse a list element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//解析\&lt;list\&gt;集合子元素</span></span><br><span class="line"><span class="keyword">public</span> List\&lt;Object\&gt; parseListElement(Element collectionEle, <span class="meta">@Nullable</span> BeanDefinition bd) &#123;</span><br><span class="line">   <span class="comment">//获取\&lt;list\&gt;元素中的value-type属性，即获取集合元素的数据类型</span></span><br><span class="line">   String defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);</span><br><span class="line">   <span class="comment">//获取\&lt;list\&gt;集合元素中的所有子节点</span></span><br><span class="line">   NodeList nl = collectionEle.getChildNodes();</span><br><span class="line">   <span class="comment">//Spring中将List封装为ManagedList</span></span><br><span class="line">   ManagedList\&lt;Object\&gt; target = <span class="keyword">new</span> ManagedList\&lt;\&gt;(nl.getLength());</span><br><span class="line">   target.setSource(extractSource(collectionEle));</span><br><span class="line">   <span class="comment">//设置集合目标数据类型</span></span><br><span class="line">   target.setElementTypeName(defaultElementType);</span><br><span class="line">   target.setMergeEnabled(parseMergeAttribute(collectionEle));</span><br><span class="line">   <span class="comment">//具体的\&lt;list\&gt;元素解析</span></span><br><span class="line">   parseCollectionElements(nl, target, bd, defaultElementType);</span><br><span class="line">   <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse a set element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set\&lt;Object\&gt; parseSetElement(Element collectionEle, <span class="meta">@Nullable</span> BeanDefinition bd) &#123;</span><br><span class="line">   String defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);</span><br><span class="line">   NodeList nl = collectionEle.getChildNodes();</span><br><span class="line">   ManagedSet\&lt;Object\&gt; target = <span class="keyword">new</span> ManagedSet\&lt;\&gt;(nl.getLength());</span><br><span class="line">   target.setSource(extractSource(collectionEle));</span><br><span class="line">   target.setElementTypeName(defaultElementType);</span><br><span class="line">   target.setMergeEnabled(parseMergeAttribute(collectionEle));</span><br><span class="line">   parseCollectionElements(nl, target, bd, defaultElementType);</span><br><span class="line">   <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体解析\&lt;list\&gt;集合元素，\&lt;array\&gt;、\&lt;list\&gt;和\&lt;set\&gt;都使用该方法解析</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseCollectionElements</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      NodeList elementNodes, Collection\&lt;Object\&gt; target, @Nullable BeanDefinition bd, String defaultElementType)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//遍历集合所有节点</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i \&lt; elementNodes.getLength(); i++) &#123;</span><br><span class="line">      Node node = elementNodes.item(i);</span><br><span class="line">      <span class="comment">//节点不是description节点</span></span><br><span class="line">      <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT)) &#123;</span><br><span class="line">         <span class="comment">//将解析的元素加入集合中，递归调用下一个子元素</span></span><br><span class="line">         target.add(parsePropertySubElement((Element) node, bd, defaultElementType));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过对 Spring Bean 配置信息转换的 Document 对象中的元素层层解析，Spring IOC 现在已经将 XML 形式定义的 Bean 配置信息转换为 Spring IOC 所识别的数据结构——BeanDefinition，它是 Bean 配 置信息中配置的 POJO 对象在 Spring IOC 容器中的映射，我们可以通过 AbstractBeanDefinition 为 入口，看到了 IOC 容器进行索引、查询和操作。</p>
<p>通过 Spring IOC 容器对 Bean 配置资源的解析后，IOC 容器大致完成了管理 Bean 对象的准备工作， 即初始化过程，但是最为重要的依赖注入还没有发生，现在在 IOC 容器中 BeanDefinition 存储的只是 一些静态信息，接下来需要向容器注册 Bean 定义信息才能全部完成 IOC 容器的初始化过程。</p>
<h3 id="16、分配注册策略"><a href="#16、分配注册策略" class="headerlink" title="16、分配注册策略"></a><strong>16、分配注册策略</strong></h3><p>让我们继续跟踪程序的执行顺序，接下来我们来分析 DefaultBeanDefinitionDocumentReader对Bean 定义转换的 Document 对象解析的流程中，在其 parseDefaultElement()方法中完成对Document 对象的解析后得到封装 BeanDefinition 的 BeanDefinitionHold 对象，然后调用BeanDefinitionReaderUtils 的 registerBeanDefinition() 方 法 向 IOC 容 器 注 册 解 析 的 Bean ， BeanDefinitionReaderUtils 的注册的源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register the given bean definition with the given bean factory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> definitionHolder the bean definition including name and aliases</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry the bean factory to register with</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException if registration failed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//将解析的BeanDefinitionHold注册到容器中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">   <span class="comment">//获取解析的BeanDefinition的名称</span></span><br><span class="line">   String beanName = definitionHolder.getBeanName();</span><br><span class="line">   <span class="comment">//向IOC容器注册BeanDefinition</span></span><br><span class="line">   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">   <span class="comment">//如果解析的BeanDefinition有别名，向容器为其注册别名</span></span><br><span class="line">   String[] aliases = definitionHolder.getAliases();</span><br><span class="line">   <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">         registry.registerAlias(beanName, alias);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用 BeanDefinitionReaderUtils 向 IOC 容器注册解析的 BeanDefinition 时，真正完成注册功能的是 DefaultListableBeanFactory。</p>
<h3 id="17、向容器注册"><a href="#17、向容器注册" class="headerlink" title="17、向容器注册"></a><strong>17、向容器注册</strong></h3><p>DefaultListableBeanFactory 中使用一个 HashMap 的集合对象存放 IOC 容器中注册解析的 BeanDefinition，向 IOC 容器注册的主要源码如下:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg07en9a4tj30f80pe45b.jpg" alt="image-20200621205411485"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Map of bean definition objects, keyed by bean name */</span></span><br><span class="line"><span class="comment">//存储注册信息的BeanDefinition</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map\&lt;String, BeanDefinition\&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap\&lt;\&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向IOC容器注册解析的BeanDefiniton</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">		Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);</span><br><span class="line">		Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//校验解析的BeanDefiniton</span></span><br><span class="line">		<span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">						<span class="string">"Validation of bean definition failed"</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		BeanDefinition oldBeanDefinition;</span><br><span class="line"></span><br><span class="line">		oldBeanDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">						<span class="string">"Cannot register bean definition ["</span> + beanDefinition + <span class="string">"] for bean '"</span> + beanName +</span><br><span class="line">						<span class="string">"': There is already ["</span> + oldBeanDefinition + <span class="string">"] bound."</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (oldBeanDefinition.getRole() \&lt; beanDefinition.getRole()) &#123;</span><br><span class="line">				<span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">					<span class="keyword">this</span>.logger.warn(<span class="string">"Overriding user-defined bean definition for bean '"</span> + beanName +</span><br><span class="line">							<span class="string">"' with a framework-generated bean definition: replacing ["</span> +</span><br><span class="line">							oldBeanDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">					<span class="keyword">this</span>.logger.info(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line">							<span class="string">"' with a different definition: replacing ["</span> + oldBeanDefinition +</span><br><span class="line">							<span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">					<span class="keyword">this</span>.logger.debug(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line">							<span class="string">"' with an equivalent definition: replacing ["</span> + oldBeanDefinition +</span><br><span class="line">							<span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">				<span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">				<span class="comment">//注册的过程中需要线程同步，以保证数据的一致性</span></span><br><span class="line">				<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">					<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">					List\&lt;String\&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList\&lt;\&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">					updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">					updatedDefinitions.add(beanName);</span><br><span class="line">					<span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">					<span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">						Set\&lt;String\&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet\&lt;\&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">						updatedSingletons.remove(beanName);</span><br><span class="line">						<span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Still in startup registration phase</span></span><br><span class="line">				<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">				<span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">				<span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//检查是否有同名的BeanDefinition已经在IOC容器中注册</span></span><br><span class="line">		<span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">			<span class="comment">//重置所有已经注册过的BeanDefinition的缓存</span></span><br><span class="line">			resetBeanDefinition(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>至此，Bean 配置信息中配置的 Bean 被解析过后，已经注册到 IOC 容器中，被容器管理起来，真正完 成了 IOC 容器初始化所做的全部工作。现在 IOC 容器中已经建立了整个 Bean 的配置信息，这些 BeanDefinition 信息已经可以使用，并且可以被检索，IOC 容器的作用就是对这些注册的 Bean 定义信 息进行处理和维护。这些的注册的 Bean 定义信息是 IOC 容器控制反转的基础，正是有了这些注册的数 据，容器才可以进行依赖注入。</p>
<h2 id="基于-Annotation-的-IOC-初始化"><a href="#基于-Annotation-的-IOC-初始化" class="headerlink" title="基于 Annotation 的 IOC 初始化"></a>基于 Annotation 的 IOC 初始化</h2><h3 id="Annotation-的前世今生"><a href="#Annotation-的前世今生" class="headerlink" title="Annotation 的前世今生"></a><strong>Annotation 的前世今生</strong></h3><p>从 Spring2.0 以后的版本中，Spring 也引入了基于注解(Annotation)方式的配置，注解(Annotation) 是 JDK1.5 中引入的一个新特性，用于简化 Bean 的配置，可以取代 XML 配置文件。开发人员对注解 (Annotation)的态度也是萝卜青菜各有所爱，个人认为注解可以大大简化配置，提高开发速度，但也给 后期维护增加了难度。目前来说 XML 方式发展的相对成熟，方便于统一管理。随着 Spring Boot 的兴起，基于注解的开发甚至实现了零配置。但作为个人的习惯而言，还是倾向于 XML 配置文件和注解 (Annotation)相互配合使用。Spring IOC 容器对于类级别的注解和类内部的注解分以下两种处理策略: </p>
<ol>
<li><p>类级别的注解:如@Component、@Repository、@Controller、@Service 以及 JavaEE6 的 @ManagedBean 和@Named 注解，都是添加在类上面的类级别注解，Spring 容器根据注解的过滤规 则扫描读取注解 Bean 定义类，并将其注册到 Spring IOC 容器中。</p>
</li>
<li><p>类内部的注解:如@Autowire、@Value、@Resource 以及 EJB 和 WebService 相关的注解等， 都是添加在类内部的字段或者方法上的类内部注解，SpringIOC 容器通过 Bean 后置注解处理器解析 Bean 内部的注解。下面将根据这两种处理策略，分别分析 Spring 处理注解相关的源码。</p>
</li>
</ol>
<h3 id="定位-Bean-扫描路径"><a href="#定位-Bean-扫描路径" class="headerlink" title="定位 Bean 扫描路径"></a><strong>定位 Bean 扫描路径</strong></h3><p>在 Spring 中 管 理 注 解 Bean 定 义 的 容 器 有 两 个 : AnnotationConfigApplicationContext 和 AnnotationConfigWebApplicationContex。这两个类是专门处理 Spring 注解方式配置的容器，直接 依赖于注解作为容器配置信息来源的 IOC 容器。AnnotationConfigWebApplicationContext 是 AnnotationConfigApplicationContext 的 Web 版本，两者的用法以及对注解的处理方式几乎没有差 别。现在我们以 AnnotationConfigApplicationContext 为例看看它的源码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationConfigApplicationContext</span> <span class="keyword">extends</span> <span class="title">GenericApplicationContext</span> <span class="keyword">implements</span> <span class="title">AnnotationConfigRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//保存一个读取注解的Bean定义读取器，并将其设置到容器中</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> AnnotatedBeanDefinitionReader reader;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//保存一个扫描指定类路径中注解Bean定义的扫描器，并将其设置到容器中</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ClassPathBeanDefinitionScanner scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Create a new AnnotationConfigApplicationContext that needs to be populated</span></span><br><span class="line"><span class="comment">    * through &#123;<span class="doctag">@link</span> #register&#125; calls and then manually &#123;<span class="doctag">@linkplain</span> #refresh refreshed&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//默认构造函数，初始化一个空容器，容器不包含任何 Bean 信息，需要在稍后通过调用其register()</span></span><br><span class="line">   <span class="comment">//方法注册配置类，并调用refresh()方法刷新容器，触发容器对注解Bean的载入、解析和注册过程</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Create a new AnnotationConfigApplicationContext with the given DefaultListableBeanFactory.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanFactory the DefaultListableBeanFactory instance to use for this context</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(beanFactory);</span><br><span class="line">      <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Create a new AnnotationConfigApplicationContext, deriving bean definitions</span></span><br><span class="line"><span class="comment">    * from the given annotated classes and automatically refreshing the context.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> annotatedClasses one or more annotated classes,</span></span><br><span class="line"><span class="comment">    * e.g. &#123;<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>&#125; classes</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//最常用的构造函数，通过将涉及到的配置类传递给该构造函数，以实现将相应配置类中的Bean自动注册到容器中</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class\&lt;?\&gt;... annotatedClasses)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>();</span><br><span class="line">      register(annotatedClasses);</span><br><span class="line">      refresh();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Create a new AnnotationConfigApplicationContext, scanning for bean definitions</span></span><br><span class="line"><span class="comment">    * in the given packages and automatically refreshing the context.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> basePackages the packages to check for annotated classes</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//该构造函数会自动扫描以给定的包及其子包下的所有类，并自动识别所有的Spring Bean，将其注册到容器中</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>();</span><br><span class="line">      scan(basePackages);</span><br><span class="line">      refresh();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;Delegates given environment to underlying &#123;<span class="doctag">@link</span> AnnotatedBeanDefinitionReader&#125;</span></span><br><span class="line"><span class="comment">    * and &#123;<span class="doctag">@link</span> ClassPathBeanDefinitionScanner&#125; members.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.setEnvironment(environment);</span><br><span class="line">      <span class="keyword">this</span>.reader.setEnvironment(environment);</span><br><span class="line">      <span class="keyword">this</span>.scanner.setEnvironment(environment);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Provide a custom &#123;<span class="doctag">@link</span> BeanNameGenerator&#125; for use with &#123;<span class="doctag">@link</span> AnnotatedBeanDefinitionReader&#125;</span></span><br><span class="line"><span class="comment">    * and/or &#123;<span class="doctag">@link</span> ClassPathBeanDefinitionScanner&#125;, if any.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;Default is &#123;<span class="doctag">@link</span> org.springframework.context.annotation.AnnotationBeanNameGenerator&#125;.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;Any call to this method must occur prior to calls to &#123;<span class="doctag">@link</span> #register(Class...)&#125;</span></span><br><span class="line"><span class="comment">    * and/or &#123;<span class="doctag">@link</span> #scan(String...)&#125;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> AnnotatedBeanDefinitionReader#setBeanNameGenerator</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> ClassPathBeanDefinitionScanner#setBeanNameGenerator</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//为容器的注解Bean读取器和注解Bean扫描器设置Bean名称产生器</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanNameGenerator</span><span class="params">(BeanNameGenerator beanNameGenerator)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.reader.setBeanNameGenerator(beanNameGenerator);</span><br><span class="line">      <span class="keyword">this</span>.scanner.setBeanNameGenerator(beanNameGenerator);</span><br><span class="line">      getBeanFactory().registerSingleton(</span><br><span class="line">            AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set the &#123;<span class="doctag">@link</span> ScopeMetadataResolver&#125; to use for detected bean classes.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;The default is an &#123;<span class="doctag">@link</span> AnnotationScopeMetadataResolver&#125;.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;Any call to this method must occur prior to calls to &#123;<span class="doctag">@link</span> #register(Class...)&#125;</span></span><br><span class="line"><span class="comment">    * and/or &#123;<span class="doctag">@link</span> #scan(String...)&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//为容器的注解Bean读取器和注解Bean扫描器设置作用范围元信息解析器</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScopeMetadataResolver</span><span class="params">(ScopeMetadataResolver scopeMetadataResolver)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.reader.setScopeMetadataResolver(scopeMetadataResolver);</span><br><span class="line">      <span class="keyword">this</span>.scanner.setScopeMetadataResolver(scopeMetadataResolver);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">   <span class="comment">// Implementation of AnnotationConfigRegistry</span></span><br><span class="line">   <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Register one or more annotated classes to be processed.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;Note that &#123;<span class="doctag">@link</span> #refresh()&#125; must be called in order for the context</span></span><br><span class="line"><span class="comment">    * to fully process the new classes.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> annotatedClasses one or more annotated classes,</span></span><br><span class="line"><span class="comment">    * e.g. &#123;<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>&#125; classes</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #scan(String...)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #refresh()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//为容器注册一个要被处理的注解Bean，新注册的Bean，必须手动调用容器的</span></span><br><span class="line">   <span class="comment">//refresh()方法刷新容器，触发容器对新注册的Bean的处理</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class\&lt;?\&gt;... annotatedClasses)</span> </span>&#123;</span><br><span class="line">      Assert.notEmpty(annotatedClasses, <span class="string">"At least one annotated class must be specified"</span>);</span><br><span class="line">      <span class="keyword">this</span>.reader.register(annotatedClasses);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Perform a scan within the specified base packages.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;Note that &#123;<span class="doctag">@link</span> #refresh()&#125; must be called in order for the context</span></span><br><span class="line"><span class="comment">    * to fully process the new classes.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> basePackages the packages to check for annotated classes</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #register(Class...)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #refresh()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//扫描指定包路径及其子包下的注解类，为了使新添加的类被处理，必须手动调用</span></span><br><span class="line">   <span class="comment">//refresh()方法刷新容器</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">      Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">      <span class="keyword">this</span>.scanner.scan(basePackages);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">   <span class="comment">// Convenient methods for registering individual beans</span></span><br><span class="line">   <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Register a bean from the given bean class, deriving its metadata from</span></span><br><span class="line"><span class="comment">    * class-declared annotations, and optionally providing explicit constructor</span></span><br><span class="line"><span class="comment">    * arguments for consideration in the autowiring process.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;The bean name will be generated according to annotated component rules.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> annotatedClass the class of the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> constructorArguments argument values to be fed into Spring's</span></span><br><span class="line"><span class="comment">    * constructor resolution algorithm, resolving either all arguments or just</span></span><br><span class="line"><span class="comment">    * specific ones, with the rest to be resolved through regular autowiring</span></span><br><span class="line"><span class="comment">    * (may be &#123;<span class="doctag">@code</span> null&#125; or empty)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> \&lt;T\&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class\&lt;T\&gt; annotatedClass, Object... constructorArguments)</span> </span>&#123;</span><br><span class="line">      registerBean(<span class="keyword">null</span>, annotatedClass, constructorArguments);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Register a bean from the given bean class, deriving its metadata from</span></span><br><span class="line"><span class="comment">    * class-declared annotations, and optionally providing explicit constructor</span></span><br><span class="line"><span class="comment">    * arguments for consideration in the autowiring process.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanName the name of the bean (may be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> annotatedClass the class of the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> constructorArguments argument values to be fed into Spring's</span></span><br><span class="line"><span class="comment">    * constructor resolution algorithm, resolving either all arguments or just</span></span><br><span class="line"><span class="comment">    * specific ones, with the rest to be resolved through regular autowiring</span></span><br><span class="line"><span class="comment">    * (may be &#123;<span class="doctag">@code</span> null&#125; or empty)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> \&lt;T\&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(@Nullable String beanName, Class\&lt;T\&gt; annotatedClass, Object... constructorArguments)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.reader.doRegisterBean(annotatedClass, <span class="keyword">null</span>, beanName, <span class="keyword">null</span>,</span><br><span class="line">            bd -\&gt; &#123;</span><br><span class="line">               <span class="keyword">for</span> (Object arg : constructorArguments) &#123;</span><br><span class="line">                  bd.getConstructorArgumentValues().addGenericArgumentValue(arg);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> \&lt;T\&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(@Nullable String beanName, Class\&lt;T\&gt; beanClass, @Nullable Supplier\&lt;T\&gt; supplier,</span></span></span><br><span class="line"><span class="function"><span class="params">         BeanDefinitionCustomizer... customizers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.reader.doRegisterBean(beanClass, supplier, beanName, <span class="keyword">null</span>, customizers);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的源码分析，我们可以看啊到 Spring 对注解的处理分为两种方式:</p>
<ol>
<li><p>直接将注解 Bean 注册到容器中 可以在初始化容器时注册;也可以在容器创建之后手动调用注册方法向容器注册，然后通过手动刷新容 器，使得容器对注册的注解 Bean 进行处理。</p>
</li>
<li><p>通过扫描指定的包及其子包下的所有类 在初始化注解容器时指定要自动扫描的路径，如果容器创建以后向给定路径动态添加了注解 Bean，则 需要手动调用容器扫描的方法，然后手动刷新容器，使得容器对所注册的 Bean 进行处理。 接下来，将会对两种处理方式详细分析其实现过程。</p>
</li>
</ol>
<h3 id="读取-Annotation-元数据"><a href="#读取-Annotation-元数据" class="headerlink" title="读取 Annotation 元数据"></a><strong>读取 Annotation 元数据</strong></h3><p>当创建注解处理容器时，如果传入的初始参数是具体的注解 Bean 定义类时，注解容器读取并注册。</p>
<p><strong>1)、AnnotationConfigApplicationContext 通过调用注解 Bean 定义读取器</strong></p>
<p>AnnotatedBeanDefinitionReader 的 register()方法向容器注册指定的注解 Bean，注解 Bean 定义读 取器向容器注册注解 Bean 的源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register one or more annotated classes to be processed.</span></span><br><span class="line"><span class="comment"> * \&lt;p\&gt;Calls to &#123;<span class="doctag">@code</span> register&#125; are idempotent; adding the same</span></span><br><span class="line"><span class="comment"> * annotated class more than once has no additional effect.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> annotatedClasses one or more annotated classes,</span></span><br><span class="line"><span class="comment"> * e.g. &#123;<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>&#125; classes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//注册多个注解Bean定义类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class\&lt;?\&gt;... annotatedClasses)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (Class\&lt;?\&gt; annotatedClass : annotatedClasses) &#123;</span><br><span class="line">      registerBean(annotatedClass);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register a bean from the given bean class, deriving its metadata from</span></span><br><span class="line"><span class="comment"> * class-declared annotations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> annotatedClass the class of the bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//注册一个注解Bean定义类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class\&lt;?\&gt; annotatedClass)</span> </span>&#123;</span><br><span class="line">   doRegisterBean(annotatedClass, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register a bean from the given bean class, deriving its metadata from</span></span><br><span class="line"><span class="comment"> * class-declared annotations, using the given supplier for obtaining a new</span></span><br><span class="line"><span class="comment"> * instance (possibly declared as a lambda expression or method reference).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> annotatedClass the class of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> instanceSupplier a callback for creating an instance of the bean</span></span><br><span class="line"><span class="comment"> * (may be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> \&lt;T\&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class\&lt;T\&gt; annotatedClass, @Nullable Supplier\&lt;T\&gt; instanceSupplier)</span> </span>&#123;</span><br><span class="line">   doRegisterBean(annotatedClass, instanceSupplier, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register a bean from the given bean class, deriving its metadata from</span></span><br><span class="line"><span class="comment"> * class-declared annotations, using the given supplier for obtaining a new</span></span><br><span class="line"><span class="comment"> * instance (possibly declared as a lambda expression or method reference).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> annotatedClass the class of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name an explicit name for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> instanceSupplier a callback for creating an instance of the bean</span></span><br><span class="line"><span class="comment"> * (may be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> \&lt;T\&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class\&lt;T\&gt; annotatedClass, String name, @Nullable Supplier\&lt;T\&gt; instanceSupplier)</span> </span>&#123;</span><br><span class="line">   doRegisterBean(annotatedClass, instanceSupplier, name, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register a bean from the given bean class, deriving its metadata from</span></span><br><span class="line"><span class="comment"> * class-declared annotations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> annotatedClass the class of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> qualifiers specific qualifier annotations to consider,</span></span><br><span class="line"><span class="comment"> * in addition to qualifiers at the bean class level</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//Bean定义读取器注册注解Bean定义的入口方法</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class\&lt;?\&gt; annotatedClass, Class\&lt;? extends Annotation\&gt;... qualifiers)</span> </span>&#123;</span><br><span class="line">   doRegisterBean(annotatedClass, <span class="keyword">null</span>, <span class="keyword">null</span>, qualifiers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register a bean from the given bean class, deriving its metadata from</span></span><br><span class="line"><span class="comment"> * class-declared annotations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> annotatedClass the class of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name an explicit name for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> qualifiers specific qualifier annotations to consider,</span></span><br><span class="line"><span class="comment"> * in addition to qualifiers at the bean class level</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//Bean定义读取器向容器注册注解Bean定义类</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class\&lt;?\&gt; annotatedClass, String name, Class\&lt;? extends Annotation\&gt;... qualifiers)</span> </span>&#123;</span><br><span class="line">   doRegisterBean(annotatedClass, <span class="keyword">null</span>, name, qualifiers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register a bean from the given bean class, deriving its metadata from</span></span><br><span class="line"><span class="comment"> * class-declared annotations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> annotatedClass the class of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> instanceSupplier a callback for creating an instance of the bean</span></span><br><span class="line"><span class="comment"> * (may be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name an explicit name for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> qualifiers specific qualifier annotations to consider, if any,</span></span><br><span class="line"><span class="comment"> * in addition to qualifiers at the bean class level</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> definitionCustomizers one or more callbacks for customizing the</span></span><br><span class="line"><span class="comment"> * factory's &#123;<span class="doctag">@link</span> BeanDefinition&#125;, e.g. setting a lazy-init or primary flag</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//Bean定义读取器向容器注册注解Bean定义类</span></span><br><span class="line">\&lt;T\&gt; <span class="function"><span class="keyword">void</span> <span class="title">doRegisterBean</span><span class="params">(Class\&lt;T\&gt; annotatedClass, @Nullable Supplier\&lt;T\&gt; instanceSupplier, @Nullable String name,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable Class\&lt;? extends Annotation\&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//根据指定的注解Bean定义类，创建Spring容器中对注解Bean的封装的数据结构</span></span><br><span class="line">   AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(annotatedClass);</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   abd.setInstanceSupplier(instanceSupplier);</span><br><span class="line">   <span class="comment">//解析注解Bean定义的作用域，若@Scope("prototype")，则Bean为原型类型；</span></span><br><span class="line">   <span class="comment">//若@Scope("singleton")，则Bean为单态类型</span></span><br><span class="line">   ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">   <span class="comment">//为注解Bean定义设置作用域</span></span><br><span class="line">   abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">   <span class="comment">//为注解Bean定义生成Bean名称</span></span><br><span class="line">   String beanName = (name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry));</span><br><span class="line"></span><br><span class="line">   <span class="comment">//处理注解Bean定义中的通用注解</span></span><br><span class="line">   AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">   <span class="comment">//如果在向容器注册注解Bean定义时，使用了额外的限定符注解，则解析限定符注解。</span></span><br><span class="line">   <span class="comment">//主要是配置的关于autowiring自动依赖注入装配的限定条件，即@Qualifier注解</span></span><br><span class="line">   <span class="comment">//Spring自动依赖注入装配默认是按类型装配，如果使用@Qualifier则按名称</span></span><br><span class="line">   <span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Class\&lt;? extends Annotation\&gt; qualifier : qualifiers) &#123;</span><br><span class="line">         <span class="comment">//如果配置了@Primary注解，设置该Bean为autowiring自动依赖注入装//配时的首选</span></span><br><span class="line">         <span class="keyword">if</span> (Primary<span class="class">.<span class="keyword">class</span> </span>== qualifier) &#123;</span><br><span class="line">            abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//如果配置了@Lazy注解，则设置该Bean为非延迟初始化，如果没有配置，</span></span><br><span class="line">         <span class="comment">//则该Bean为预实例化</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (Lazy<span class="class">.<span class="keyword">class</span> </span>== qualifier) &#123;</span><br><span class="line">            abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//如果使用了除@Primary和@Lazy以外的其他注解，则为该Bean添加一</span></span><br><span class="line">         <span class="comment">//个autowiring自动依赖注入装配限定符，该Bean在进autowiring</span></span><br><span class="line">         <span class="comment">//自动依赖注入装配时，根据名称装配限定符指定的Bean</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (BeanDefinitionCustomizer customizer : definitionCustomizers) &#123;</span><br><span class="line">      customizer.customize(abd);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建一个指定Bean名称的Bean定义对象，封装注解Bean定义类数据</span></span><br><span class="line">   BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line">   <span class="comment">//根据注解Bean定义类中配置的作用域，创建相应的代理对象</span></span><br><span class="line">   definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">   <span class="comment">//向IOC容器注册注解Bean类定义对象</span></span><br><span class="line">   BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的源码我们可以看出，注册注解 Bean 定义类的基本步骤: </p>
<ol>
<li><p>需要使用注解元数据解析器解析注解 Bean 中关于作用域的配置。</p>
</li>
<li><p>使用 AnnotationConfigUtils 的 processCommonDefinitionAnnotations()方法处理注解 Bean 定 义类中通用的注解。</p>
</li>
<li><p>使用 AnnotationConfigUtils 的 applyScopedProxyMode()方法创建对于作用域的代理对象。 d、通过 BeanDefinitionReaderUtils 向容器注册 Bean。</p>
</li>
</ol>
<p>下面我们继续分析这 4 步的具体实现过程</p>
<p><strong>2)、AnnotationScopeMetadataResolver 解析作用域元数据</strong></p>
<p>AnnotationScopeMetadataResolver 通过 resolveScopeMetadata()方法解析注解 Bean 定义类的作 用域元信息，即判断注册的 Bean 是原生类型(prototype)还是单态(singleton)类型，其源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解析注解Bean定义类中的作用域元信息</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ScopeMetadata <span class="title">resolveScopeMetadata</span><span class="params">(BeanDefinition definition)</span> </span>&#123;</span><br><span class="line">   ScopeMetadata metadata = <span class="keyword">new</span> ScopeMetadata();</span><br><span class="line">   <span class="keyword">if</span> (definition <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">      AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition;</span><br><span class="line">      <span class="comment">//从注解Bean定义类的属性中查找属性为”Scope”的值，即@Scope注解的值</span></span><br><span class="line">      <span class="comment">//annDef.getMetadata().getAnnotationAttributes()方法将Bean</span></span><br><span class="line">      <span class="comment">//中所有的注解和注解的值存放在一个map集合中</span></span><br><span class="line">      AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(</span><br><span class="line">            annDef.getMetadata(), <span class="keyword">this</span>.scopeAnnotationType);</span><br><span class="line">      <span class="comment">//将获取到的@Scope注解的值设置到要返回的对象中</span></span><br><span class="line">      <span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">         metadata.setScopeName(attributes.getString(<span class="string">"value"</span>));</span><br><span class="line">         <span class="comment">//获取@Scope注解中的proxyMode属性值，在创建代理对象时会用到</span></span><br><span class="line">         ScopedProxyMode proxyMode = attributes.getEnum(<span class="string">"proxyMode"</span>);</span><br><span class="line">         <span class="comment">//如果@Scope的proxyMode属性为DEFAULT或者NO</span></span><br><span class="line">         <span class="keyword">if</span> (proxyMode == ScopedProxyMode.DEFAULT) &#123;</span><br><span class="line">            <span class="comment">//设置proxyMode为NO</span></span><br><span class="line">            proxyMode = <span class="keyword">this</span>.defaultProxyMode;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//为返回的元数据设置proxyMode</span></span><br><span class="line">         metadata.setScopedProxyMode(proxyMode);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//返回解析的作用域元信息对象</span></span><br><span class="line">   <span class="keyword">return</span> metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中的 annDef.getMetadata().getAnnotationAttributes()方法就是获取对象中指定类型的注 解的值。</p>
<p> <strong>3)、AnnotationConfigUtils 处理注解 Bean 定义类中的通用注解</strong></p>
<p> AnnotationConfigUtils 类的 processCommonDefinitionAnnotations()在向容器注册 Bean 之前，首 先对注解 Bean 定义类中的通用 Spring 注解进行处理，源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processCommonDefinitionAnnotations</span><span class="params">(AnnotatedBeanDefinition abd)</span> </span>&#123;</span><br><span class="line">   processCommonDefinitionAnnotations(abd, abd.getMetadata());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理Bean定义中通用注解</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processCommonDefinitionAnnotations</span><span class="params">(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">   AnnotationAttributes lazy = attributesFor(metadata, Lazy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   <span class="comment">//如果Bean定义中有@Lazy注解，则将该Bean预实例化属性设置为@lazy注解的值</span></span><br><span class="line">   <span class="keyword">if</span> (lazy != <span class="keyword">null</span>) &#123;</span><br><span class="line">      abd.setLazyInit(lazy.getBoolean(<span class="string">"value"</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (abd.getMetadata() != metadata) &#123;</span><br><span class="line">      lazy = attributesFor(abd.getMetadata(), Lazy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">if</span> (lazy != <span class="keyword">null</span>) &#123;</span><br><span class="line">         abd.setLazyInit(lazy.getBoolean(<span class="string">"value"</span>));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果Bean定义中有@Primary注解，则为该Bean设置为autowiring自动依赖注入装配的首选对象</span></span><br><span class="line">   <span class="keyword">if</span> (metadata.isAnnotated(Primary<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())) </span>&#123;</span><br><span class="line">      abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果Bean定义中有@ DependsOn注解，则为该Bean设置所依赖的Bean名称，</span></span><br><span class="line">   <span class="comment">//容器将确保在实例化该Bean之前首先实例化所依赖的Bean</span></span><br><span class="line">   AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">      abd.setDependsOn(dependsOn.getStringArray(<span class="string">"value"</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (abd <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">      AbstractBeanDefinition absBd = (AbstractBeanDefinition) abd;</span><br><span class="line">      AnnotationAttributes role = attributesFor(metadata, Role<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">if</span> (role != <span class="keyword">null</span>) &#123;</span><br><span class="line">         absBd.setRole(role.getNumber(<span class="string">"value"</span>).intValue());</span><br><span class="line">      &#125;</span><br><span class="line">      AnnotationAttributes description = attributesFor(metadata, Description<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">if</span> (description != <span class="keyword">null</span>) &#123;</span><br><span class="line">         absBd.setDescription(description.getString(<span class="string">"value"</span>));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据作用域为Bean应用引用的代码模式</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BeanDefinitionHolder <span class="title">applyScopedProxyMode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ScopeMetadata metadata, BeanDefinitionHolder definition, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取注解Bean定义类中@Scope注解的proxyMode属性值</span></span><br><span class="line">   ScopedProxyMode scopedProxyMode = metadata.getScopedProxyMode();</span><br><span class="line">   <span class="comment">//如果配置的@Scope注解的proxyMode属性值为NO，则不应用代理模式</span></span><br><span class="line">   <span class="keyword">if</span> (scopedProxyMode.equals(ScopedProxyMode.NO)) &#123;</span><br><span class="line">      <span class="keyword">return</span> definition;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//获取配置的@Scope注解的proxyMode属性值，如果为TARGET_CLASS</span></span><br><span class="line">   <span class="comment">//则返回true，如果为INTERFACES，则返回false</span></span><br><span class="line">   <span class="keyword">boolean</span> proxyTargetClass = scopedProxyMode.equals(ScopedProxyMode.TARGET_CLASS);</span><br><span class="line">   <span class="comment">//为注册的Bean创建相应模式的代理对象</span></span><br><span class="line">   <span class="keyword">return</span> ScopedProxyCreator.createScopedProxy(definition, registry, proxyTargetClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段为 Bean 引用创建相应模式的代理，这里不做深入的分析。</p>
<p><strong>5)、BeanDefinitionReaderUtils 向容器注册 Bean</strong></p>
<p>BeanDefinitionReaderUtils 主要是校验 BeanDefinition 信息，然后将 Bean 添加到容器中一个管理BeanDefinition 的 HashMap 中。</p>
<h3 id="扫描指定包并解析为-BeanDefinition"><a href="#扫描指定包并解析为-BeanDefinition" class="headerlink" title="扫描指定包并解析为 BeanDefinition"></a><strong>扫描指定包并解析为 BeanDefinition</strong></h3><p>当创建注解处理容器时，如果传入的初始参数是注解 Bean 定义类所在的包时，注解容器将扫描给定的 包及其子包，将扫描到的注解 Bean 定义载入并注册。</p>
<p><strong>1)、ClassPathBeanDefinitionScanner 扫描给定的包及其子包</strong></p>
<p>AnnotationConfigApplicationContext 通 过 调 用 类 路 径 Bean 定 义 扫 描 器 ClassPathBeanDefinitionScanner 扫描给定包及其子包下的所有类，主要源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathBeanDefinitionScanner</span> <span class="keyword">extends</span> <span class="title">ClassPathScanningCandidateComponentProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> BeanDefinitionRegistry registry;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> BeanDefinitionDefaults beanDefinitionDefaults = <span class="keyword">new</span> BeanDefinitionDefaults();</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String[] autowireCandidatePatterns;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> BeanNameGenerator beanNameGenerator = <span class="keyword">new</span> AnnotationBeanNameGenerator();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> ScopeMetadataResolver scopeMetadataResolver = <span class="keyword">new</span> AnnotationScopeMetadataResolver();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> includeAnnotationConfig = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Create a new &#123;<span class="doctag">@code</span> ClassPathBeanDefinitionScanner&#125; for the given bean factory.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> registry the &#123;<span class="doctag">@code</span> BeanFactory&#125; to load bean definitions into, in the form</span></span><br><span class="line"><span class="comment">    * of a &#123;<span class="doctag">@code</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//创建一个类路径Bean定义扫描器</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(registry, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Create a new &#123;<span class="doctag">@code</span> ClassPathBeanDefinitionScanner&#125; for the given bean factory.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;If the passed-in bean factory does not only implement the</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> BeanDefinitionRegistry&#125; interface but also the &#123;<span class="doctag">@code</span> ResourceLoader&#125;</span></span><br><span class="line"><span class="comment">    * interface, it will be used as default &#123;<span class="doctag">@code</span> ResourceLoader&#125; as well. This will</span></span><br><span class="line"><span class="comment">    * usually be the case for &#123;<span class="doctag">@link</span> org.springframework.context.ApplicationContext&#125;</span></span><br><span class="line"><span class="comment">    * implementations.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;If given a plain &#123;<span class="doctag">@code</span> BeanDefinitionRegistry&#125;, the default &#123;<span class="doctag">@code</span> ResourceLoader&#125;</span></span><br><span class="line"><span class="comment">    * will be a &#123;<span class="doctag">@link</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver&#125;.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;If the passed-in bean factory also implements &#123;<span class="doctag">@link</span> EnvironmentCapable&#125; its</span></span><br><span class="line"><span class="comment">    * environment will be used by this reader.  Otherwise, the reader will initialize and</span></span><br><span class="line"><span class="comment">    * use a &#123;<span class="doctag">@link</span> org.springframework.core.env.StandardEnvironment&#125;. All</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> ApplicationContext&#125; implementations are &#123;<span class="doctag">@code</span> EnvironmentCapable&#125;, while</span></span><br><span class="line"><span class="comment">    * normal &#123;<span class="doctag">@code</span> BeanFactory&#125; implementations are not.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> registry the &#123;<span class="doctag">@code</span> BeanFactory&#125; to load bean definitions into, in the form</span></span><br><span class="line"><span class="comment">    * of a &#123;<span class="doctag">@code</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> useDefaultFilters whether to include the default filters for the</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> org.springframework.stereotype.Component <span class="doctag">@Component</span>&#125;,</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> org.springframework.stereotype.Repository <span class="doctag">@Repository</span>&#125;,</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> org.springframework.stereotype.Service <span class="doctag">@Service</span>&#125;, and</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> org.springframework.stereotype.Controller <span class="doctag">@Controller</span>&#125; stereotype annotations</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setResourceLoader</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setEnvironment</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//为容器创建一个类路径Bean定义扫描器，并指定是否使用默认的扫描过滤规则。</span></span><br><span class="line">   <span class="comment">//即Spring默认扫描配置：@Component、@Repository、@Service、@Controller</span></span><br><span class="line">   <span class="comment">//注解的Bean，同时也支持JavaEE6的@ManagedBean和JSR-330的@Named注解</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(registry, useDefaultFilters, getOrCreateEnvironment(registry));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Create a new &#123;<span class="doctag">@code</span> ClassPathBeanDefinitionScanner&#125; for the given bean factory and</span></span><br><span class="line"><span class="comment">    * using the given &#123;<span class="doctag">@link</span> Environment&#125; when evaluating bean definition profile metadata.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;If the passed-in bean factory does not only implement the &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">    * BeanDefinitionRegistry&#125; interface but also the &#123;<span class="doctag">@link</span> ResourceLoader&#125; interface, it</span></span><br><span class="line"><span class="comment">    * will be used as default &#123;<span class="doctag">@code</span> ResourceLoader&#125; as well. This will usually be the</span></span><br><span class="line"><span class="comment">    * case for &#123;<span class="doctag">@link</span> org.springframework.context.ApplicationContext&#125; implementations.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;If given a plain &#123;<span class="doctag">@code</span> BeanDefinitionRegistry&#125;, the default &#123;<span class="doctag">@code</span> ResourceLoader&#125;</span></span><br><span class="line"><span class="comment">    * will be a &#123;<span class="doctag">@link</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver&#125;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> registry the &#123;<span class="doctag">@code</span> BeanFactory&#125; to load bean definitions into, in the form</span></span><br><span class="line"><span class="comment">    * of a &#123;<span class="doctag">@code</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> useDefaultFilters whether to include the default filters for the</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> org.springframework.stereotype.Component <span class="doctag">@Component</span>&#125;,</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> org.springframework.stereotype.Repository <span class="doctag">@Repository</span>&#125;,</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> org.springframework.stereotype.Service <span class="doctag">@Service</span>&#125;, and</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> org.springframework.stereotype.Controller <span class="doctag">@Controller</span>&#125; stereotype annotations</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> environment the Spring &#123;<span class="doctag">@link</span> Environment&#125; to use when evaluating bean</span></span><br><span class="line"><span class="comment">    * definition profile metadata</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setResourceLoader</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters,</span></span></span><br><span class="line"><span class="function"><span class="params">         Environment environment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>(registry, useDefaultFilters, environment,</span><br><span class="line">            (registry <span class="keyword">instanceof</span> ResourceLoader ? (ResourceLoader) registry : <span class="keyword">null</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Create a new &#123;<span class="doctag">@code</span> ClassPathBeanDefinitionScanner&#125; for the given bean factory and</span></span><br><span class="line"><span class="comment">    * using the given &#123;<span class="doctag">@link</span> Environment&#125; when evaluating bean definition profile metadata.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> registry the &#123;<span class="doctag">@code</span> BeanFactory&#125; to load bean definitions into, in the form</span></span><br><span class="line"><span class="comment">    * of a &#123;<span class="doctag">@code</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> useDefaultFilters whether to include the default filters for the</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> org.springframework.stereotype.Component <span class="doctag">@Component</span>&#125;,</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> org.springframework.stereotype.Repository <span class="doctag">@Repository</span>&#125;,</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> org.springframework.stereotype.Service <span class="doctag">@Service</span>&#125;, and</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> org.springframework.stereotype.Controller <span class="doctag">@Controller</span>&#125; stereotype annotations</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> environment the Spring &#123;<span class="doctag">@link</span> Environment&#125; to use when evaluating bean</span></span><br><span class="line"><span class="comment">    * definition profile metadata</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> resourceLoader the &#123;<span class="doctag">@link</span> ResourceLoader&#125; to use</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 4.3.6</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters,</span></span></span><br><span class="line"><span class="function"><span class="params">         Environment environment, @Nullable ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">      <span class="comment">//为容器设置加载Bean定义的注册器</span></span><br><span class="line">      <span class="keyword">this</span>.registry = registry;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (useDefaultFilters) &#123;</span><br><span class="line">         registerDefaultFilters();</span><br><span class="line">      &#125;</span><br><span class="line">      setEnvironment(environment);</span><br><span class="line">      <span class="comment">//为容器设置资源加载器</span></span><br><span class="line">      setResourceLoader(resourceLoader);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the BeanDefinitionRegistry that this scanner operates on.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> BeanDefinitionRegistry <span class="title">getRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.registry;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set the defaults to use for detected beans.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> BeanDefinitionDefaults</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanDefinitionDefaults</span><span class="params">(@Nullable BeanDefinitionDefaults beanDefinitionDefaults)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.beanDefinitionDefaults =</span><br><span class="line">            (beanDefinitionDefaults != <span class="keyword">null</span> ? beanDefinitionDefaults : <span class="keyword">new</span> BeanDefinitionDefaults());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the defaults to use for detected beans (never &#123;<span class="doctag">@code</span> null&#125;).</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 4.1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> BeanDefinitionDefaults <span class="title">getBeanDefinitionDefaults</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.beanDefinitionDefaults;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set the name-matching patterns for determining autowire candidates.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> autowireCandidatePatterns the patterns to match against</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAutowireCandidatePatterns</span><span class="params">(@Nullable String... autowireCandidatePatterns)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.autowireCandidatePatterns = autowireCandidatePatterns;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set the BeanNameGenerator to use for detected bean classes.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;Default is a &#123;<span class="doctag">@link</span> AnnotationBeanNameGenerator&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanNameGenerator</span><span class="params">(@Nullable BeanNameGenerator beanNameGenerator)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.beanNameGenerator = (beanNameGenerator != <span class="keyword">null</span> ? beanNameGenerator : <span class="keyword">new</span> AnnotationBeanNameGenerator());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set the ScopeMetadataResolver to use for detected bean classes.</span></span><br><span class="line"><span class="comment">    * Note that this will override any custom "scopedProxyMode" setting.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;The default is an &#123;<span class="doctag">@link</span> AnnotationScopeMetadataResolver&#125;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setScopedProxyMode</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScopeMetadataResolver</span><span class="params">(@Nullable ScopeMetadataResolver scopeMetadataResolver)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.scopeMetadataResolver =</span><br><span class="line">            (scopeMetadataResolver != <span class="keyword">null</span> ? scopeMetadataResolver : <span class="keyword">new</span> AnnotationScopeMetadataResolver());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Specify the proxy behavior for non-singleton scoped beans.</span></span><br><span class="line"><span class="comment">    * Note that this will override any custom "scopeMetadataResolver" setting.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;The default is &#123;<span class="doctag">@link</span> ScopedProxyMode#NO&#125;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setScopeMetadataResolver</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScopedProxyMode</span><span class="params">(ScopedProxyMode scopedProxyMode)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.scopeMetadataResolver = <span class="keyword">new</span> AnnotationScopeMetadataResolver(scopedProxyMode);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Specify whether to register annotation config post-processors.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;The default is to register the post-processors. Turn this off</span></span><br><span class="line"><span class="comment">    * to be able to ignore the annotations or to process them differently.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIncludeAnnotationConfig</span><span class="params">(<span class="keyword">boolean</span> includeAnnotationConfig)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.includeAnnotationConfig = includeAnnotationConfig;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Perform a scan within the specified base packages.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> basePackages the packages to check for annotated classes</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> number of beans registered</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//调用类路径Bean定义扫描器入口方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//获取容器中已经注册的Bean个数</span></span><br><span class="line">      <span class="keyword">int</span> beanCountAtScanStart = <span class="keyword">this</span>.registry.getBeanDefinitionCount();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//启动扫描器扫描给定包</span></span><br><span class="line">      doScan(basePackages);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Register annotation config processors, if necessary.</span></span><br><span class="line">      <span class="comment">//注册注解配置(Annotation config)处理器</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.includeAnnotationConfig) &#123;</span><br><span class="line">         AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//返回注册的Bean个数</span></span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Perform a scan within the specified base packages,</span></span><br><span class="line"><span class="comment">    * returning the registered bean definitions.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;This method does \&lt;i\&gt;not\&lt;/i\&gt; register an annotation config processor</span></span><br><span class="line"><span class="comment">    * but rather leaves this up to the caller.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> basePackages the packages to check for annotated classes</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> set of beans registered if any for tooling registration purposes (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//类路径Bean定义扫描器扫描给定包及其子包</span></span><br><span class="line">   <span class="keyword">protected</span> Set\&lt;BeanDefinitionHolder\&gt; doScan(String... basePackages) &#123;</span><br><span class="line">      Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">      <span class="comment">//创建一个集合，存放扫描到Bean定义的封装类</span></span><br><span class="line">      Set\&lt;BeanDefinitionHolder\&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet\&lt;\&gt;();</span><br><span class="line">      <span class="comment">//遍历扫描所有给定的包</span></span><br><span class="line">      <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">         <span class="comment">//调用父类ClassPathScanningCandidateComponentProvider的方法</span></span><br><span class="line">         <span class="comment">//扫描给定类路径，获取符合条件的Bean定义</span></span><br><span class="line">         Set\&lt;BeanDefinition\&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">         <span class="comment">//遍历扫描到的Bean</span></span><br><span class="line">         <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">            <span class="comment">//获取Bean定义类中@Scope注解的值，即获取Bean的作用域</span></span><br><span class="line">            ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">            <span class="comment">//为Bean设置注解配置的作用域</span></span><br><span class="line">            candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">            <span class="comment">//为Bean生成名称</span></span><br><span class="line">            String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line">            <span class="comment">//如果扫描到的Bean不是Spring的注解Bean，则为Bean设置默认值，</span></span><br><span class="line">            <span class="comment">//设置Bean的自动依赖注入装配属性等</span></span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">               postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果扫描到的Bean是Spring的注解Bean，则处理其通用的Spring注解</span></span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">               <span class="comment">//处理注解Bean中通用的注解，在分析注解Bean定义类读取器时已经分析过</span></span><br><span class="line">               AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据Bean名称检查指定的Bean是否需要在容器中注册，或者在容器中冲突</span></span><br><span class="line">            <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">               BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">               <span class="comment">//根据注解中配置的作用域，为Bean应用相应的代理模式</span></span><br><span class="line">               definitionHolder =</span><br><span class="line">                     AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">               beanDefinitions.add(definitionHolder);</span><br><span class="line">               <span class="comment">//向容器注册扫描到的Bean</span></span><br><span class="line">               registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Apply further settings to the given bean definition,</span></span><br><span class="line"><span class="comment">    * beyond the contents retrieved from scanning the component class.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanDefinition the scanned bean definition</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanName the generated bean name for the given bean</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinition</span><span class="params">(AbstractBeanDefinition beanDefinition, String beanName)</span> </span>&#123;</span><br><span class="line">      beanDefinition.applyDefaults(<span class="keyword">this</span>.beanDefinitionDefaults);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.autowireCandidatePatterns != <span class="keyword">null</span>) &#123;</span><br><span class="line">         beanDefinition.setAutowireCandidate(PatternMatchUtils.simpleMatch(<span class="keyword">this</span>.autowireCandidatePatterns, beanName));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Register the specified bean with the given registry.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;Can be overridden in subclasses, e.g. to adapt the registration</span></span><br><span class="line"><span class="comment">    * process or to register further bean definitions for each scanned bean.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> definitionHolder the bean definition plus bean name for the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> registry the BeanDefinitionRegistry to register the bean with</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">      BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Check the given candidate's bean name, determining whether the corresponding</span></span><br><span class="line"><span class="comment">    * bean definition needs to be registered or conflicts with an existing definition.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanName the suggested name for the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanDefinition the corresponding bean definition</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the bean can be registered as-is;</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> false&#125; if it should be skipped because there is an</span></span><br><span class="line"><span class="comment">    * existing, compatible bean definition for the specified name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> ConflictingBeanDefinitionException if an existing, incompatible</span></span><br><span class="line"><span class="comment">    * bean definition has been found for the specified name</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">checkCandidate</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.registry.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      BeanDefinition existingDef = <span class="keyword">this</span>.registry.getBeanDefinition(beanName);</span><br><span class="line">      BeanDefinition originatingDef = existingDef.getOriginatingBeanDefinition();</span><br><span class="line">      <span class="keyword">if</span> (originatingDef != <span class="keyword">null</span>) &#123;</span><br><span class="line">         existingDef = originatingDef;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isCompatible(beanDefinition, existingDef)) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ConflictingBeanDefinitionException(<span class="string">"Annotation-specified bean name '"</span> + beanName +</span><br><span class="line">            <span class="string">"' for bean class ["</span> + beanDefinition.getBeanClassName() + <span class="string">"] conflicts with existing, "</span> +</span><br><span class="line">            <span class="string">"non-compatible bean definition of same name and class ["</span> + existingDef.getBeanClassName() + <span class="string">"]"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Determine whether the given new bean definition is compatible with</span></span><br><span class="line"><span class="comment">    * the given existing bean definition.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;The default implementation considers them as compatible when the existing</span></span><br><span class="line"><span class="comment">    * bean definition comes from the same source or from a non-scanning source.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> newDefinition the new bean definition, originated from scanning</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> existingDefinition the existing bean definition, potentially an</span></span><br><span class="line"><span class="comment">    * explicitly defined one or a previously generated one from scanning</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> whether the definitions are considered as compatible, with the</span></span><br><span class="line"><span class="comment">    * new definition to be skipped in favor of the existing definition</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCompatible</span><span class="params">(BeanDefinition newDefinition, BeanDefinition existingDefinition)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (!(existingDefinition <span class="keyword">instanceof</span> ScannedGenericBeanDefinition) ||  <span class="comment">// explicitly registered overriding bean</span></span><br><span class="line">            (newDefinition.getSource() != <span class="keyword">null</span> &amp;&amp; newDefinition.getSource().equals(existingDefinition.getSource())) ||  <span class="comment">// scanned same file twice</span></span><br><span class="line">            newDefinition.equals(existingDefinition));  <span class="comment">// scanned equivalent class twice</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Get the Environment from the given registry if possible, otherwise return a new</span></span><br><span class="line"><span class="comment">    * StandardEnvironment.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Environment <span class="title">getOrCreateEnvironment</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">      Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">      <span class="keyword">if</span> (registry <span class="keyword">instanceof</span> EnvironmentCapable) &#123;</span><br><span class="line">         <span class="keyword">return</span> ((EnvironmentCapable) registry).getEnvironment();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类路径 Bean 定义扫描器 ClassPathBeanDefinitionScanner 主要通过 findCandidateComponents() 方法调用其父类 ClassPathScanningCandidateComponentProvider 类来扫描获取给定包及其子包下 的类。</p>
<p><strong>2)、ClassPathScanningCandidateComponentProvider 扫描给定包及其子包的类</strong></p>
<p>ClassPathScanningCandidateComponentProvider 类的 findCandidateComponents()方法具体实 现扫描给定类路径包的功能，主要源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathScanningCandidateComponentProvider</span> <span class="keyword">implements</span> <span class="title">EnvironmentCapable</span>, <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_RESOURCE_PATTERN = <span class="string">"**/*.class"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String resourcePattern = DEFAULT_RESOURCE_PATTERN;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//保存过滤规则要包含的注解，即Spring默认的@Component、@Repository、@Service、</span></span><br><span class="line">   <span class="comment">//@Controller注解的Bean，以及JavaEE6的@ManagedBean和JSR-330的@Named注解</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> List\&lt;TypeFilter\&gt; includeFilters = <span class="keyword">new</span> LinkedList\&lt;\&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//保存过滤规则要排除的注解</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> List\&lt;TypeFilter\&gt; excludeFilters = <span class="keyword">new</span> LinkedList\&lt;\&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> ConditionEvaluator conditionEvaluator;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> ResourcePatternResolver resourcePatternResolver;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> MetadataReaderFactory metadataReaderFactory;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> CandidateComponentsIndex componentsIndex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Protected constructor for flexible subclass initialization.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 4.3.6</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">ClassPathScanningCandidateComponentProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Create a ClassPathScanningCandidateComponentProvider with a &#123;<span class="doctag">@link</span> StandardEnvironment&#125;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> useDefaultFilters whether to register the default filters for the</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> Component <span class="doctag">@Component</span>&#125;, &#123;<span class="doctag">@link</span> Repository <span class="doctag">@Repository</span>&#125;,</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> Service <span class="doctag">@Service</span>&#125;, and &#123;<span class="doctag">@link</span> Controller <span class="doctag">@Controller</span>&#125;</span></span><br><span class="line"><span class="comment">    * stereotype annotations</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #registerDefaultFilters()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//构造方法，该方法在子类ClassPathBeanDefinitionScanner的构造方法中被调用</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ClassPathScanningCandidateComponentProvider</span><span class="params">(<span class="keyword">boolean</span> useDefaultFilters)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(useDefaultFilters, <span class="keyword">new</span> StandardEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Create a ClassPathScanningCandidateComponentProvider with the given &#123;<span class="doctag">@link</span> Environment&#125;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> useDefaultFilters whether to register the default filters for the</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> Component <span class="doctag">@Component</span>&#125;, &#123;<span class="doctag">@link</span> Repository <span class="doctag">@Repository</span>&#125;,</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> Service <span class="doctag">@Service</span>&#125;, and &#123;<span class="doctag">@link</span> Controller <span class="doctag">@Controller</span>&#125;</span></span><br><span class="line"><span class="comment">    * stereotype annotations</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> environment the Environment to use</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #registerDefaultFilters()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ClassPathScanningCandidateComponentProvider</span><span class="params">(<span class="keyword">boolean</span> useDefaultFilters, Environment environment)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//如果使用Spring默认的过滤规则，则向容器注册过滤规则</span></span><br><span class="line">      <span class="keyword">if</span> (useDefaultFilters) &#123;</span><br><span class="line">         registerDefaultFilters();</span><br><span class="line">      &#125;</span><br><span class="line">      setEnvironment(environment);</span><br><span class="line">      setResourceLoader(<span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set the resource pattern to use when scanning the classpath.</span></span><br><span class="line"><span class="comment">    * This value will be appended to each base package name.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #findCandidateComponents(String)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #DEFAULT_RESOURCE_PATTERN</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourcePattern</span><span class="params">(String resourcePattern)</span> </span>&#123;</span><br><span class="line">      Assert.notNull(resourcePattern, <span class="string">"'resourcePattern' must not be null"</span>);</span><br><span class="line">      <span class="keyword">this</span>.resourcePattern = resourcePattern;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Add an include type filter to the \&lt;i\&gt;end\&lt;/i\&gt; of the inclusion list.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addIncludeFilter</span><span class="params">(TypeFilter includeFilter)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.includeFilters.add(includeFilter);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Add an exclude type filter to the \&lt;i\&gt;front\&lt;/i\&gt; of the exclusion list.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addExcludeFilter</span><span class="params">(TypeFilter excludeFilter)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.excludeFilters.add(<span class="number">0</span>, excludeFilter);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Reset the configured type filters.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> useDefaultFilters whether to re-register the default filters for</span></span><br><span class="line"><span class="comment">    * the &#123;<span class="doctag">@link</span> Component <span class="doctag">@Component</span>&#125;, &#123;<span class="doctag">@link</span> Repository <span class="doctag">@Repository</span>&#125;,</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> Service <span class="doctag">@Service</span>&#125;, and &#123;<span class="doctag">@link</span> Controller <span class="doctag">@Controller</span>&#125;</span></span><br><span class="line"><span class="comment">    * stereotype annotations</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #registerDefaultFilters()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resetFilters</span><span class="params">(<span class="keyword">boolean</span> useDefaultFilters)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.includeFilters.clear();</span><br><span class="line">      <span class="keyword">this</span>.excludeFilters.clear();</span><br><span class="line">      <span class="keyword">if</span> (useDefaultFilters) &#123;</span><br><span class="line">         registerDefaultFilters();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Register the default filter for &#123;<span class="doctag">@link</span> Component <span class="doctag">@Component</span>&#125;.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;This will implicitly register all annotations that have the</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> Component <span class="doctag">@Component</span>&#125; meta-annotation including the</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> Repository <span class="doctag">@Repository</span>&#125;, &#123;<span class="doctag">@link</span> Service <span class="doctag">@Service</span>&#125;, and</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> Controller <span class="doctag">@Controller</span>&#125; stereotype annotations.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;Also supports Java EE 6's &#123;<span class="doctag">@link</span> javax.annotation.ManagedBean&#125; and</span></span><br><span class="line"><span class="comment">    * JSR-330's &#123;<span class="doctag">@link</span> javax.inject.Named&#125; annotations, if available.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//向容器注册过滤规则</span></span><br><span class="line">   <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerDefaultFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//向要包含的过滤规则中添加@Component注解类，注意Spring中@Repository</span></span><br><span class="line">      <span class="comment">//@Service和@Controller都是Component，因为这些注解都添加了@Component注解</span></span><br><span class="line">      <span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(Component<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">      <span class="comment">//获取当前类的类加载器</span></span><br><span class="line">      ClassLoader cl = ClassPathScanningCandidateComponentProvider<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//向要包含的过滤规则添加JavaEE6的@ManagedBean注解</span></span><br><span class="line">         <span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">               ((Class\&lt;? extends Annotation\&gt;) ClassUtils.forName(<span class="string">"javax.annotation.ManagedBean"</span>, cl)), <span class="keyword">false</span>));</span><br><span class="line">         logger.debug(<span class="string">"JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">         <span class="comment">// JSR-250 1.1 API (as included in Java EE 6) not available - simply skip.</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//向要包含的过滤规则添加@Named注解</span></span><br><span class="line">         <span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">               ((Class\&lt;? extends Annotation\&gt;) ClassUtils.forName(<span class="string">"javax.inject.Named"</span>, cl)), <span class="keyword">false</span>));</span><br><span class="line">         logger.debug(<span class="string">"JSR-330 'javax.inject.Named' annotation found and supported for component scanning"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">         <span class="comment">// JSR-330 API not available - simply skip.</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set the Environment to use when resolving placeholders and evaluating</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> Conditional <span class="doctag">@Conditional</span>&#125;-annotated component classes.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;The default is a &#123;<span class="doctag">@link</span> StandardEnvironment&#125;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> environment the Environment to use</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">      Assert.notNull(environment, <span class="string">"Environment must not be null"</span>);</span><br><span class="line">      <span class="keyword">this</span>.environment = environment;</span><br><span class="line">      <span class="keyword">this</span>.conditionEvaluator = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Environment <span class="title">getEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.environment = <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.environment;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the &#123;<span class="doctag">@link</span> BeanDefinitionRegistry&#125; used by this scanner, if any.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> BeanDefinitionRegistry <span class="title">getRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set the &#123;<span class="doctag">@link</span> ResourceLoader&#125; to use for resource locations.</span></span><br><span class="line"><span class="comment">    * This will typically be a &#123;<span class="doctag">@link</span> ResourcePatternResolver&#125; implementation.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;Default is a &#123;<span class="doctag">@code</span> PathMatchingResourcePatternResolver&#125;, also capable of</span></span><br><span class="line"><span class="comment">    * resource pattern resolving through the &#123;<span class="doctag">@code</span> ResourcePatternResolver&#125; interface.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> org.springframework.core.io.support.ResourcePatternResolver</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(@Nullable ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.resourcePatternResolver = ResourcePatternUtils.getResourcePatternResolver(resourceLoader);</span><br><span class="line">      <span class="keyword">this</span>.metadataReaderFactory = <span class="keyword">new</span> CachingMetadataReaderFactory(resourceLoader);</span><br><span class="line">      <span class="keyword">this</span>.componentsIndex = CandidateComponentsIndexLoader.loadIndex(<span class="keyword">this</span>.resourcePatternResolver.getClassLoader());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the ResourceLoader that this component provider uses.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> getResourcePatternResolver();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> ResourcePatternResolver <span class="title">getResourcePatternResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.resourcePatternResolver == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.resourcePatternResolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.resourcePatternResolver;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set the &#123;<span class="doctag">@link</span> MetadataReaderFactory&#125; to use.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;Default is a &#123;<span class="doctag">@link</span> CachingMetadataReaderFactory&#125; for the specified</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@linkplain</span> #setResourceLoader resource loader&#125;.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;Call this setter method \&lt;i\&gt;after\&lt;/i\&gt; &#123;<span class="doctag">@link</span> #setResourceLoader&#125; in order</span></span><br><span class="line"><span class="comment">    * for the given MetadataReaderFactory to override the default factory.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMetadataReaderFactory</span><span class="params">(MetadataReaderFactory metadataReaderFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.metadataReaderFactory = metadataReaderFactory;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the MetadataReaderFactory used by this component provider.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> MetadataReaderFactory <span class="title">getMetadataReaderFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.metadataReaderFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.metadataReaderFactory = <span class="keyword">new</span> CachingMetadataReaderFactory();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.metadataReaderFactory;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Scan the class path for candidate components.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> basePackage the package to check for annotated classes</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> a corresponding Set of autodetected bean definitions</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//扫描给定类路径的包</span></span><br><span class="line">   <span class="keyword">public</span> Set\&lt;BeanDefinition\&gt; findCandidateComponents(String basePackage) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.componentsIndex != <span class="keyword">null</span> &amp;&amp; indexSupportsIncludeFilters()) &#123;</span><br><span class="line">         <span class="keyword">return</span> addCandidateComponentsFromIndex(<span class="keyword">this</span>.componentsIndex, basePackage);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> scanCandidateComponents(basePackage);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Determine if the index can be used by this instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the index is available and the configuration of this</span></span><br><span class="line"><span class="comment">    * instance is supported by it, &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">indexSupportsIncludeFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (TypeFilter includeFilter : <span class="keyword">this</span>.includeFilters) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!indexSupportsIncludeFilter(includeFilter)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Determine if the specified include &#123;<span class="doctag">@link</span> TypeFilter&#125; is supported by the index.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> filter the filter to check</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> whether the index supports this include filter</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #extractStereotype(TypeFilter)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">indexSupportsIncludeFilter</span><span class="params">(TypeFilter filter)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (filter <span class="keyword">instanceof</span> AnnotationTypeFilter) &#123;</span><br><span class="line">         Class\&lt;? extends Annotation\&gt; annotation = ((AnnotationTypeFilter) filter).getAnnotationType();</span><br><span class="line">         <span class="keyword">return</span> (AnnotationUtils.isAnnotationDeclaredLocally(Indexed<span class="class">.<span class="keyword">class</span>, <span class="title">annotation</span>) ||</span></span><br><span class="line">               annotation.getName().startsWith("javax."));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (filter <span class="keyword">instanceof</span> AssignableTypeFilter) &#123;</span><br><span class="line">         Class\&lt;?\&gt; target = ((AssignableTypeFilter) filter).getTargetType();</span><br><span class="line">         <span class="keyword">return</span> AnnotationUtils.isAnnotationDeclaredLocally(Indexed<span class="class">.<span class="keyword">class</span>, <span class="title">target</span>)</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Extract the stereotype to use for the specified compatible filter.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> filter the filter to handle</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the stereotype in the index matching this filter</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #indexSupportsIncludeFilter(TypeFilter)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> String <span class="title">extractStereotype</span><span class="params">(TypeFilter filter)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (filter <span class="keyword">instanceof</span> AnnotationTypeFilter) &#123;</span><br><span class="line">         <span class="keyword">return</span> ((AnnotationTypeFilter) filter).getAnnotationType().getName();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (filter <span class="keyword">instanceof</span> AssignableTypeFilter) &#123;</span><br><span class="line">         <span class="keyword">return</span> ((AssignableTypeFilter) filter).getTargetType().getName();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Set\&lt;BeanDefinition\&gt; addCandidateComponentsFromIndex(CandidateComponentsIndex index, String basePackage) &#123;</span><br><span class="line">      <span class="comment">//创建存储扫描到的类的集合</span></span><br><span class="line">      Set\&lt;BeanDefinition\&gt; candidates = <span class="keyword">new</span> LinkedHashSet\&lt;\&gt;();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         Set\&lt;String\&gt; types = <span class="keyword">new</span> HashSet\&lt;\&gt;();</span><br><span class="line">         <span class="keyword">for</span> (TypeFilter filter : <span class="keyword">this</span>.includeFilters) &#123;</span><br><span class="line">            String stereotype = extractStereotype(filter);</span><br><span class="line">            <span class="keyword">if</span> (stereotype == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Failed to extract stereotype from "</span>+ filter);</span><br><span class="line">            &#125;</span><br><span class="line">            types.addAll(index.getCandidateTypes(basePackage, stereotype));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">boolean</span> traceEnabled = logger.isTraceEnabled();</span><br><span class="line">         <span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line">         <span class="keyword">for</span> (String type : types) &#123;</span><br><span class="line">            <span class="comment">//为指定资源获取元数据读取器，元信息读取器通过汇编(ASM)读//取资源元信息</span></span><br><span class="line">            MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(type);</span><br><span class="line">            <span class="comment">//如果扫描到的类符合容器配置的过滤规则</span></span><br><span class="line">            <span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">               <span class="comment">//通过汇编(ASM)读取资源字节码中的Bean定义元信息</span></span><br><span class="line">               AnnotatedGenericBeanDefinition sbd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(</span><br><span class="line">                     metadataReader.getAnnotationMetadata());</span><br><span class="line">               <span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">                     logger.debug(<span class="string">"Using candidate component class from index: "</span> + type);</span><br><span class="line">                  &#125;</span><br><span class="line">                  candidates.add(sbd);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">                     logger.debug(<span class="string">"Ignored because not a concrete top-level class: "</span> + type);</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">                  logger.trace(<span class="string">"Ignored because matching an exclude filter: "</span> + type);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"I/O failure during classpath scanning"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> candidates;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Set\&lt;BeanDefinition\&gt; scanCandidateComponents(String basePackage) &#123;</span><br><span class="line">      Set\&lt;BeanDefinition\&gt; candidates = <span class="keyword">new</span> LinkedHashSet\&lt;\&gt;();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">               resolveBasePackage(basePackage) + <span class="string">'/'</span> + <span class="keyword">this</span>.resourcePattern;</span><br><span class="line">         Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br><span class="line">         <span class="keyword">boolean</span> traceEnabled = logger.isTraceEnabled();</span><br><span class="line">         <span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line">         <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">            <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">               logger.trace(<span class="string">"Scanning "</span> + resource);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resource.isReadable()) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);</span><br><span class="line">                  <span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">                     ScannedGenericBeanDefinition sbd = <span class="keyword">new</span> ScannedGenericBeanDefinition(metadataReader);</span><br><span class="line">                     sbd.setResource(resource);</span><br><span class="line">                     sbd.setSource(resource);</span><br><span class="line">                     <span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">                           logger.debug(<span class="string">"Identified candidate component class: "</span> + resource);</span><br><span class="line">                        &#125;</span><br><span class="line">                        candidates.add(sbd);</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">                           logger.debug(<span class="string">"Ignored because not a concrete top-level class: "</span> + resource);</span><br><span class="line">                        &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">                        logger.trace(<span class="string">"Ignored because not matching any filter: "</span> + resource);</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                        <span class="string">"Failed to read candidate component class: "</span> + resource, ex);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">                  logger.trace(<span class="string">"Ignored because not readable: "</span> + resource);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"I/O failure during classpath scanning"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> candidates;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Resolve the specified base package into a pattern specification for</span></span><br><span class="line"><span class="comment">    * the package search path.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;The default implementation resolves placeholders against system properties,</span></span><br><span class="line"><span class="comment">    * and converts a "."-based package path to a "/"-based resource path.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> basePackage the base package as specified by the user</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the pattern specification to be used for package searching</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> String <span class="title">resolveBasePackage</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> ClassUtils.convertClassNameToResourcePath(getEnvironment().resolveRequiredPlaceholders(basePackage));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Determine whether the given class does not match any exclude filter</span></span><br><span class="line"><span class="comment">    * and does match at least one include filter.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> metadataReader the ASM ClassReader for the class</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> whether the class qualifies as a candidate component</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//判断元信息读取器读取的类是否符合容器定义的注解过滤规则</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(MetadataReader metadataReader)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">//如果读取的类的注解在排除注解过滤规则中，返回false</span></span><br><span class="line">      <span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.excludeFilters) &#123;</span><br><span class="line">         <span class="keyword">if</span> (tf.match(metadataReader, getMetadataReaderFactory())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果读取的类的注解在包含的注解的过滤规则中，则返回ture</span></span><br><span class="line">      <span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.includeFilters) &#123;</span><br><span class="line">         <span class="keyword">if</span> (tf.match(metadataReader, getMetadataReaderFactory())) &#123;</span><br><span class="line">            <span class="keyword">return</span> isConditionMatch(metadataReader);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果读取的类的注解既不在排除规则，也不在包含规则中，则返回false</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Determine whether the given class is a candidate component based on any</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> <span class="doctag">@Conditional</span>&#125; annotations.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> metadataReader the ASM ClassReader for the class</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> whether the class qualifies as a candidate component</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isConditionMatch</span><span class="params">(MetadataReader metadataReader)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.conditionEvaluator =</span><br><span class="line">               <span class="keyword">new</span> ConditionEvaluator(getRegistry(), <span class="keyword">this</span>.environment, <span class="keyword">this</span>.resourcePatternResolver);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> !<span class="keyword">this</span>.conditionEvaluator.shouldSkip(metadataReader.getAnnotationMetadata());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Determine whether the given bean definition qualifies as candidate.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;The default implementation checks whether the class is not an interface</span></span><br><span class="line"><span class="comment">    * and not dependent on an enclosing class.</span></span><br><span class="line"><span class="comment">    * \&lt;p\&gt;Can be overridden in subclasses.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanDefinition the bean definition to check</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> whether the bean definition qualifies as a candidate component</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">      AnnotationMetadata metadata = beanDefinition.getMetadata();</span><br><span class="line">      <span class="keyword">return</span> (metadata.isIndependent() &amp;&amp; (metadata.isConcrete() ||</span><br><span class="line">            (metadata.isAbstract() &amp;&amp; metadata.hasAnnotatedMethods(Lookup<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))))</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Clear the local metadata cache, if any, removing all cached class metadata.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line">         <span class="comment">// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span></span><br><span class="line">         <span class="comment">// for a shared cache since it'll be cleared by the ApplicationContext.</span></span><br><span class="line">         ((CachingMetadataReaderFactory) <span class="keyword">this</span>.metadataReaderFactory).clearCache();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册注解-BeanDefinition"><a href="#注册注解-BeanDefinition" class="headerlink" title="注册注解 BeanDefinition"></a>注册注解 BeanDefinition</h3><p>AnnotationConfigWebApplicationContext 是 AnnotationConfigApplicationContext 的 Web 版， 它们对于注解 Bean 的注册和扫描是基本相同的，但是 AnnotationConfigWebApplicationContext 对注解 Bean 定义的载入稍有不同，AnnotationConfigWebApplicationContext 注入注解 Bean 定义 源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//载入注解Bean定义资源</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//为容器设置注解Bean定义读取器</span></span><br><span class="line">   AnnotatedBeanDefinitionReader reader = getAnnotatedBeanDefinitionReader(beanFactory);</span><br><span class="line">   <span class="comment">//为容器设置类路径Bean定义扫描器</span></span><br><span class="line">   ClassPathBeanDefinitionScanner scanner = getClassPathBeanDefinitionScanner(beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取容器的Bean名称生成器</span></span><br><span class="line">   BeanNameGenerator beanNameGenerator = getBeanNameGenerator();</span><br><span class="line">   <span class="comment">//为注解Bean定义读取器和类路径扫描器设置Bean名称生成器</span></span><br><span class="line">   <span class="keyword">if</span> (beanNameGenerator != <span class="keyword">null</span>) &#123;</span><br><span class="line">      reader.setBeanNameGenerator(beanNameGenerator);</span><br><span class="line">      scanner.setBeanNameGenerator(beanNameGenerator);</span><br><span class="line">      beanFactory.registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取容器的作用域元信息解析器</span></span><br><span class="line">   ScopeMetadataResolver scopeMetadataResolver = getScopeMetadataResolver();</span><br><span class="line">   <span class="comment">//为注解Bean定义读取器和类路径扫描器设置作用域元信息解析器</span></span><br><span class="line">   <span class="keyword">if</span> (scopeMetadataResolver != <span class="keyword">null</span>) &#123;</span><br><span class="line">      reader.setScopeMetadataResolver(scopeMetadataResolver);</span><br><span class="line">      scanner.setScopeMetadataResolver(scopeMetadataResolver);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!<span class="keyword">this</span>.annotatedClasses.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">         logger.info(<span class="string">"Registering annotated classes: ["</span> +</span><br><span class="line">               StringUtils.collectionToCommaDelimitedString(<span class="keyword">this</span>.annotatedClasses) + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      reader.register(<span class="keyword">this</span>.annotatedClasses.toArray(<span class="keyword">new</span> Class\&lt;?\&gt;[<span class="keyword">this</span>.annotatedClasses.size()]));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!<span class="keyword">this</span>.basePackages.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">         logger.info(<span class="string">"Scanning base packages: ["</span> +</span><br><span class="line">               StringUtils.collectionToCommaDelimitedString(<span class="keyword">this</span>.basePackages) + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      scanner.scan(<span class="keyword">this</span>.basePackages.toArray(<span class="keyword">new</span> String[<span class="keyword">this</span>.basePackages.size()]));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取容器定义的Bean定义资源路径</span></span><br><span class="line">   String[] configLocations = getConfigLocations();</span><br><span class="line">   <span class="comment">//如果定位的Bean定义资源路径不为空</span></span><br><span class="line">   <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (String configLocation : configLocations) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//使用当前容器的类加载器加载定位路径的字节码类文件</span></span><br><span class="line">            Class\&lt;?\&gt; clazz = ClassUtils.forName(configLocation, getClassLoader());</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">               logger.info(<span class="string">"Successfully resolved class for ["</span> + configLocation + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            reader.register(clazz);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">               logger.debug(<span class="string">"Could not load class for config location ["</span> + configLocation +</span><br><span class="line">                     <span class="string">"] - trying package scan. "</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果容器类加载器加载定义路径的Bean定义资源失败</span></span><br><span class="line">            <span class="comment">//则启用容器类路径扫描器扫描给定路径包及其子包中的类</span></span><br><span class="line">            <span class="keyword">int</span> count = scanner.scan(configLocation);</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                  logger.info(<span class="string">"No annotated classes found for specified class/package ["</span> + configLocation + <span class="string">"]"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                  logger.info(<span class="string">"Found "</span> + count + <span class="string">" annotated classes in package ["</span> + configLocation + <span class="string">"]"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是解析和注入注解配置资源的全过程分析。</p>
<h2 id="IOC-容器初始化小结"><a href="#IOC-容器初始化小结" class="headerlink" title="IOC 容器初始化小结"></a>IOC 容器初始化小结</h2><p>现在通过上面的代码，总结一下 IOC 容器初始化的基本步骤:<br> 1、初始化的入口在容器实现中的 refresh()调用来完成。<br> 2、对 Bean 定义载入 IOC 容器使用的方法是 loadBeanDefinition(),<br> 其中的大致过程如下:通过 ResourceLoader 来完成资源文件位置的定位，DefaultResourceLoader 是默认的实现，同时上下文本身就给出了 ResourceLoader 的实现，可以从类路径，文件系统,URL 等 方式来定为资源位置。如果是 XmlBeanFactory 作为 IOC 容器，那么需要为它指定 Bean 定义的资源， 也就是说 Bean 定义文件时通过抽象成 Resource 来被 IOC 容器处理的，容器通过 BeanDefinitionReader 来完成定义信息的解析和 Bean 信息的注册,往往使用的是XmlBeanDefinitionReader 来解析 Bean 的 XML 定义文件-实际的处理过程是委托给 BeanDefinitionParserDelegate 来完成的，从而得到 bean 的定义信息，这些信息在 Spring 中使用 BeanDefinition 对象来表示-这个名字可以让我们想到 loadBeanDefinition(),registerBeanDefinition() 这些相关方法。它们都是为处理 BeanDefinitin 服务的，容器解析得到 BeanDefinition 以后，需要把 它在 IOC 容器中注册，这由 IOC 实现 BeanDefinitionRegistry 接口来实现。注册过程就是在 IOC 容器 内部维护的一个 HashMap 来保存得到的 BeanDefinition 的过程。这个 HashMap 是 IOC 容器持有 Bean 信息的场所，以后对 Bean 的操作都是围绕这个 HashMap 来实现的。</p>
<p>然后我们就可以通过 BeanFactory 和 ApplicationContext 来享受到 Spring IOC 的服务了,在使用 IOC 容器的时候，我们注意到除了少量粘合代码，绝大多数以正确 IOC 风格编写的应用程序代码完全不用关 心如何到达工厂，因为容器将把这些对象与容器管理的其他对象钩在一起。基本的策略是把工厂放到已 知的地方，最好是放在对预期使用的上下文有意义的地方，以及代码将实际需要访问工厂的地方。Spring 本身提供了对声明式载入 web 应用程序用法的应用程序上下文,并将其存储在 ServletContext 中的框架 实现。</p>
<p>以下是容器初始化全过程的时序图:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg087c713vj31lv0u0mzd.jpg" alt="一步一步手绘Spring IOC运行时序图"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg100kca1lj31di0u07wi.jpg" alt="基于XML的IOC容器初始化"></p>
]]></content>
      <categories>
        <category>spring源码解读</category>
      </categories>
      <tags>
        <tag>spring-ioc</tag>
      </tags>
  </entry>
</search>
