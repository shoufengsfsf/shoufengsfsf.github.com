<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Semaphore信号量</title>
    <url>/2020/06/18/Semaphore%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
    <content><![CDATA[<h1 id="Semaphore信号量"><a href="#Semaphore信号量" class="headerlink" title="Semaphore信号量"></a>Semaphore信号量</h1><p>Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore 可以用来构建一些对象池，资源池之类的，比如数据库连接池</p>
<p>实现互斥锁（计数器为 1）</p>
<p>我们也可以创建计数为 1 的 Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。</p>
<p><strong>代码实现</strong></p>
<p>它的用法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个计数阈值为 5 的信号量对象</span></span><br><span class="line"><span class="comment">// 只能 5 个线程同时访问</span></span><br><span class="line">Semaphore semp = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">try</span> &#123; <span class="comment">// 申请许可</span></span><br><span class="line">semp.acquire();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line"><span class="number">121623125152125125</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 释放许可</span></span><br><span class="line">semp.release();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Semaphore-与-ReentrantLock"><a href="#Semaphore-与-ReentrantLock" class="headerlink" title="Semaphore 与 ReentrantLock"></a><strong>Semaphore</strong> <strong>与</strong> <strong>ReentrantLock</strong></h2><p>Semaphore 基本能完成 ReentrantLock 的所有工作，使用方法也与之类似，通过 acquire()与release()方法来获得和释放临界资源。经实测，Semaphone.acquire()方法默认为可响应中断锁，与 ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被Thread.interrupt()方法中断。</p>
<p>此外，Semaphore 也实现了可轮询的锁请求与定时锁的功能，除了方法名 tryAcquire 与 tryLock不同，其使用方法与 ReentrantLock 几乎一致。Semaphore 也提供了公平与非公平锁的机制，也可在构造函数中进行设定。</p>
<p>Semaphore 的锁释放操作也由手动进行，因此与 ReentrantLock 一样，为避免线程因抛出异常而无法正常释放锁的情况发生，释放锁的操作也必须在 finally 代码块中完成。</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>ReentrantLock</title>
    <url>/2020/06/18/ReentrantLock/</url>
    <content><![CDATA[<h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><strong>ReentrantLock</strong></h1><p>ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。</p>
<h2 id="Lock-接口的主要方法"><a href="#Lock-接口的主要方法" class="headerlink" title="Lock 接口的主要方法"></a><strong>Lock</strong> <strong>接口的主要方法</strong></h2><ol>
<li><p>void lock(): 执行此方法时, 如果锁处于空闲状态, 当前线程将获取到锁. 相反, 如果锁已经被其他线程持有, 将禁用当前线程, 直到当前线程获取到锁.</p>
</li>
<li><p>boolean tryLock()：如果锁可用, 则获取锁, 并立即返回 true, 否则返回 false. 该方法和lock()的区别在于, tryLock()只是”试图”获取锁, 如果锁不可用, 不会导致当前线程被禁用, 当前线程仍然继续往下执行代码. 而 lock()方法则是一定要获取到锁, 如果锁不可用, 就一直等待, 在未获得锁之前,当前线程并不继续向下执行. </p>
</li>
<li><p>void unlock()：执行此方法时, 当前线程将释放持有的锁. 锁只能由持有者释放, 如果线程并不持有锁, 却执行该方法, 可能导致异常的发生.</p>
</li>
<li><p>Condition newCondition()：条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的 await()方法，而调用后，当前线程将缩放锁。</p>
</li>
<li><p>getHoldCount() ：查询当前线程保持此锁的次数，也就是执行此线程执行 lock 方法的次数。</p>
</li>
<li><p>getQueueLength（）：返回正等待获取此锁的线程估计数，比如启动 10 个线程，1 个线程获得锁，此时返回的是 9</p>
</li>
<li><p>getWaitQueueLength：（Condition condition）返回等待与此锁相关的给定条件的线程估计数。比如 10 个线程，用同一个 condition 对象，并且此时这 10 个线程都执行了condition 对象的 await 方法，那么此时执行此方法返回 10</p>
</li>
<li><p>hasWaiters(Condition condition)：查询是否有线程等待与此锁有关的给定条件</p>
</li>
</ol>
<p>(condition)，对于指定 contidion 对象，有多少线程执行了 condition.await 方法</p>
<ol start="9">
<li><p>hasQueuedThread(Thread thread)：查询给定线程是否等待获取此锁</p>
</li>
<li><p>hasQueuedThreads()：是否有线程等待此锁</p>
</li>
<li><p>isFair()：该锁是否公平锁</p>
</li>
<li><p>isHeldByCurrentThread()： 当前线程是否保持锁锁定，线程的执行 lock 方法的前后分别是 false 和 true</p>
</li>
<li><p>isLock()：此锁是否有任意线程占用</p>
</li>
<li><p>lockInterruptibly（）：如果当前线程未被中断，获取锁</p>
</li>
<li><p>tryLock（）：尝试获得锁，仅在调用时锁未被线程占用，获得锁</p>
</li>
<li><p>tryLock(long timeout TimeUnit unit)：如果锁在给定等待时间内没有被另一个线程保持，则获取该锁。</p>
</li>
</ol>
<h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a><strong>非公平锁</strong></h2><p>JVM 按随机、就近原则分配锁的机制则称为不公平锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式，默认为非公平锁。非公平锁实际执行的效率要远远超出公平锁，除非程序有特殊需要，否则最常用非公平锁的分配机制。</p>
<h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a><strong>公平锁</strong></h2><p>公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式来定义公平锁。</p>
<h2 id="ReentrantLock-与-synchronized"><a href="#ReentrantLock-与-synchronized" class="headerlink" title="ReentrantLock 与 synchronized"></a><strong>ReentrantLock</strong> <strong>与</strong> <strong>synchronized</strong></h2><ol>
<li><p>ReentrantLock 通过方法 lock()与 unlock()来进行加锁与解锁操作，与 synchronized 会 被 JVM 自动解锁机制不同，ReentrantLock 加锁后需要手动进行解锁。为了避免程序出现异常而无法正常解锁的情况，使用 ReentrantLock 必须在 finally 控制块中进行解锁操作。</p>
</li>
<li><p>ReentrantLock 相比 synchronized 的优势是可中断、公平锁、多个锁。这种情况下需要使用 ReentrantLock。</p>
</li>
</ol>
<h3 id="ReentrantLock-实现"><a href="#ReentrantLock-实现" class="headerlink" title="ReentrantLock 实现"></a><strong>ReentrantLock</strong> <strong>实现</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//Lock lock=new ReentrantLock(true);//公平锁</span></span><br><span class="line"><span class="comment">//Lock lock=new ReentrantLock(false);//非公平锁</span></span><br><span class="line"><span class="keyword">private</span> Condition condition=lock.newCondition();<span class="comment">//创建 Condition</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();<span class="comment">//lock 加锁</span></span><br><span class="line"><span class="comment">//1：wait 方法等待：</span></span><br><span class="line"><span class="comment">//System.out.println("开始 wait");</span></span><br><span class="line">condition.await();</span><br><span class="line"><span class="comment">//通过创建 Condition 对象来使线程 wait，必须先执行 lock.lock 方法获得锁</span></span><br><span class="line"><span class="comment">//:2：signal 方法唤醒</span></span><br><span class="line">condition.signal();<span class="comment">//condition 对象的 signal 方法可以唤醒 wait 线程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"ThreadName="</span> + Thread.currentThread().getName()+ (<span class="string">" "</span> + (i + <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line"><span class="number">121623125152125125</span></span><br><span class="line">&#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125; &#125; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Condition-类和-Object-类锁方法区别区别"><a href="#Condition-类和-Object-类锁方法区别区别" class="headerlink" title="Condition 类和 Object 类锁方法区别区别"></a><strong>Condition</strong> <strong>类和</strong> <strong>Object</strong> <strong>类锁方法区别区别</strong></h3><ol>
<li><p>Condition 类的 awiat 方法和 Object 类的 wait 方法等效</p>
</li>
<li><p>Condition 类的 signal 方法和 Object 类的 notify 方法等效</p>
</li>
<li><p>Condition 类的 signalAll 方法和 Object 类的 notifyAll 方法等效</p>
</li>
<li><p>ReentrantLock 类可以唤醒指定条件的线程，而 object 的唤醒是随机的</p>
</li>
</ol>
<h3 id="tryLock-和-lock-和-lockInterruptibly-的区别"><a href="#tryLock-和-lock-和-lockInterruptibly-的区别" class="headerlink" title="tryLock 和 lock 和 lockInterruptibly 的区别"></a><strong>tryLock</strong> <strong>和</strong> <strong>lock</strong> <strong>和</strong> <strong>lockInterruptibly</strong> <strong>的区别</strong></h3><ol>
<li><p>tryLock 能获得锁就返回 true，不能就立即返回 false，tryLock(long timeout,TimeUnit unit)，可以增加时间限制，如果超过该时间段还没获得锁，返回 false</p>
</li>
<li><p>lock 能获得锁就返回 true，不能的话一直等待获得锁</p>
</li>
<li><p>lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程，lock 不会抛出异常，而 lockInterruptibly 会抛出异常。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>AtomicInteger</title>
    <url>/2020/06/18/AtomicInteger/</url>
    <content><![CDATA[<h1 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a><strong>AtomicInteger</strong></h1><p>首先说明，此处 AtomicInteger ，一个提供原子操作的 Integer 的类，常见的还有AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 等，他们的实现原理相同，区别在与运算对象类型的不同。令人兴奋地，还可以通过 AtomicReference<V>将一个对象的所有操作转化成原子操作。</p>
<p>我们知道，在多线程程序中，诸如++i 或 i++等运算不具有原子性，是不安全的线程操作之一。通常我们会使用 synchronized 将该操作变成一个原子操作，但 JVM 为此类操作特意提供了一些</p>
<p>同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger的性能是 ReentantLock 的好几倍。</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>ReadWriteLock读写锁</title>
    <url>/2020/06/18/ReadWriteLock%E8%AF%BB%E5%86%99%E9%94%81/</url>
    <content><![CDATA[<h1 id="ReadWriteLock读写锁"><a href="#ReadWriteLock读写锁" class="headerlink" title="ReadWriteLock读写锁"></a>ReadWriteLock读写锁</h1><p>为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。</p>
<h2 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a><strong>读锁</strong></h2><p>如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁</p>
<h2 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a><strong>写锁</strong></h2><p>如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！</p>
<p>Java 中 读 写 锁 有 个 接 口 java.util.concurrent.locks.ReadWriteLock ， 也 有 具 体 的 实 现ReentrantReadWriteLock。</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>乐观锁、悲观锁、自旋锁</title>
    <url>/2020/06/17/%E4%B9%90%E8%A7%82%E9%94%81%E3%80%81%E6%82%B2%E8%A7%82%E9%94%81%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81/</url>
    <content><![CDATA[<h1 id="乐观锁、悲观锁、自旋锁"><a href="#乐观锁、悲观锁、自旋锁" class="headerlink" title="乐观锁、悲观锁、自旋锁"></a>乐观锁、悲观锁、自旋锁</h1><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a><strong>乐观锁</strong></h2><p>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。</p>
<p>java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。</p>
<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a><strong>悲观锁</strong></h2><p>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。</p>
<p>java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如 RetreenLock。</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a><strong>自旋锁</strong></h2><p>自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p>
<p>线程自旋是需要消耗 cup 的，说白了就是让 cup 在做无用功，如果一直获取不到锁，那线程也不能一直占用 cup 自旋做无用功，所以需要设定一个自旋等待的最大时间。</p>
<p>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p>
<h3 id="自旋锁的优缺点"><a href="#自旋锁的优缺点" class="headerlink" title="自旋锁的优缺点"></a><strong>自旋锁的优缺点</strong></h3><p>自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！</p>
<p>但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cup 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁；自旋锁时间阈值（1.6 引入了适应性自旋锁）自旋锁的目的是为了占着 CPU 的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！</p>
<p>JVM 对于自旋周期的选择，jdk1.5 这个限度是一定的写死的，在 1.6 引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时 JVM 还针对当前 CPU 的负荷情况做了较多的优化，如果平均负载小于 CPUs 则一直自旋，如果有超过(CPUs/2)个线程正在自旋，则后来线程直接阻塞，如果正在自旋的线程发现 Owner 发生了变化则延迟自旋时间（自旋计数）或进入阻塞，如果 CPU 处于节电模式则停止自旋，自旋时间的最坏情况是 CPU的存储延迟（CPU A 存储了一个数据，到 CPU B 得知这个数据直接的时间差），自旋时会适当放弃线程优先级之间的差异。</p>
<p><strong>自旋锁的开启</strong></p>
<p>JDK1.6 中-XX:+UseSpinning 开启；</p>
<p>-XX:PreBlockSpin=10 为自旋次数；</p>
<p>JDK1.7 后，去掉此参数，由 jvm 控制；</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-ioc运行时序解析</title>
    <url>/2020/06/18/spring-ioc%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%8F%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="spring-ioc运行时序解析"><a href="#spring-ioc运行时序解析" class="headerlink" title="spring-ioc运行时序解析"></a>spring-ioc运行时序解析</h1><h2 id="Spring-核心之-IOC-容器初体验"><a href="#Spring-核心之-IOC-容器初体验" class="headerlink" title="Spring 核心之 IOC 容器初体验"></a>Spring 核心之 IOC 容器初体验</h2><h3 id="再谈-IOC-与-DI"><a href="#再谈-IOC-与-DI" class="headerlink" title="再谈 IOC 与 DI"></a><strong>再谈 IOC 与 DI</strong></h3><p><strong>IOC</strong>(Inversion of Control)控制反转：所谓控制反转，就是把原先我们代码里面需要实现的对象创 建、依赖的代码，反转给容器来帮忙实现。那么必然的我们需要创建一个容器，同时需要一种描述来让 容器知道需要创建的对象与对象的关系。这个描述最具体表现就是我们所看到的配置文件。 </p>
<p><strong>DI</strong>(Dependency Injection)依赖注入：就是指对象是被动接受依赖类而不是自己主动去找，换句话说就 是指对象不是从容器中查找它依赖的类，而是在容器实例化对象的时候主动将它依赖的类注入给它。</p>
<h3 id="Spring-核心容器类图"><a href="#Spring-核心容器类图" class="headerlink" title="Spring 核心容器类图"></a><strong>Spring 核心容器类图</strong></h3><h4 id="1、BeanFactory"><a href="#1、BeanFactory" class="headerlink" title="1、BeanFactory"></a><strong>1、BeanFactory</strong></h4><p>Spring Bean 的创建是典型的工厂模式，这一系列的 Bean 工厂，也即 IOC 容器为开发者管理对象间的依赖关系提供了很多便利和基础服务，在 Spring 中有许多的 IOC 容器的实现供用户选择和使用，其相互关系如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfw7h16t9ej317m0lg7ir.jpg" alt="image-20200618095413402"></p>
<p>其中 <strong>BeanFactory</strong> 作为<strong>最顶层</strong>的一个接口类，它定义了 IOC 容器的基本功能规范，BeanFactory 有三 个重要的子类：<strong>ListableBeanFactory</strong>、<strong>HierarchicalBeanFactory</strong> 和 <strong>AutowireCapableBeanFactory</strong>。 但是从类图中我们可以发现<strong>最终的默认实现类</strong>是 <strong>DefaultListableBeanFactory</strong>，它实现了所有的接口。</p>
<p>那为何要定义这么多层次的接口呢？查阅这些接口的源码和说明发现，每个接口都有它使用的场合，它主要是为了区分在 Spring 内部在操作过程中对象的传递和转化过程时，对对象的数据访问所做的限制。 </p>
<p><strong>ListableBeanFactory</strong> 接口：表示这些 <strong>Bean 是可列表化</strong></p>
<p><strong>HierarchicalBeanFactory</strong> 接口：表示的是 这些 Bean 是<strong>有继承关系</strong>的，也就是每个 Bean 有可能有父 Bean。</p>
<p><strong>AutowireCapableBeanFactory</strong> 接口：定义 Bean 的<strong>自动装配规则</strong>。</p>
<p>这三个接口共同定义了 Bean 的集合、Bean 之间的关系、以及 Bean 行 为。</p>
<p>最基本的 IOC 容器接口 BeanFactory，来看一下它的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2002-2017 the original author or authors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.ResolvableType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The root interface for accessing a Spring bean container.</span></span><br><span class="line"><span class="comment"> * This is the basic client view of a bean container;</span></span><br><span class="line"><span class="comment"> * further interfaces such as &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.config.ConfigurableBeanFactory&#125;</span></span><br><span class="line"><span class="comment"> * are available for specific purposes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This interface is implemented by objects that hold a number of bean definitions,</span></span><br><span class="line"><span class="comment"> * each uniquely identified by a String name. Depending on the bean definition,</span></span><br><span class="line"><span class="comment"> * the factory will return either an independent instance of a contained object</span></span><br><span class="line"><span class="comment"> * (the Prototype design pattern), or a single shared instance (a superior</span></span><br><span class="line"><span class="comment"> * alternative to the Singleton design pattern, in which the instance is a</span></span><br><span class="line"><span class="comment"> * singleton in the scope of the factory). Which type of instance will be returned</span></span><br><span class="line"><span class="comment"> * depends on the bean factory configuration: the API is the same. Since Spring</span></span><br><span class="line"><span class="comment"> * 2.0, further scopes are available depending on the concrete application</span></span><br><span class="line"><span class="comment"> * context (e.g. "request" and "session" scopes in a web environment).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The point of this approach is that the BeanFactory is a central registry</span></span><br><span class="line"><span class="comment"> * of application components, and centralizes configuration of application</span></span><br><span class="line"><span class="comment"> * components (no more do individual objects need to read properties files,</span></span><br><span class="line"><span class="comment"> * for example). See chapters 4 and 11 of "Expert One-on-One J2EE Design and</span></span><br><span class="line"><span class="comment"> * Development" for a discussion of the benefits of this approach.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that it is generally better to rely on Dependency Injection</span></span><br><span class="line"><span class="comment"> * ("push" configuration) to configure application objects through setters</span></span><br><span class="line"><span class="comment"> * or constructors, rather than use any form of "pull" configuration like a</span></span><br><span class="line"><span class="comment"> * BeanFactory lookup. Spring's Dependency Injection functionality is</span></span><br><span class="line"><span class="comment"> * implemented using this BeanFactory interface and its subinterfaces.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Normally a BeanFactory will load bean definitions stored in a configuration</span></span><br><span class="line"><span class="comment"> * source (such as an XML document), and use the &#123;<span class="doctag">@code</span> org.springframework.beans&#125;</span></span><br><span class="line"><span class="comment"> * package to configure the beans. However, an implementation could simply return</span></span><br><span class="line"><span class="comment"> * Java objects it creates as necessary directly in Java code. There are no</span></span><br><span class="line"><span class="comment"> * constraints on how the definitions could be stored: LDAP, RDBMS, XML,</span></span><br><span class="line"><span class="comment"> * properties file, etc. Implementations are encouraged to support references</span></span><br><span class="line"><span class="comment"> * amongst beans (Dependency Injection).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;In contrast to the methods in &#123;<span class="doctag">@link</span> ListableBeanFactory&#125;, all of the</span></span><br><span class="line"><span class="comment"> * operations in this interface will also check parent factories if this is a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> HierarchicalBeanFactory&#125;. If a bean is not found in this factory instance,</span></span><br><span class="line"><span class="comment"> * the immediate parent factory will be asked. Beans in this factory instance</span></span><br><span class="line"><span class="comment"> * are supposed to override beans of the same name in any parent factory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Bean factory implementations should support the standard bean lifecycle interfaces</span></span><br><span class="line"><span class="comment"> * as far as possible. The full set of initialization methods and their standard order is:</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;BeanNameAware's &#123;<span class="doctag">@code</span> setBeanName&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;BeanClassLoaderAware's &#123;<span class="doctag">@code</span> setBeanClassLoader&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;BeanFactoryAware's &#123;<span class="doctag">@code</span> setBeanFactory&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;EnvironmentAware's &#123;<span class="doctag">@code</span> setEnvironment&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;EmbeddedValueResolverAware's &#123;<span class="doctag">@code</span> setEmbeddedValueResolver&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;ResourceLoaderAware's &#123;<span class="doctag">@code</span> setResourceLoader&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;ApplicationEventPublisherAware's &#123;<span class="doctag">@code</span> setApplicationEventPublisher&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;MessageSourceAware's &#123;<span class="doctag">@code</span> setMessageSource&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;ApplicationContextAware's &#123;<span class="doctag">@code</span> setApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;ServletContextAware's &#123;<span class="doctag">@code</span> setServletContext&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in a web application context)</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@code</span> postProcessBeforeInitialization&#125; methods of BeanPostProcessors</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;InitializingBean's &#123;<span class="doctag">@code</span> afterPropertiesSet&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;a custom init-method definition</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@code</span> postProcessAfterInitialization&#125; methods of BeanPostProcessors</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;On shutdown of a bean factory, the following lifecycle methods apply:</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@code</span> postProcessBeforeDestruction&#125; methods of DestructionAwareBeanPostProcessors</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;DisposableBean's &#123;<span class="doctag">@code</span> destroy&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;a custom destroy-method definition</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Chris Beams</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 13 April 2001</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanNameAware#setBeanName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanClassLoaderAware#setBeanClassLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanFactoryAware#setBeanFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.ResourceLoaderAware#setResourceLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.ApplicationEventPublisherAware#setApplicationEventPublisher</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.MessageSourceAware#setMessageSource</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.ApplicationContextAware#setApplicationContext</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.context.ServletContextAware#setServletContext</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.config.BeanPostProcessor#postProcessBeforeInitialization</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> InitializingBean#afterPropertiesSet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.support.RootBeanDefinition#getInitMethodName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.config.BeanPostProcessor#postProcessAfterInitialization</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DisposableBean#destroy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.support.RootBeanDefinition#getDestroyMethodName</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//在BeanFactory里只对IOC容器的基本行为作了定义，根本不关心你的Bean是如何定义怎样加载的。</span></span><br><span class="line"><span class="comment">//正如我们只关心工厂里得到什么的产品对象，至于工厂是怎么生产这些对象的，这个基本的接口不关心。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Used to dereference a &#123;<span class="doctag">@link</span> FactoryBean&#125; instance and distinguish it from</span></span><br><span class="line"><span class="comment">    * beans &lt;i&gt;created&lt;/i&gt; by the FactoryBean. For example, if the bean named</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> myJndiObject&#125; is a FactoryBean, getting &#123;<span class="doctag">@code</span> &amp;myJndiObject&#125;</span></span><br><span class="line"><span class="comment">    * will return the factory, not the instance returned by the factory.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//对FactoryBean的转义定义，因为如果使用bean的名字检索FactoryBean得到的对象是工厂生成的对象，</span></span><br><span class="line">   <span class="comment">//如果需要得到工厂本身，需要转义</span></span><br><span class="line">   String FACTORY_BEAN_PREFIX = <span class="string">"&amp;"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;This method allows a Spring BeanFactory to be used as a replacement for the</span></span><br><span class="line"><span class="comment">    * Singleton or Prototype design pattern. Callers may retain references to</span></span><br><span class="line"><span class="comment">    * returned objects in the case of Singleton beans.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean definition</span></span><br><span class="line"><span class="comment">    * with the specified name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeansException if the bean could not be obtained</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//根据bean的名字，获取在IOC容器中得到bean实例</span></span><br><span class="line">   <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Behaves the same as &#123;<span class="doctag">@link</span> #getBean(String)&#125;, but provides a measure of type</span></span><br><span class="line"><span class="comment">    * safety by throwing a BeanNotOfRequiredTypeException if the bean is not of the</span></span><br><span class="line"><span class="comment">    * required type. This means that ClassCastException can't be thrown on casting</span></span><br><span class="line"><span class="comment">    * the result correctly, as can happen with &#123;<span class="doctag">@link</span> #getBean(String)&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> requiredType type the bean must match. Can be an interface or superclass</span></span><br><span class="line"><span class="comment">    * of the actual class, or &#123;<span class="doctag">@code</span> null&#125; for any match. For example, if the value</span></span><br><span class="line"><span class="comment">    * is &#123;<span class="doctag">@code</span> Object.class&#125;, this method will succeed whatever the class of the</span></span><br><span class="line"><span class="comment">    * returned instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no such bean definition</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeanNotOfRequiredTypeException if the bean is not of the required type</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//根据bean的名字和Class类型来得到bean实例，增加了类型安全验证机制。</span></span><br><span class="line">   &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, @Nullable Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Allows for specifying explicit constructor arguments / factory method arguments,</span></span><br><span class="line"><span class="comment">    * overriding the specified default arguments (if any) in the bean definition.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment">    * (only applied when creating a new instance as opposed to retrieving an existing one)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no such bean definition</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeanDefinitionStoreException if arguments have been given but</span></span><br><span class="line"><span class="comment">    * the affected bean isn't a prototype</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the bean instance that uniquely matches the given object type, if any.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;This method goes into &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; by-type lookup territory</span></span><br><span class="line"><span class="comment">    * but may also be translated into a conventional by-name lookup based on the name</span></span><br><span class="line"><span class="comment">    * of the given type. For more extensive retrieval operations across sets of beans,</span></span><br><span class="line"><span class="comment">    * use &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; and/or &#123;<span class="doctag">@link</span> BeanFactoryUtils&#125;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> requiredType type the bean must match; can be an interface or superclass.</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> null&#125; is disallowed.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> an instance of the single bean matching the required type</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if no bean of the given type was found</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoUniqueBeanDefinitionException if more than one bean of the given type was found</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> ListableBeanFactory</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Allows for specifying explicit constructor arguments / factory method arguments,</span></span><br><span class="line"><span class="comment">    * overriding the specified default arguments (if any) in the bean definition.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;This method goes into &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; by-type lookup territory</span></span><br><span class="line"><span class="comment">    * but may also be translated into a conventional by-name lookup based on the name</span></span><br><span class="line"><span class="comment">    * of the given type. For more extensive retrieval operations across sets of beans,</span></span><br><span class="line"><span class="comment">    * use &#123;<span class="doctag">@link</span> ListableBeanFactory&#125; and/or &#123;<span class="doctag">@link</span> BeanFactoryUtils&#125;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> requiredType type the bean must match; can be an interface or superclass.</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> null&#125; is disallowed.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment">    * (only applied when creating a new instance as opposed to retrieving an existing one)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no such bean definition</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeanDefinitionStoreException if arguments have been given but</span></span><br><span class="line"><span class="comment">    * the affected bean isn't a prototype</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 4.1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Does this bean factory contain a bean definition or externally registered singleton</span></span><br><span class="line"><span class="comment">    * instance with the given name?</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;If the given name is an alias, it will be translated back to the corresponding</span></span><br><span class="line"><span class="comment">    * canonical bean name.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;If this factory is hierarchical, will ask any parent factory if the bean cannot</span></span><br><span class="line"><span class="comment">    * be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;If a bean definition or singleton instance matching the given name is found,</span></span><br><span class="line"><span class="comment">    * this method will return &#123;<span class="doctag">@code</span> true&#125; whether the named bean definition is concrete</span></span><br><span class="line"><span class="comment">    * or abstract, lazy or eager, in scope or not. Therefore, note that a &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">    * return value from this method does not necessarily indicate that &#123;<span class="doctag">@link</span> #getBean&#125;</span></span><br><span class="line"><span class="comment">    * will be able to obtain an instance for the same name.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> whether a bean with the given name is present</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//提供对bean的检索，看看是否在IOC容器有这个名字的bean</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Is this bean a shared singleton? That is, will &#123;<span class="doctag">@link</span> #getBean&#125; always</span></span><br><span class="line"><span class="comment">    * return the same instance?</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Note: This method returning &#123;<span class="doctag">@code</span> false&#125; does not clearly indicate</span></span><br><span class="line"><span class="comment">    * independent instances. It indicates non-singleton instances, which may correspond</span></span><br><span class="line"><span class="comment">    * to a scoped bean as well. Use the &#123;<span class="doctag">@link</span> #isPrototype&#125; operation to explicitly</span></span><br><span class="line"><span class="comment">    * check for independent instances.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> whether this bean corresponds to a singleton instance</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #isPrototype</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//根据bean名字得到bean实例，并同时判断这个bean是不是单例</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Is this bean a prototype? That is, will &#123;<span class="doctag">@link</span> #getBean&#125; always return</span></span><br><span class="line"><span class="comment">    * independent instances?</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Note: This method returning &#123;<span class="doctag">@code</span> false&#125; does not clearly indicate</span></span><br><span class="line"><span class="comment">    * a singleton object. It indicates non-independent instances, which may correspond</span></span><br><span class="line"><span class="comment">    * to a scoped bean as well. Use the &#123;<span class="doctag">@link</span> #isSingleton&#125; operation to explicitly</span></span><br><span class="line"><span class="comment">    * check for a shared singleton instance.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> whether this bean will always deliver independent instances</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 2.0.3</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #isSingleton</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Check whether the bean with the given name matches the specified type.</span></span><br><span class="line"><span class="comment">    * More specifically, check whether a &#123;<span class="doctag">@link</span> #getBean&#125; call for the given name</span></span><br><span class="line"><span class="comment">    * would return an object that is assignable to the specified target type.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> typeToMatch the type to match against (as a &#123;<span class="doctag">@code</span> ResolvableType&#125;)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the bean type matches,</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> false&#125; if it doesn't match or cannot be determined yet</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getType</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Check whether the bean with the given name matches the specified type.</span></span><br><span class="line"><span class="comment">    * More specifically, check whether a &#123;<span class="doctag">@link</span> #getBean&#125; call for the given name</span></span><br><span class="line"><span class="comment">    * would return an object that is assignable to the specified target type.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> typeToMatch the type to match against (as a &#123;<span class="doctag">@code</span> Class&#125;)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the bean type matches,</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> false&#125; if it doesn't match or cannot be determined yet</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 2.0.1</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getType</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, @Nullable Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Determine the type of the bean with the given name. More specifically,</span></span><br><span class="line"><span class="comment">    * determine the type of object that &#123;<span class="doctag">@link</span> #getBean&#125; would return for the given name.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;For a &#123;<span class="doctag">@link</span> FactoryBean&#125;, return the type of object that the FactoryBean creates,</span></span><br><span class="line"><span class="comment">    * as exposed by &#123;<span class="doctag">@link</span> FactoryBean#getObjectType()&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment">    * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the name of the bean to query</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the type of the bean, or &#123;<span class="doctag">@code</span> null&#125; if not determinable</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no bean with the given name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 1.1.2</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #isTypeMatch</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//得到bean实例的Class类型</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the aliases for the given bean name, if any.</span></span><br><span class="line"><span class="comment">    * All of those aliases point to the same bean when used in a &#123;<span class="doctag">@link</span> #getBean&#125; call.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;If the given name is an alias, the corresponding original bean name</span></span><br><span class="line"><span class="comment">    * and other aliases (if any) will be returned, with the original bean name</span></span><br><span class="line"><span class="comment">    * being the first element in the array.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name the bean name to check for aliases</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the aliases, or an empty array if none</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #getBean</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//得到bean的别名，如果根据别名检索，那么其原名也会被检索出来</span></span><br><span class="line">   String[] getAliases(String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 BeanFactory 里只对 IOC 容器的基本行为作了定义，根本不关心你的 Bean 是如何定义怎样加载的。 正如我们只关心工厂里得到什么的产品对象，至于工厂是怎么生产这些对象的，这个基本的接口不关心。 </p>
<p>而要知道工厂是如何产生对象的，我们需要看具体的 IOC 容器实现，Spring 提供了许多 <strong>IOC 容器</strong>的 实 现 。 比 如 <strong>GenericApplicationContext</strong> ， <strong>ClasspathXmlApplicationContext</strong> 等 。 </p>
<p><strong>ApplicationContext</strong> 是 Spring 提供的一个<strong>高级的 IOC 容器</strong>，它除了能够提供 IOC 容器的基本功能 外，还为用户提供了以下的附加服务。从 ApplicationContext 接口的实现，我们看出其特点： </p>
<ol>
<li><p>支持信息源，可以实现国际化。（实现 MessageSource 接口） </p>
</li>
<li><p>访问资源。(实现 ResourcePatternResolver 接口，后面章节会讲到) </p>
</li>
<li><p>支持应用事件。(实现 ApplicationEventPublisher 接口) </p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2002-2014 the original author or authors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.HierarchicalBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.ListableBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.AutowireCapableBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.EnvironmentCapable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.ResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Central interface to provide configuration for an application.</span></span><br><span class="line"><span class="comment"> * This is read-only while the application is running, but may be</span></span><br><span class="line"><span class="comment"> * reloaded if the implementation supports this.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;An ApplicationContext provides:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Bean factory methods for accessing application components.</span></span><br><span class="line"><span class="comment"> * Inherited from &#123;<span class="doctag">@link</span> org.springframework.beans.factory.ListableBeanFactory&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;The ability to load file resources in a generic fashion.</span></span><br><span class="line"><span class="comment"> * Inherited from the &#123;<span class="doctag">@link</span> org.springframework.core.io.ResourceLoader&#125; interface.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;The ability to publish events to registered listeners.</span></span><br><span class="line"><span class="comment"> * Inherited from the &#123;<span class="doctag">@link</span> ApplicationEventPublisher&#125; interface.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;The ability to resolve messages, supporting internationalization.</span></span><br><span class="line"><span class="comment"> * Inherited from the &#123;<span class="doctag">@link</span> MessageSource&#125; interface.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Inheritance from a parent context. Definitions in a descendant context</span></span><br><span class="line"><span class="comment"> * will always take priority. This means, for example, that a single parent</span></span><br><span class="line"><span class="comment"> * context can be used by an entire web application, while each servlet has</span></span><br><span class="line"><span class="comment"> * its own child context that is independent of that of any other servlet.</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;In addition to standard &#123;<span class="doctag">@link</span> org.springframework.beans.factory.BeanFactory&#125;</span></span><br><span class="line"><span class="comment"> * lifecycle capabilities, ApplicationContext implementations detect and invoke</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ApplicationContextAware&#125; beans as well as &#123;<span class="doctag">@link</span> ResourceLoaderAware&#125;,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ApplicationEventPublisherAware&#125; and &#123;<span class="doctag">@link</span> MessageSourceAware&#125; beans.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurableApplicationContext</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.BeanFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.core.io.ResourceLoader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//ApplicationContext是Spring提供的一个高级的IOC容器，它除了能够提供IOC容器的基本功能外，还为用户提供了以下的附加服务。</span></span><br><span class="line"><span class="comment">//从ApplicationContext接口的实现，我们看出其特点：</span></span><br><span class="line"><span class="comment">//1、支持信息源，可以实现国际化。（实现 MessageSource 接口）</span></span><br><span class="line"><span class="comment">//2、访问资源。(实现 ResourcePatternResolver 接口，后面章节会讲到)</span></span><br><span class="line"><span class="comment">//3、支持应用事件。(实现 ApplicationEventPublisher 接口)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">EnvironmentCapable</span>, <span class="title">ListableBeanFactory</span>, <span class="title">HierarchicalBeanFactory</span>,</span></span><br><span class="line"><span class="class">      <span class="title">MessageSource</span>, <span class="title">ApplicationEventPublisher</span>, <span class="title">ResourcePatternResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the unique id of this application context.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the unique id of the context, or &#123;<span class="doctag">@code</span> null&#125; if none</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return a name for the deployed application that this context belongs to.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> a name for the deployed application, or the empty String by default</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">String <span class="title">getApplicationName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return a friendly name for this context.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> a display name for this context (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">String <span class="title">getDisplayName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the timestamp when this context was first loaded.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the timestamp (ms) when this context was first loaded</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">long</span> <span class="title">getStartupDate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the parent context, or &#123;<span class="doctag">@code</span> null&#125; if there is no parent</span></span><br><span class="line"><span class="comment">    * and this is the root of the context hierarchy.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the parent context, or &#123;<span class="doctag">@code</span> null&#125; if there is no parent</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">ApplicationContext <span class="title">getParent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Expose AutowireCapableBeanFactory functionality for this context.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;This is not typically used by application code, except for the purpose of</span></span><br><span class="line"><span class="comment">    * initializing bean instances that live outside of the application context,</span></span><br><span class="line"><span class="comment">    * applying the Spring bean lifecycle (fully or partly) to them.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Alternatively, the internal BeanFactory exposed by the</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> ConfigurableApplicationContext&#125; interface offers access to the</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> AutowireCapableBeanFactory&#125; interface too. The present method mainly</span></span><br><span class="line"><span class="comment">    * serves as a convenient, specific facility on the ApplicationContext interface.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span> As of 4.2, this method will consistently throw IllegalStateException</span></span><br><span class="line"><span class="comment">    * after the application context has been closed.&lt;/b&gt; In current Spring Framework</span></span><br><span class="line"><span class="comment">    * versions, only refreshable application contexts behave that way; as of 4.2,</span></span><br><span class="line"><span class="comment">    * all application context implementations will be required to comply.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the AutowireCapableBeanFactory for this context</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalStateException if the context does not support the</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> AutowireCapableBeanFactory&#125; interface, or does not hold an</span></span><br><span class="line"><span class="comment">    * autowire-capable bean factory yet (e.g. if &#123;<span class="doctag">@code</span> refresh()&#125; has</span></span><br><span class="line"><span class="comment">    * never been called), or if the context has been closed already</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> ConfigurableApplicationContext#refresh()</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> ConfigurableApplicationContext#getBeanFactory()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">AutowireCapableBeanFactory <span class="title">getAutowireCapableBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、BeanDefinition"><a href="#2、BeanDefinition" class="headerlink" title="2、BeanDefinition"></a><strong>2、BeanDefinition</strong></h4><p>SpringIOC 容器管理了我们定义的各种 <strong>Bean 对象及其相互的关系</strong>，Bean 对象在 Spring 实现中是 以 <strong>BeanDefinition</strong> 来描述的，其继承体系如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfws7fsumcj310y0tg4c6.jpg" alt="image-20200618215133105"></p>
<h4 id="3、BeanDefinitionReader"><a href="#3、BeanDefinitionReader" class="headerlink" title="3、BeanDefinitionReader"></a><strong>3、BeanDefinitionReader</strong></h4><p>Bean 的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。Bean 的解析主要就是对 Spring 配置文件的解析。这个解析过程主要通过BeanDefintionReader 来完成，最后看看 Spring 中 BeanDefintionReader 的类结构图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfws8bzy5dj30te0hugst.jpg" alt="image-20200618215224546"></p>
<h2 id="基于-Xml-的-IOC-容器的初始化"><a href="#基于-Xml-的-IOC-容器的初始化" class="headerlink" title="基于 Xml 的 IOC 容器的初始化"></a>基于 Xml 的 IOC 容器的初始化</h2><p>IOC 容器的初始化包括 BeanDefinition 的 Resource 定位、加载和注册这三个基本的过程。我们以 ApplicationContext 为例讲解，ApplicationContext 系列容器也许是我们最熟悉的，因为 Web 项目中使用的 XmlWebApplicationContext 就属于这个继承体系，还有 ClasspathXmlApplicationContext 等，其继承体系如下图所示:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfxcc75e3jj31700u0qma.jpg" alt="image-20200619092807520"></p>
<p>ApplicationContext 允许上下文嵌套，通过保持父上下文可以维持一个上下文体系。对于 Bean 的查找 可以在这个上下文体系中发生，首先检查当前上下文，其次是父上下文，逐级向上，这样为不同的 Spring 应用提供了一个共享的 Bean 定义环境。</p>
<h3 id="1、寻找入口"><a href="#1、寻找入口" class="headerlink" title="1、寻找入口"></a><strong>1、寻找入口</strong></h3><p>还有一个我们用的比较多的 ClassPathXmlApplicationContext，通过 main()方法启动:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext app = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"application.xml"</span>);</span><br></pre></td></tr></table></figure>

<p>先看其构造函数的调用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> BeansException </span>&#123; </span><br><span class="line">  <span class="keyword">this</span>(<span class="keyword">new</span> String[]&#123;configLocation&#125;, <span class="keyword">true</span>, (ApplicationContext)<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实际调用的构造函数为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, @Nullable ApplicationContext parent)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(parent); </span><br><span class="line">  <span class="keyword">this</span>.setConfigLocations(configLocations); </span><br><span class="line">  <span class="keyword">if</span>(refresh) &#123;</span><br><span class="line">    <span class="keyword">this</span>.refresh(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还 有 像 AnnotationConfigApplicationContext 、 FileSystemXmlApplicationContext 、 XmlWebApplicationContext 等都继承自父容器 AbstractApplicationContext 主要用到了装饰器模式 和策略模式，最终都是调用 refresh()方法。</p>
<h3 id="2、获得配置路径"><a href="#2、获得配置路径" class="headerlink" title="2、获得配置路径"></a><strong>2、获得配置路径</strong></h3><p>通过分析 ClassPathXmlApplicationContext 的源代码可以知道，在创建 ClassPathXmlApplicationContext 容器时，构造方法做以下两项重要工作: 首先，调用父类容器的构造方法(super(parent)方法)为容器设置好 Bean 资源加载器。<br> 然 后 ， 再 调 用 父 类 AbstractRefreshableConfigApplicationContext 的 setConfigLocations(configLocations)方法设置 Bean 配置信息的定位路径。</p>
<p>通过追踪 ClassPathXmlApplicationContext 的继承体系，发现其父类的父类 AbstractApplicationContext 中初始化 IOC 容器所做的主要源码如下:</p>
]]></content>
      <categories>
        <category>spring源码解读</category>
      </categories>
      <tags>
        <tag>spring-ioc</tag>
      </tags>
  </entry>
  <entry>
    <title>Synchronized同步锁</title>
    <url>/2020/06/17/Synchronized%E5%90%8C%E6%AD%A5%E9%94%81/</url>
    <content><![CDATA[<h1 id="Synchronized同步锁"><a href="#Synchronized同步锁" class="headerlink" title="Synchronized同步锁"></a>Synchronized同步锁</h1><p>synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重入锁。</p>
<h2 id="Synchronized-作用范围"><a href="#Synchronized-作用范围" class="headerlink" title="Synchronized 作用范围"></a><strong>Synchronized</strong> <strong>作用范围</strong></h2><ol>
<li><p>作用于方法时，锁住的是对象的实例(this)；</p>
</li>
<li><p>当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen（jdk1.8 则是 metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程；</p>
</li>
<li><p>synchronized 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。</p>
</li>
</ol>
<h2 id="Synchronized-核心组件"><a href="#Synchronized-核心组件" class="headerlink" title="Synchronized 核心组件"></a><strong>Synchronized</strong> <strong>核心组件</strong></h2><ol>
<li><p>Wait Set：哪些调用 wait 方法被阻塞的线程被放置在这里；</p>
</li>
<li><p>Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；</p>
</li>
<li><p>Entry List：Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中；</p>
</li>
<li><p>OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck；</p>
</li>
<li><p>Owner：当前已经获取到所资源的线程被称为 Owner；</p>
</li>
<li><p>!Owner：当前释放锁的线程。</p>
</li>
</ol>
<h2 id="Synchronized-实现"><a href="#Synchronized-实现" class="headerlink" title="Synchronized 实现"></a><strong>Synchronized</strong> <strong>实现</strong></h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfwhot9cepj317s0jstod.jpg" alt="image-20200618154736405"></p>
<ol>
<li><p>JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争，JVM 会将一部分线程移动到 EntryList 中作为候选竞争线程。</p>
</li>
<li><p>Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并指定EntryList 中的某个线程为 OnDeck 线程（一般是最先进去的那个线程）。</p>
</li>
<li><p>Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck，OnDeck 需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM 中，也把这种选择行为称之为“竞争切换”。</p>
</li>
<li><p>OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList中。如果 Owner 线程被 wait 方法阻塞，则转移到 WaitSet 队列中，直到某个时刻通过 notify或者 notifyAll 唤醒，会重新进去 EntryList 中。</p>
</li>
<li><p>处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux 内核下采用 pthread_mutex_lock 内核函数实现的）。</p>
</li>
<li><p>Synchronized 是非公平锁。 Synchronized 在线程进入 ContentionList 时，等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源。参考：<a href="https://blog.csdn.net/zqz_zqz/article/details/70233767" target="_blank" rel="noopener">https://blog.csdn.net/zqz_zqz/article/details/70233767</a></p>
</li>
<li><p>每个对象都有个 monitor 对象，加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的</p>
</li>
<li><p>synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。</p>
</li>
<li><p>Java1.6，synchronized 进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。</p>
</li>
<li><p>锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀；</p>
</li>
<li><p>JDK 1.6 中默认是开启偏向锁和轻量级锁，可以通过-XX:-UseBiasedLocking 来禁用偏向锁。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>偏向锁</title>
    <url>/2020/06/18/%E5%81%8F%E5%90%91%E9%94%81/</url>
    <content><![CDATA[<h1 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h1><p>Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换ThreadID 的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2020/06/20/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="原型模式的应用场景"><a href="#原型模式的应用场景" class="headerlink" title="原型模式的应用场景"></a><strong>原型模式的应用场景</strong></h2><p>你一定遇到过大篇幅 getter、setter 赋值的场景。例如这样的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParam</span><span class="params">(ExamPaperVo vo)</span></span>&#123;</span><br><span class="line">  ExamPaper examPaper = <span class="keyword">new</span> ExamPaper();</span><br><span class="line">  <span class="comment">//试卷主键 </span></span><br><span class="line">  examPaper.setExaminationPaperId(vo.getExaminationPaperId()); </span><br><span class="line">  <span class="comment">//剩余时间</span></span><br><span class="line">  curForm.setLeavTime(examPaper.getLeavTime());</span><br><span class="line">  <span class="comment">//单位主键 </span></span><br><span class="line">  curForm.setOrganizationId(examPaper.getOrganizationId()); </span><br><span class="line">  <span class="comment">//考试主键</span></span><br><span class="line">  curForm.setId(examPaper.getId());</span><br><span class="line">  <span class="comment">//考场主键 </span></span><br><span class="line">  curForm.setExamroomId(examPaper.getExamroomId()); </span><br><span class="line">  <span class="comment">//用户主键 </span></span><br><span class="line">  curForm.setUserId(examPaper.getUserId());</span><br><span class="line">  <span class="comment">//专业 </span></span><br><span class="line">  curForm.setSpecialtyCode(examPaper.getSpecialtyCode()); </span><br><span class="line">  <span class="comment">//岗位 </span></span><br><span class="line">  curForm.setPostionCode(examPaper.getPostionCode()); </span><br><span class="line">  <span class="comment">//等级</span></span><br><span class="line">  curForm.setGradeCode(examPaper.getGradeCode()); </span><br><span class="line">  <span class="comment">//考试开始时间 </span></span><br><span class="line">  curForm.setExamStartTime(examPaper.getExamStartTime()); </span><br><span class="line">  <span class="comment">//考试结束时间</span></span><br><span class="line">  curForm.setExamEndTime(examPaper.getExamEndTime());</span><br><span class="line">  <span class="comment">//单选题重要数量 </span></span><br><span class="line">  curForm.setSingleSelectionImpCount(examPaper.getSingleSelectionImpCount()); </span><br><span class="line">  <span class="comment">//多选题重要数量 </span></span><br><span class="line">  curForm.setMultiSelectionImpCount(examPaper.getMultiSelectionImpCount()); </span><br><span class="line">  <span class="comment">//判断题重要数量 </span></span><br><span class="line">  curForm.setJudgementImpCount(examPaper.getJudgementImpCount());</span><br><span class="line">  <span class="comment">//考试时间</span></span><br><span class="line">  curForm.setExamTime(examPaper.getExamTime());</span><br><span class="line">  <span class="comment">//总分</span></span><br><span class="line">  curForm.setFullScore(examPaper.getFullScore());</span><br><span class="line">  <span class="comment">//及格分</span></span><br><span class="line">  curForm.setPassScore(examPaper.getPassScore());</span><br><span class="line">  <span class="comment">//学员姓名</span></span><br><span class="line">  curForm.setUserName(examPaper.getUserName());</span><br><span class="line">  <span class="comment">//分数</span></span><br><span class="line">  curForm.setScore(examPaper.getScore());</span><br><span class="line">  <span class="comment">//是否及格</span></span><br><span class="line">  curForm.setResult(examPaper.getResult()); </span><br><span class="line">  curForm.setIsPassed(examPaper.getIsPassed());</span><br><span class="line">  <span class="comment">//单选答对数量 </span></span><br><span class="line">  curForm.setSingleOkCount(examPaper.getSingleOkCount()); </span><br><span class="line">  <span class="comment">//多选答对数量 </span></span><br><span class="line">  curForm.setMultiOkCount(examPaper.getMultiOkCount()); </span><br><span class="line">  <span class="comment">//判断答对数量 </span></span><br><span class="line">  curForm.setJudgementOkCount(examPaper.getJudgementOkCount());</span><br><span class="line">  <span class="comment">//提交试卷</span></span><br><span class="line">  service.submit(examPaper); &#125;</span><br></pre></td></tr></table></figure>

<p>代码非常工整，命名非常规范，注释也写的很全面，大家觉得这样的代码优雅吗?我认 为，这样的代码属于纯体力劳动。那么原型模式，能帮助我们解决这样的问题。 原型模式(Prototype Pattern)是指原型实例指定创建对象的种类，并且通过拷贝这些 原型创建新的对象。</p>
<p>原型模式主要适用于以下场景:</p>
<ol>
<li>类初始化消耗资源较多。</li>
<li>new 产生的一个对象需要非常繁琐的过程(数据准备、访问权限等) </li>
<li>构造函数比较复杂。</li>
<li>循环体中生产大量对象时。</li>
</ol>
<p>在 Spring 中，原型模式应用得非常广泛。例如 scope=“prototype”，在我们经常用 的 JSON.parseObject()也是一种原型模式。下面，我们来看看原型模式类结构图:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfyhtavz0yj319y0ew4ac.jpg" alt="image-20200620092308215"></p>
<h2 id="简单克隆"><a href="#简单克隆" class="headerlink" title="简单克隆"></a><strong>简单克隆</strong></h2><p>一个标准的原型模式代码，应该是这样设计的。先创建原型 Prototype 接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Prototype</span></span>&#123; </span><br><span class="line">  <span class="function">Prototype <span class="title">clone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建具体需要克隆的对象 ConcretePrototype</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototypeA</span> <span class="keyword">implements</span> <span class="title">Prototype</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> List hobbies;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List <span class="title">getHobbies</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hobbies;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHobbies</span><span class="params">(List hobbies)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.hobbies = hobbies;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ConcretePrototypeA <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConcretePrototypeA concretePrototype = <span class="keyword">new</span> ConcretePrototypeA(); </span><br><span class="line">    concretePrototype.setAge(<span class="keyword">this</span>.age);</span><br><span class="line">    concretePrototype.setName(<span class="keyword">this</span>.name); </span><br><span class="line">    concretePrototype.setHobbies(<span class="keyword">this</span>.hobbies);</span><br><span class="line">    <span class="keyword">return</span> concretePrototype;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 Client 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Prototype prototype; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">(Prototype prototype)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.prototype = prototype; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Prototype <span class="title">startClone</span><span class="params">(Prototype concretePrototype)</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (Prototype)concretePrototype.clone();</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个具体的需要克隆的对象</span></span><br><span class="line">    ConcretePrototypeA concretePrototype = <span class="keyword">new</span> ConcretePrototypeA(); </span><br><span class="line">    <span class="comment">// 填充属性，方便测试</span></span><br><span class="line">    concretePrototype.setAge(<span class="number">18</span>); </span><br><span class="line">    concretePrototype.setName(<span class="string">"prototype"</span>);</span><br><span class="line">    List hobbies = <span class="keyword">new</span> ArrayList&lt;String&gt;(); </span><br><span class="line">    concretePrototype.setHobbies(hobbies); </span><br><span class="line">    System.out.println(concretePrototype);</span><br><span class="line">    <span class="comment">// 创建 Client 对象，准备开始克隆</span></span><br><span class="line">    Client client = <span class="keyword">new</span> Client(concretePrototype); </span><br><span class="line">    ConcretePrototypeA concretePrototypeClone = (ConcretePrototypeA)client.startClone(concretePrototype);</span><br><span class="line">    System.out.println(concretePrototypeClone);</span><br><span class="line">    System.out.println(<span class="string">"克隆对象中的引用类型地址值:"</span> + concretePrototypeClone.getHobbies()); </span><br><span class="line">    System.out.println(<span class="string">"原对象中的引用类型地址值:"</span> + concretePrototype.getHobbies()); </span><br><span class="line">    System.out.println(<span class="string">"对象地址比较:"</span>+(concretePrototypeClone.getHobbies() == concretePrototype.getHobbies())); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从测试结果看出 hobbies 的引用地址是相同的，意味着复制的不是值，而是引用的地址。 这样的话，如果我们修改任意一个对象中的属性值，concretePrototype 和 concretePrototypeCone 的 hobbies 值都会改变。这就是我们常说的浅克隆。只是完整 复制了值类型数据，没有赋值引用对象。换言之，所有的引用对象仍然指向原来的对象， 显然不是我们想要的结果。下面我们来看深度克隆继续改造。</p>
<h2 id="深度克隆"><a href="#深度克隆" class="headerlink" title="深度克隆"></a><strong>深度克隆</strong></h2><p>我们换一个场景，大家都知道齐天大圣。首先它是一只猴子，有七十二般变化，把一根 毫毛就可以吹出千万个泼猴，手里还拿着金箍棒，金箍棒可以变大变小。这就是我们耳 熟能详的原型模式的经典体现。<br> 创建原型猴子 Monkey 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> </span>&#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> height; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> weight; </span><br><span class="line">  <span class="keyword">public</span> Date birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建引用对象金箍棒 Jingubang 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JinGuBang</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">float</span> h = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">float</span> d = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">big</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.d *= <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">this</span>.h *= <span class="number">2</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">small</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.d /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.h /= <span class="number">2</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建具体的对象齐天大圣 QiTianDaSheng 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QiTianDaSheng</span> <span class="keyword">extends</span> <span class="title">Monkey</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> JinGuBang jinGuBang;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QiTianDaSheng</span><span class="params">()</span> </span>&#123; <span class="comment">//只是初始化</span></span><br><span class="line">        <span class="keyword">this</span>.birthday = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">this</span>.jinGuBang = <span class="keyword">new</span> JinGuBang();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.deepClone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">            oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line">            ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">            QiTianDaSheng copy = (QiTianDaSheng) ois.readObject();</span><br><span class="line">            copy.birthday = <span class="keyword">new</span> Date();</span><br><span class="line">            <span class="keyword">return</span> copy;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> QiTianDaSheng <span class="title">shallowClone</span><span class="params">(QiTianDaSheng target)</span> </span>&#123;</span><br><span class="line">        QiTianDaSheng qiTianDaSheng = <span class="keyword">new</span> QiTianDaSheng();</span><br><span class="line">        qiTianDaSheng.height = target.height;</span><br><span class="line">        qiTianDaSheng.weight = target.height;</span><br><span class="line">        qiTianDaSheng.jinGuBang = target.jinGuBang;</span><br><span class="line">        qiTianDaSheng.birthday = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">return</span> qiTianDaSheng;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="克隆破坏单例模式"><a href="#克隆破坏单例模式" class="headerlink" title="克隆破坏单例模式"></a><strong>克隆破坏单例模式</strong></h2><p>如果我们克隆的目标的对象是单例对象，那意味着，深克隆就会破坏单例。实际上防止 克隆破坏单例解决思路非常简单，禁止深克隆便可。要么你我们的单例类不实现 Cloneable 接口;要么我们重写 clone()方法，在 clone 方法中返回单例对象即可，具体代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Cloneable-源码分析"><a href="#Cloneable-源码分析" class="headerlink" title="Cloneable 源码分析"></a><strong>Cloneable 源码分析</strong></h2><p>先看我们常用的 ArrayList 就实现了 Cloneable 接口，来看代码 clone()方法的实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    ArrayList&lt;?&gt; v=(ArrayList&lt;?&gt;)<span class="keyword">super</span>.clone();v.elementData=Arrays.copyOf(elementData,size);</span><br><span class="line">    v.modCount=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">  &#125;<span class="keyword">catch</span>(CloneNotSupportedException e)&#123;</span><br><span class="line">    <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>公平锁与非公平锁</title>
    <url>/2020/06/18/%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81/</url>
    <content><![CDATA[<h1 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h1><h2 id="公平锁（Fair）"><a href="#公平锁（Fair）" class="headerlink" title="公平锁（Fair）"></a>公平锁（Fair）</h2><p>加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得</p>
<h3 id="非公平锁（Nonfair）"><a href="#非公平锁（Nonfair）" class="headerlink" title="非公平锁（Nonfair）"></a>非公平锁（Nonfair）</h3><p>加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待</p>
<ol>
<li><p>非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列</p>
</li>
<li><p>Java 中的 synchronized 是非公平锁，ReentrantLock 默认的 lock()方法采用的是非公平锁。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>共享锁和独占锁</title>
    <url>/2020/06/18/%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E7%8B%AC%E5%8D%A0%E9%94%81/</url>
    <content><![CDATA[<h1 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h1><p>java 并发包提供的加锁模式分为独占锁和共享锁。</p>
<h2 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a><strong>独占锁</strong></h2><p>独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。</p>
<p>独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。</p>
<h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a><strong>共享锁</strong></h2><p>共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。</p>
<ol>
<li><p>AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等待线程的锁获取模式。</p>
</li>
<li><p>java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，或者被一个 写操作访问，但两者不能同时进行。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>分段锁</title>
    <url>/2020/06/18/%E5%88%86%E6%AE%B5%E9%94%81/</url>
    <content><![CDATA[<p>分段锁也并非一种实际的锁，而是一种思想 ConcurrentHashMap 是学习分段锁的最好实践</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2020/06/19/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="工厂模式详解"><a href="#工厂模式详解" class="headerlink" title="工厂模式详解"></a>工厂模式详解</h2><h3 id="工厂模式的历史由来"><a href="#工厂模式的历史由来" class="headerlink" title="工厂模式的历史由来"></a><strong>工厂模式的历史由来</strong></h3><p>在现实生活中我们都知道，原始社会自给自足(没有工厂)、农耕社会小作坊(简单工 厂，民间酒坊)、工业革命流水线(工厂方法，自产自销)、现代产业链代工厂(抽象工厂， 富士康)</p>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>简单工厂模式(Simple Factory Pattern)是指由一个工厂对象决定创建出哪一种产品类 的实例，但它不属于 GOF，23 种设计模式(参考资料: <a href="http://en.wikipedia.org/wiki/Design_Patterns#Patterns_by_Type)。简单工厂适用" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Design_Patterns#Patterns_by_Type)。简单工厂适用</a> 于工厂类负责创建的对象较少的场景，且客户端只需要传入工厂类的参数，对于如何创 建对象的逻辑不需要关心。 接下来我们来看代码，还是以课程为例。目前开设有 Java 架构、大数据、人工 智能等课程，已经形成了一个生态。我们可以定义一个课程标准 ICourse 接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICourse</span> </span>&#123; </span><br><span class="line">  <span class="comment">/** 录制视频 */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">record</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个 Java 课程的实现 JavaCourse 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaCourse</span> <span class="keyword">implements</span> <span class="title">ICourse</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">record</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"录制 Java 课程"</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看客户端调用代码，我们会这样写:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">  ICourse course = <span class="keyword">new</span> JavaCourse(); </span><br><span class="line">  course.record();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看上面的代码，父类 ICourse 指向子类 JavaCourse 的引用，应用层代码需要依赖 JavaCourse，如果业务扩展，我继续增加 PythonCourse 甚至更多，那么我们客户端的 依赖会变得越来越臃肿。因此，我们要想办法把这种依赖减弱，把创建细节隐藏。虽然 目前的代码中，我们创建对象的过程并不复杂，但从代码设计角度来讲不易于扩展。现 在，我们用简单工厂模式对代码进行优化。先增加课程 PythonCourse 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PythonCourse</span> <span class="keyword">implements</span> <span class="title">ICourse</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">record</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"录制 Python 课程"</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 CourseFactory 工厂类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ICourse <span class="title">create</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"java"</span>.equals(name))&#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> JavaCourse();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"python"</span>.equals(name))&#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> PythonCourse();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改客户端调用代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactoryTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CourseFactory factory = <span class="keyword">new</span> CourseFactory();</span><br><span class="line">    factory.create(<span class="string">"java"</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，我们为了调用方便，可将 factory 的 create()改为静态方法，下面来看一下类图:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfxdbvlezsj30my0pi15c.jpg" alt="image-20200619100225030"></p>
<p>客户端调用是简单了，但如果我们业务继续扩展，要增加前端课程，那么工厂中的 create() 就要根据产品链的丰富每次都要修改代码逻辑。不符合开闭原则。因此，我们对简单工 厂还可以继续优化，可以采用反射技术:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ICourse <span class="title">create</span><span class="params">(String className)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(<span class="keyword">null</span> == className || <span class="string">""</span>.equals(className))) &#123;</span><br><span class="line">        <span class="keyword">return</span> (ICourse) Class.forName(className).newInstance(); </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123; </span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a><strong>工厂方法模式</strong></h2><p>工厂方法模式(Fatory Method Pattern)是指定义一个创建对象的接口，但让实现这个 接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。在工厂方法 模式中用户只需要关心所需产品对应的工厂，无须关心创建细节，而且加入新的产品符 合开闭原则。 </p>
<p>工厂方法模式主要解决产品扩展的问题，在简单工厂中，随着产品链的丰富，如果每个 课程的创建逻辑有区别的话，工厂的职责会变得越来越多，有点像万能工厂，并不便于 维护。根据单一职责原则我们将职能继续拆分，专人干专事。Java 课程由 Java 工厂创建， Python 课程由 Python 工厂创建，对工厂本身也做一个抽象。</p>
<p>工厂方法适用于以下场景:<br> 1、创建对象需要大量重复的代码。 2、客户端(应用层)不依赖于产品类实例如何被创建、实现等细节。 3、一个类通过其子类来指定创建哪个对象。<br> 工厂方法也有缺点:<br> 1、类的个数容易过多，增加复杂度。<br> 2、增加了系统的抽象性和理解难度。</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂模式(Abastract Factory Pattern)是指提供一个创建一系列相关或相互依赖对象的接口，无须指定他们具体的类。客户端(应用层)不依赖于产品类实例如何被创 建、实现等细节，强调的是一系列相关的产品对象(属于同一产品族)一起使用创建对 象需要大量重复的代码。需要提供一个产品类的库，所有的产品以同样的接口出现，从 而使客户端不依赖于具体实现。 讲解抽象工厂之前，我们要了解两个概念产品等级结构和产品族，看下面的图:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfyh36nnegj31300oi0wn.jpg" alt="image-20200620085759434"></p>
<p>从上图中看出有正方形，圆形和菱形三种图形，相同颜色深浅的就代表同一个产品族， 相同形状的代表同一个产品等级结构。同样可以从生活中来举例，比如，美的电器生产 多种家用电器。那么上图中，颜色最深的正方形就代表美的洗衣机、颜色最深的圆形代 表美的空调、颜色最深的菱形代表美的热水器，颜色最深的一排都属于美的品牌，都是 美的电器这个产品族。再看最右侧的菱形，颜色最深的我们指定了代表美的热水器，那 么第二排颜色稍微浅一点的菱形，代表海信的热水器。同理，同一产品结构下还有格力 热水器，格力空调，格力洗衣机。</p>
<p>再看下面的这张图，最左侧的小房子我们就认为具体的工厂，有美的工厂，有海信工厂， 有格力工厂。每个品牌的工厂都生产洗衣机、热水器和空调。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfyh4e565oj317e0neafx.jpg" alt="image-20200620085911334"></p>
<p>抽象工厂也是 有缺点的: </p>
<ol>
<li><p>规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂 的接口。</p>
</li>
<li><p>增加了系统的抽象性和理解难度。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>可重入锁（递归锁）</title>
    <url>/2020/06/18/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%88%E9%80%92%E5%BD%92%E9%94%81%EF%BC%89/</url>
    <content><![CDATA[<h1 id="可重入锁（递归锁）"><a href="#可重入锁（递归锁）" class="headerlink" title="可重入锁（递归锁）"></a>可重入锁（递归锁）</h1><p>本文里面讲的是广义上的可重入锁，而不是单指 JAVA 下的 ReentrantLock。可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。在 JAVA 环境下 ReentrantLock 和 synchronized 都是 可重入锁。</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>模仿spring-mvc</title>
    <url>/2020/06/17/%E6%A8%A1%E4%BB%BFspring-mvc/</url>
    <content><![CDATA[<h1 id="模仿spring-mvc"><a href="#模仿spring-mvc" class="headerlink" title="模仿spring-mvc"></a>模仿spring-mvc</h1><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfvnfa3619j31gm0tie81.jpg" alt="image-20200617222032762"></p>
<h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><h3 id="配置-application-properties-文件"><a href="#配置-application-properties-文件" class="headerlink" title="配置 application.properties 文件"></a>配置 application.properties 文件</h3><p>为了解析方便，我们用 application.properties 来代替 application.xml 文件，具体配置内容如下：</p>
<p>scanPackage=com.shoufeng.demo</p>
<h3 id="配置-web-xml-文件"><a href="#配置-web-xml-文件" class="headerlink" title="配置 web.xml 文件"></a>配置 web.xml 文件</h3><p>大家都知道，所有依赖于 web 容器的项目，都是从读取 web.xml 文件开始的。我们先配置好 web.xml 中的内容。 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">version</span>=<span class="string">"2.4"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>sf Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>sfmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.shoufeng.mvc.core.servlet.SFDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>application.properties<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>sfmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中 SFDispatcherServlet 是有自己模拟 Spring 实现的核心功能类。 </p>
<h3 id="自定义-Annotation"><a href="#自定义-Annotation" class="headerlink" title="自定义 Annotation"></a>自定义 Annotation</h3><h4 id="SFAutowired-注解："><a href="#SFAutowired-注解：" class="headerlink" title="@SFAutowired 注解："></a>@SFAutowired 注解：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoufeng.mvc.core.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shoufeng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SFAutowired &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SFController-注解："><a href="#SFController-注解：" class="headerlink" title="@SFController 注解："></a>@SFController 注解：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoufeng.mvc.core.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shoufeng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SFController &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SFRequestMapping-注解："><a href="#SFRequestMapping-注解：" class="headerlink" title="@SFRequestMapping 注解："></a>@SFRequestMapping 注解：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoufeng.mvc.core.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shoufeng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SFRequestMapping &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SFRequestParam-注解："><a href="#SFRequestParam-注解：" class="headerlink" title="@SFRequestParam 注解："></a>@SFRequestParam 注解：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoufeng.mvc.core.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shoufeng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.PARAMETER&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SFRequestParam &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SFService-注解："><a href="#SFService-注解：" class="headerlink" title="@SFService 注解："></a>@SFService 注解：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoufeng.mvc.core.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shoufeng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SFService &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="容器初始化"><a href="#容器初始化" class="headerlink" title="容器初始化"></a>容器初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoufeng.mvc.core.servlet;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.shoufeng.mvc.core.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shoufeng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SFDispatcherServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存application.properties配置文件中的内容</span></span><br><span class="line">    <span class="keyword">private</span> Properties contextConfig = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存扫描的所有的类名</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; classNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传说中的IOC容器，我们来揭开它的神秘面纱</span></span><br><span class="line">    <span class="comment">//为了简化程序，暂时不考虑ConcurrentHashMap</span></span><br><span class="line">    <span class="comment">// 主要还是关注设计思想和原理</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; ioc = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存url和Method的对应关系</span></span><br><span class="line"><span class="comment">//    private Map&lt;String,Method&gt; handlerMapping = new HashMap&lt;String,Method&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//思考：为什么不用Map</span></span><br><span class="line">    <span class="comment">//你用Map的话，key，只能是url</span></span><br><span class="line">    <span class="comment">//Handler 本身的功能就是把url和method对应关系，已经具备了Map的功能</span></span><br><span class="line">    <span class="comment">//根据设计原则：冗余的感觉了，单一职责，最少知道原则，帮助我们更好的理解</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Handler&gt; handlerMapping = <span class="keyword">new</span> ArrayList&lt;Handler&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6、调用，运行阶段</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doDispatch(req, resp);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            resp.getWriter().write(<span class="string">"500 Exection,Detail : "</span> + Arrays.toString(e.getStackTrace()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化阶段</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、加载配置文件</span></span><br><span class="line">        doLoadConfig(config.getInitParameter(<span class="string">"contextConfigLocation"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、扫描相关的类</span></span><br><span class="line">        doScanner(contextConfig.getProperty(<span class="string">"scanPackage"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、初始化扫描到的类，并且将它们放入到ICO容器之中</span></span><br><span class="line">        doInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、完成依赖注入</span></span><br><span class="line">        doAutowired();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5、初始化HandlerMapping</span></span><br><span class="line">        initHandlerMapping();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"SF Spring framework is init."</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Handler handler = getHandler(req);</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//        if(!this.handlerMapping.containsKey(url))&#123;</span></span><br><span class="line">            resp.getWriter().write(<span class="string">"404 Not Found!!!"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得方法的形参列表</span></span><br><span class="line">        Class&lt;?&gt;[] paramTypes = handler.getParamTypes();</span><br><span class="line"></span><br><span class="line">        Object[] paramValues = <span class="keyword">new</span> Object[paramTypes.length];</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String[]&gt; params = req.getParameterMap();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String[]&gt; parm : params.entrySet()) &#123;</span><br><span class="line">            String value = Arrays.toString(parm.getValue()).replaceAll(<span class="string">"\\[|\\]"</span>, <span class="string">""</span>)</span><br><span class="line">                    .replaceAll(<span class="string">"\\s"</span>, <span class="string">","</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!handler.paramIndexMapping.containsKey(parm.getKey())) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = handler.paramIndexMapping.get(parm.getKey());</span><br><span class="line">            paramValues[index] = convert(paramTypes[index], value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (handler.paramIndexMapping.containsKey(HttpServletRequest<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())) </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> reqIndex = handler.paramIndexMapping.get(HttpServletRequest<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">            paramValues[reqIndex] = req;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (handler.paramIndexMapping.containsKey(HttpServletResponse<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())) </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> respIndex = handler.paramIndexMapping.get(HttpServletResponse<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">            paramValues[respIndex] = resp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object returnValue = handler.method.invoke(handler.controller, paramValues);</span><br><span class="line">        <span class="keyword">if</span> (returnValue == <span class="keyword">null</span> || returnValue <span class="keyword">instanceof</span> Void) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        resp.getWriter().write(returnValue.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Handler <span class="title">getHandler</span><span class="params">(HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handlerMapping.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//绝对路径</span></span><br><span class="line">        String url = req.getRequestURI();</span><br><span class="line">        <span class="comment">//处理成相对路径</span></span><br><span class="line">        String contextPath = req.getContextPath();</span><br><span class="line">        url = url.replaceAll(contextPath, <span class="string">""</span>).replaceAll(<span class="string">"/+"</span>, <span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Handler handler : <span class="keyword">this</span>.handlerMapping) &#123;</span><br><span class="line">            Matcher matcher = handler.getPattern().matcher(url);</span><br><span class="line">            <span class="keyword">if</span> (!matcher.matches()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> handler;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//url传过来的参数都是String类型的，HTTP是基于字符串协议</span></span><br><span class="line">    <span class="comment">//只需要把String转换为任意类型就好</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">convert</span><span class="params">(Class&lt;?&gt; type, String value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果是int</span></span><br><span class="line">        <span class="keyword">if</span> (Integer<span class="class">.<span class="keyword">class</span> </span>== type) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.valueOf(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Double<span class="class">.<span class="keyword">class</span> </span>== type) &#123;</span><br><span class="line">            <span class="keyword">return</span> Double.valueOf(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果还有double或者其他类型，继续加if</span></span><br><span class="line">        <span class="comment">//这时候，我们应该想到策略模式了</span></span><br><span class="line">        <span class="comment">//在这里暂时不实现，希望小伙伴自己来实现</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化url和Method的一对一对应关系</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ioc.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : ioc.entrySet()) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = entry.getValue().getClass();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!clazz.isAnnotationPresent(SFController<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//保存写在类上面的@SFRequestMapping("/demo")</span></span><br><span class="line">            String baseUrl = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">if</span> (clazz.isAnnotationPresent(SFRequestMapping<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                SFRequestMapping requestMapping = clazz.getAnnotation(SFRequestMapping<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                baseUrl = requestMapping.value();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//默认获取所有的public方法</span></span><br><span class="line">            <span class="keyword">for</span> (Method method : clazz.getMethods()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!method.isAnnotationPresent(SFRequestMapping<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                SFRequestMapping requestMapping = method.getAnnotation(SFRequestMapping<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                <span class="comment">//优化</span></span><br><span class="line">                <span class="comment">// //demo///query</span></span><br><span class="line">                String regex = (<span class="string">"/"</span> + baseUrl + <span class="string">"/"</span> + requestMapping.value())</span><br><span class="line">                        .replaceAll(<span class="string">"/+"</span>, <span class="string">"/"</span>);</span><br><span class="line">                Pattern pattern = Pattern.compile(regex);</span><br><span class="line">                <span class="keyword">this</span>.handlerMapping.add(<span class="keyword">new</span> Handler(pattern, entry.getValue(), method));</span><br><span class="line"><span class="comment">//                handlerMapping.put(url,method);</span></span><br><span class="line">                System.out.println(<span class="string">"Mapped :"</span> + pattern + <span class="string">","</span> + method);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自动依赖注入</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAutowired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ioc.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : ioc.entrySet()) &#123;</span><br><span class="line">            <span class="comment">//Declared 所有的，特定的 字段，包括private/protected/default</span></span><br><span class="line">            <span class="comment">//正常来说，普通的OOP编程只能拿到public的属性</span></span><br><span class="line">            Field[] fields = entry.getValue().getClass().getDeclaredFields();</span><br><span class="line">            <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!field.isAnnotationPresent(SFAutowired<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                SFAutowired autowired = field.getAnnotation(SFAutowired<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果用户没有自定义beanName，默认就根据类型注入</span></span><br><span class="line">                <span class="comment">//这个地方省去了对类名首字母小写的情况的判断，这个作为课后作业</span></span><br><span class="line">                <span class="comment">//小伙伴们自己去完善</span></span><br><span class="line">                String beanName = autowired.value().trim();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">""</span>.equals(beanName)) &#123;</span><br><span class="line">                    <span class="comment">//获得接口的类型，作为key待会拿这个key到ioc容器中去取值</span></span><br><span class="line">                    beanName = field.getType().getName();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果是public以外的修饰符，只要加了@Autowired注解，都要强制赋值</span></span><br><span class="line">                <span class="comment">//反射中叫做暴力访问， 强吻</span></span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//用反射机制，动态给字段赋值</span></span><br><span class="line">                    field.set(entry.getValue(), ioc.get(beanName));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化，为DI做准备</span></span><br><span class="line">        <span class="keyword">if</span> (classNames.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (String className : classNames) &#123;</span><br><span class="line">                Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//什么样的类才需要初始化呢？</span></span><br><span class="line">                <span class="comment">//加了注解的类，才初始化，怎么判断？</span></span><br><span class="line">                <span class="comment">//为了简化代码逻辑，主要体会设计思想，只举例 @Controller和@Service,</span></span><br><span class="line">                <span class="comment">// @Componment...就一一举例了</span></span><br><span class="line">                <span class="keyword">if</span> (clazz.isAnnotationPresent(SFController<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                    Object instance = clazz.newInstance();</span><br><span class="line">                    <span class="comment">//Spring默认类名首字母小写</span></span><br><span class="line">                    String beanName = toLowerFirstCase(clazz.getSimpleName());</span><br><span class="line">                    ioc.put(beanName, instance);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz.isAnnotationPresent(SFService<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                    <span class="comment">//1、自定义的beanName</span></span><br><span class="line">                    SFService service = clazz.getAnnotation(SFService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                    String beanName = service.value();</span><br><span class="line">                    <span class="comment">//2、默认类名首字母小写</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">""</span>.equals(beanName.trim())) &#123;</span><br><span class="line">                        beanName = toLowerFirstCase(clazz.getSimpleName());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Object instance = clazz.newInstance();</span><br><span class="line">                    ioc.put(beanName, instance);</span><br><span class="line">                    <span class="comment">//3、根据类型自动赋值,投机取巧的方式</span></span><br><span class="line">                    <span class="keyword">for</span> (Class&lt;?&gt; i : clazz.getInterfaces()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (ioc.containsKey(i.getName())) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"The “"</span> + i.getName() + <span class="string">"” is exists!!"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//把接口的类型直接当成key了</span></span><br><span class="line">                        ioc.put(i.getName(), instance);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果类名本身是小写字母，确实会出问题</span></span><br><span class="line">    <span class="comment">//但是我要说明的是：这个方法是我自己用，private的</span></span><br><span class="line">    <span class="comment">//传值也是自己传，类也都遵循了驼峰命名法</span></span><br><span class="line">    <span class="comment">//默认传入的值，存在首字母小写的情况，也不可能出现非字母的情况</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了简化程序逻辑，就不做其他判断了，大家了解就OK</span></span><br><span class="line">    <span class="comment">//其实用写注释的时间都能够把逻辑写完了</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">toLowerFirstCase</span><span class="params">(String simpleName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = simpleName.toCharArray();</span><br><span class="line">        <span class="comment">//之所以加，是因为大小写字母的ASCII码相差32，</span></span><br><span class="line">        <span class="comment">// 而且大写字母的ASCII码要小于小写字母的ASCII码</span></span><br><span class="line">        <span class="comment">//在Java中，对char做算学运算，实际上就是对ASCII码做算学运算</span></span><br><span class="line">        chars[<span class="number">0</span>] += <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(chars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//扫描出相关的类</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doScanner</span><span class="params">(String scanPackage)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//scanPackage = com.gupaoedu.demo ，存储的是包路径</span></span><br><span class="line">        <span class="comment">//转换为文件路径，实际上就是把.替换为/就OK了</span></span><br><span class="line">        <span class="comment">//classpath</span></span><br><span class="line">        URL url = <span class="keyword">this</span>.getClass().getClassLoader().getResource(<span class="string">"/"</span> + scanPackage.replaceAll(<span class="string">"\\."</span>, <span class="string">"/"</span>));</span><br><span class="line">        File classPath = <span class="keyword">new</span> File(url.getFile());</span><br><span class="line">        <span class="keyword">for</span> (File file : classPath.listFiles()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                doScanner(scanPackage + <span class="string">"."</span> + file.getName());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!file.getName().endsWith(<span class="string">".class"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String className = (scanPackage + <span class="string">"."</span> + file.getName().replace(<span class="string">".class"</span>, <span class="string">""</span>));</span><br><span class="line">                classNames.add(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载配置文件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doLoadConfig</span><span class="params">(String contextConfigLocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//直接从类路径下找到Spring主配置文件所在的路径</span></span><br><span class="line">        <span class="comment">//并且将其读取出来放到Properties对象中</span></span><br><span class="line">        <span class="comment">//相对于scanPackage=com.gupaoedu.demo 从文件中保存到了内存中</span></span><br><span class="line">        InputStream fis = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(contextConfigLocation);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            contextConfig.load(fis);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != fis) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存一个url和一个Method的关系</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="comment">//必须把url放到HandlerMapping才好理解吧</span></span><br><span class="line">        <span class="keyword">private</span> Pattern pattern;  <span class="comment">//正则</span></span><br><span class="line">        <span class="keyword">private</span> Method method;</span><br><span class="line">        <span class="keyword">private</span> Object controller;</span><br><span class="line">        <span class="keyword">private</span> Class&lt;?&gt;[] paramTypes;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Pattern <span class="title">getPattern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pattern;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> method;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> controller;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt;[] getParamTypes() &#123;</span><br><span class="line">            <span class="keyword">return</span> paramTypes;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//形参列表</span></span><br><span class="line">        <span class="comment">//参数的名字作为key,参数的顺序，位置作为值</span></span><br><span class="line">        <span class="keyword">private</span> Map&lt;String, Integer&gt; paramIndexMapping;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Pattern pattern, Object controller, Method method)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.pattern = pattern;</span><br><span class="line">            <span class="keyword">this</span>.method = method;</span><br><span class="line">            <span class="keyword">this</span>.controller = controller;</span><br><span class="line"></span><br><span class="line">            paramTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">            paramIndexMapping = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">            putParamIndexMapping(method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putParamIndexMapping</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//提取方法中加了注解的参数</span></span><br><span class="line">            <span class="comment">//把方法上的注解拿到，得到的是一个二维数组</span></span><br><span class="line">            <span class="comment">//因为一个参数可以有多个注解，而一个方法又有多个参数</span></span><br><span class="line">            Annotation[][] pa = method.getParameterAnnotations();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pa.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Annotation a : pa[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a <span class="keyword">instanceof</span> SFRequestParam) &#123;</span><br><span class="line">                        String paramName = ((SFRequestParam) a).value();</span><br><span class="line">                        <span class="keyword">if</span> (!<span class="string">""</span>.equals(paramName.trim())) &#123;</span><br><span class="line">                            paramIndexMapping.put(paramName, i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//提取方法中的request和response参数</span></span><br><span class="line">            Class&lt;?&gt;[] paramsTypes = method.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paramsTypes.length; i++) &#123;</span><br><span class="line">                Class&lt;?&gt; type = paramsTypes[i];</span><br><span class="line">                <span class="keyword">if</span> (type == HttpServletRequest<span class="class">.<span class="keyword">class</span> ||</span></span><br><span class="line"><span class="class">                        <span class="title">type</span> </span>== HttpServletResponse<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    paramIndexMapping.put(type.getName(), i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行效果演示"><a href="#运行效果演示" class="headerlink" title="运行效果演示"></a>运行效果演示</h2><h3 id="启动tomcat"><a href="#启动tomcat" class="headerlink" title="启动tomcat"></a>启动tomcat</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfvog5hpifj31h50u0kbt.jpg" alt="image-20200617225559239"></p>
<h3 id="访问接口"><a href="#访问接口" class="headerlink" title="访问接口"></a>访问接口</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfvogof4xpj31j80to77l.jpg" alt="image-20200617225629999"></p>
]]></content>
      <categories>
        <category>spring源码解读</category>
      </categories>
      <tags>
        <tag>模仿spring-mvc</tag>
      </tags>
  </entry>
  <entry>
    <title>软件架构设计的七大原则</title>
    <url>/2020/06/18/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="软件架构设计的七大原则"><a href="#软件架构设计的七大原则" class="headerlink" title="软件架构设计的七大原则"></a>软件架构设计的七大原则</h1><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>开闭原则（Open-Closed Principle, OCP）是指一个软件实体如类、模块和函数应该对 扩展开放，对修改关闭。所谓的开闭，也正是对扩展和修改两个行为的一个原则。强调的是用抽象构建框架，用实现扩展细节。可以提高软件系统的可复用性及可维护性。开闭原则，是面向对象设计中最基础的设计原则。它指导我们如何建立稳定灵活的系统，例如：我们版本更新，我尽可能不修改源代码，但是可以增加新功能。 </p>
<p>在现实生活中对于开闭原则也有体现。比如，很多互联网公司都实行弹性制作息时间，规定每天工作 8 小时。意思就是说，对于每天工作 8 小时这个规定是关闭的，但是你什 么时候来，什么时候走是开放的。早来早走，晚来晚走。 实现开闭原则的核心思想就是面向抽象编程，接下来我们来看一段代码：</p>
<p>以课程体系为例，首先创建一个课程接口 ICourse： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICourse</span> </span>&#123; </span><br><span class="line">  <span class="function">Integer <span class="title">getId</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function">String <span class="title">getName</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function">Double <span class="title">getPrice</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个课程生态有 Java 架构、大数据、人工智能、前端、软件测试等，我们来创建一个 Java 架构课程的类 JavaCourse：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaCourse</span> <span class="keyword">implements</span> <span class="title">ICourse</span></span>&#123; </span><br><span class="line">  <span class="keyword">private</span> Integer Id; </span><br><span class="line">  <span class="keyword">private</span> String name; </span><br><span class="line">  <span class="keyword">private</span> Double price; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JavaCourse</span><span class="params">(Integer id, String name, Double price)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.Id = id; <span class="keyword">this</span>.name = name; <span class="keyword">this</span>.price = price; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.Id; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Double <span class="title">getPrice</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.price; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们要给 Java 架构课程做活动，价格优惠。如果修改 JavaCourse 中的 getPrice() 方法，则会存在一定的风险，可能影响其他地方的调用结果。我们如何在不修改原有代 码前提前下，实现价格优惠这个功能呢？现在，我们再写一个处理优惠逻辑的JavaDiscountCourse 类 （ 思 考 一 下 为 什 么 要 叫 JavaDiscountCourse ， 而 不 叫 DiscountCourse）： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaDiscountCourse</span> <span class="keyword">extends</span> <span class="title">JavaCourse</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JavaDiscountCourse</span><span class="params">(Integer id, String name, Double price)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">super</span>(id, name, price); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Double <span class="title">getOriginPrice</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getPrice(); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Double <span class="title">getPrice</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getPrice() * <span class="number">0.61</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回顾一下，简单一下类结构图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfwkdvm3h7j30os0y2wtr.jpg" alt="image-20200618172057924"></p>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a><strong>依赖倒置原则</strong></h2><p>依赖倒置原则（Dependence Inversion Principle,DIP）是指设计代码结构时，高层模 块不应该依赖底层模块，二者都应该依赖其抽象。抽象不应该依赖细节；细节应该依赖 抽象。通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的 可读性和可维护性，并能够降低修改程序所造成的风险。接下来看一个案例，还是以课 程为例，先来创建一个类 Tom：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tom</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">studyJavaCourse</span><span class="params">()</span></span>&#123; </span><br><span class="line">    System.out.println(<span class="string">"Tom 在学习 Java 的课程"</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">studyPythonCourse</span><span class="params">()</span></span>&#123; </span><br><span class="line">    System.out.println(<span class="string">"Tom 在学习 Python 的课程"</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来调用一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">  Tom tom = <span class="keyword">new</span> Tom(); </span><br><span class="line">  tom.studyJavaCourse(); </span><br><span class="line">  tom.studyPythonCourse(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tom 热爱学习，目前正在学习 Java 课程和 Python 课程。大家都知道，学习也是会上瘾 的。随着学习兴趣的暴涨，现在 Tom 还想学习 AI 人工智能的课程。这个时候，业务扩展，我们的代码要从底层到高层（调用层）一次修改代码。在 Tom 类中增加 studyAICourse()的方法，在高层也要追加调用。如此一来，系统发布以后，实际上是非 常不稳定的，在修改代码的同时也会带来意想不到的风险。接下来我们优化代码，创建 一个课程的抽象 ICourse 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICourse</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后写 JavaCourse 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaCourse</span> <span class="keyword">implements</span> <span class="title">ICourse</span> </span>&#123; </span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    System.out.println(<span class="string">"Tom 在学习 Java 课程"</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再实现 PythonCourse 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">blic <span class="class"><span class="keyword">class</span> <span class="title">PythonCourse</span> <span class="keyword">implements</span> <span class="title">ICourse</span> </span>&#123; </span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    System.out.println(<span class="string">"Tom 在学习 Python 课程"</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改 Tom 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tom</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">(ICourse course)</span></span>&#123; </span><br><span class="line">    course.study(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">  Tom tom = <span class="keyword">new</span> Tom(); </span><br><span class="line">  tom.study(<span class="keyword">new</span> JavaCourse()); </span><br><span class="line">  tom.study(<span class="keyword">new</span> PythonCourse()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这时候再看来代码，Tom 的兴趣无论怎么暴涨，对于新的课程，我只需要新建一个 类，通过传参的方式告诉 Tom，而不需要修改底层代码。实际上这是一种大家非常熟悉 的方式，叫依赖注入。注入的方式还有构造器方式和 setter 方式。我们来看构造器注入 方式： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tom</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> ICourse course; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Tom</span><span class="params">(ICourse course)</span></span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.course = course; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123; </span><br><span class="line">    course.study(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看调用代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">  Tom tom = <span class="keyword">new</span> Tom(<span class="keyword">new</span> JavaCourse()); </span><br><span class="line">  tom.study(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据构造器方式注入，在调用时，每次都要创建实例。那么，如果 Tom 是全局单例，则我们就只能选择用 Setter 方式来注入，继续修改 Tom 类的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tom</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> ICourse course; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCourse</span><span class="params">(ICourse course)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.course = course; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">    course.study(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看调用代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">  Tom tom = <span class="keyword">new</span> Tom(); </span><br><span class="line">  tom.setCourse(<span class="keyword">new</span> JavaCourse()); </span><br><span class="line">  tom.study(); </span><br><span class="line">  tom.setCourse(<span class="keyword">new</span> PythonCourse()); </span><br><span class="line">  tom.study(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们再来看最终的类图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfwkmku4p5j31ew0o0qlr.jpg" alt="image-20200618172919462"></p>
<p>大家要切记：以抽象为基准比以细节为基准搭建起来的架构要稳定得多，因此大家在拿 到需求之后，要面向接口编程，先顶层再细节来设计代码结构。</p>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a><strong>单一职责原则</strong></h2><p>单一职责（Simple Responsibility Pinciple，SRP）是指不要存在多于一个导致类变更的原因。假设我们有一个 Class 负责两个职责，一旦发生需求变更，修改其中一个职责的逻辑代码，有可能会导致另一个职责的功能发生故障。这样一来，这个 Class 存在两个导 </p>
<p>致类变更的原因。如何解决这个问题呢？我们就要给两个职责分别用两个 Class 来实现，进行解耦。后期需求变更维护互不影响。这样的设计，可以降低类的复杂度，提高类的可读 性 ， 提 高 系 统 的 可 维 护 性 ， 降 低 变 更 引 起 的 风 险 。 总 体 来 说 就 是 一 个 Class/Interface/Method 只负责一项职责。接下来，我们来看代码实例，还是用课程举例，我们的课程有直播课和录播课。直播课不能快进和快退，录播可以可以任意的反复观看，功能职责不一样。还是先创建一个 Course 类： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">(String courseName)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"直播课"</span>.equals(courseName))&#123;</span><br><span class="line">      System.out.println(courseName + <span class="string">"不能快进"</span>); </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">      System.out.println(courseName + <span class="string">"可以反复回看"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看代码调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">  Course course = <span class="keyword">new</span> Course(); </span><br><span class="line">  course.study(<span class="string">"直播课"</span>); </span><br><span class="line">  course.study(<span class="string">"录播课"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码来看，Course 类承担了两种处理逻辑。假如，现在要对课程进行加密，那么 直播课和录播课的加密逻辑都不一样，必须要修改代码。而修改代码逻辑势必会相互影 s响容易造成不可控的风险。我们对职责进行分离解耦，来看代码，分别创建两个类ReplayCourse 和 LiveCourse： </p>
<p>LiveCourse 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveCourse</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">(String courseName)</span></span>&#123;</span><br><span class="line">    System.out.println(courseName + <span class="string">"不能快进看"</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReplayCourse 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplayCourse</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">(String courseName)</span></span>&#123; </span><br><span class="line">    System.out.println(courseName + <span class="string">"可以反复回"</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">  LiveCourse liveCourse = <span class="keyword">new</span> LiveCourse(); </span><br><span class="line">  liveCourse.study(<span class="string">"直播课"</span>); </span><br><span class="line">  ReplayCourse replayCourse = <span class="keyword">new</span> ReplayCourse(); replayCourse.study(<span class="string">"录播课"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>业务继续发展，课程要做权限。没有付费的学员可以获取课程基本信息，已经付费的学员可以获得视频流，即学习权限。那么对于控制课程层面上至少有两个职责。我们可以s把展示职责和管理职责分离开来，都实现同一个抽象依赖。设计一个顶层接口,创建 </p>
<p>ICourse 接口： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICourse</span> </span>&#123; </span><br><span class="line">  <span class="comment">//获得基本信息 </span></span><br><span class="line">  <span class="function">String <span class="title">getCourseName</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="comment">//获得视频流 </span></span><br><span class="line">  <span class="keyword">byte</span>[] getCourseVideo(); </span><br><span class="line">  <span class="comment">//学习课程 </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">studyCourse</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="comment">//退款 </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">refundCourse</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以把这个接口拆成两个接口，创建一个接口 ICourseInfo 和 ICourseManager： </p>
<p>ICourseInfo 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICourseInfo</span> </span>&#123; </span><br><span class="line">  <span class="function">String <span class="title">getCourseName</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">byte</span>[] getCourseVideo();                       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ICourseManager 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICourseManager</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">studyCourse</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">refundCourse</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看一下类图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfwkvjzbqcj31940i0tpr.jpg" alt="image-20200618173757300"></p>
<p>下面我们来看一下方法层面的单一职责设计。有时候，我们为了偷懒，通常会把一个方法写成下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">modifyUserInfo</span><span class="params">(String userName,String address)</span></span>&#123; </span><br><span class="line">  userName = <span class="string">"Tom"</span>; </span><br><span class="line">  address = <span class="string">"Changsha"</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可能写成这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">modifyUserInfo</span><span class="params">(String userName,String... fileds)</span></span>&#123; </span><br><span class="line">  userName = <span class="string">"Tom"</span>; </span><br><span class="line">  <span class="comment">// address = "Changsha"; </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">modifyUserInfo</span><span class="params">(String userName,String address,<span class="keyword">boolean</span> bool)</span></span>&#123; </span><br><span class="line">  <span class="keyword">if</span>(bool)&#123; </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  userName = <span class="string">"Tom"</span>; </span><br><span class="line">  address = <span class="string">"Changsha"</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，上面的 modifyUserInfo()方法中都承担了多个职责，既可以修改 userName,也可以修改 address，甚至更多，明显不符合单一职责。那么我们做如下修改，把这个方法拆 成两个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">modifyUserName</span><span class="params">(String userName)</span></span>&#123; </span><br><span class="line">  userName = <span class="string">"Tom"</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">modifyAddress</span><span class="params">(String address)</span></span>&#123; </span><br><span class="line">  address = <span class="string">"Changsha"</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这修改之后，开发起来简单，维护起来也容易。但是，我们在实际开发中会项目依赖，组合，聚合这些关系，还有还有项目的规模，周期，技术人员的水平，对进度的把控，很多类都不符合单一职责。但是，我们在编写代码的过程，尽可能地让接口和方法保持s单一职责，对我们项目后期的维护是有很大帮助的。 </p>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a><strong>接口隔离原则</strong></h2><p>接口隔离原则（Interface Segregation Principle, ISP）是指用多个专门的接口，而不使 用单一的总接口，客户端不应该依赖它不需要的接口。这个原则指导我们在设计接口时 应当注意一下几点： </p>
<ol>
<li><p>一个类对一类的依赖应该建立在最小的接口之上。 </p>
</li>
<li><p>建立单一接口，不要建立庞大臃肿的接口。 </p>
</li>
<li><p>尽量细化接口，接口中的方法尽量少（不是越少越好，一定要适度）。 </p>
</li>
</ol>
<p>接口隔离原则符合我们常说的高内聚低耦合的设计思想，从而使得类具有很好的可读性、 可扩展性和可维护性。我们在设计接口的时候，要多花时间去思考，要考虑业务模型， 包括以后有可能发生变更的地方还要做一些预判。所以，对于抽象，对业务模型的理解是非常重要的。下面我们来看一段代码，写一个动物行为的抽象： </p>
<p>IAnimal 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAnimal</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bird 类实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">implements</span> <span class="title">IAnimal</span> </span>&#123; </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dog 类实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">IAnimal</span> </span>&#123; </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，Bird 的 swim()方法可能只能空着，Dog 的 fly()方法显然不可能的。这时候，我们针对不同动物行为来设计不同的接口，分别设计 IEatAnimal，IFlyAnimal 和 ISwimAnimal 接口，来看代码： </p>
<p>IEatAnimal 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IEatAnimal</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IFlyAnimal 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFlyAnimal</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ISwimAnimal 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISwimAnimal</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;                        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dog 只实现 IEatAnimal 和 ISwimAnimal 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">ISwimAnimal</span>,<span class="title">IEatAnimal</span> </span>&#123; </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看下两种类图的对比，还是非常清晰明了的：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfwl5vy67bj31g80hqngn.jpg" alt="image-20200618174753127"></p>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a><strong>迪米特法则</strong></h2><p>迪米特原则（Law of Demeter LoD）是指一个对象应该对其他对象保持最少的了解，又叫最少知道原则（Least Knowledge Principle,LKP），尽量降低类与类之间的耦合。迪米特原则主要强调只和朋友交流，不和陌生人说话。出现在成员变量、方法的输入、输 出参数中的类都可以称之为成员朋友类，而出现在方法体内部的类不属于朋友类。 </p>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a><strong>里氏替换原则</strong></h2><p>里氏替换原则（Liskov Substitution Principle,LSP）是指如果对每一个类型为 T1 的对 </p>
<p>象 o1,都有类型为 T2 的对象 o2,使得以 T1 定义的所有程序 P 在所有的对象 o1 都替换成 </p>
<p>o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。 </p>
<p>定义看上去还是比较抽象，我们重新理解一下，可以理解为一个软件实体如果适用一个 </p>
<p>父类的话，那一定是适用于其子类，所有引用父类的地方必须能透明地使用其子类的对 </p>
<p>象，子类对象能够替换父类对象，而程序逻辑不变。根据这个理解，我们总结一下： </p>
<p>引申含义：子类可以扩展父类的功能，但不能改变父类原有的功能。 </p>
<ol>
<li><p>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 </p>
</li>
<li><p>子类中可以增加自己特有的方法。 </p>
</li>
<li><p>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入/入参）要比父类 方法的输入参数更宽松。 </p>
</li>
<li><p>当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即 方法的输出/返回值）要比父类更严格或相等。</p>
</li>
</ol>
<p>使用里氏替换原则有以下优点： </p>
<ol>
<li><p>约束继承泛滥，开闭原则的一种体现。 </p>
</li>
<li><p>加强程序的健壮性，同时变更时也可以做到非常好的兼容性，提高程序的维护性、扩展性。降低需求变更时引入的风险。 </p>
</li>
</ol>
<h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a><strong>合成复用原则</strong></h2><p>合成复用原则（Composite/Aggregate Reuse Principle,CARP）是指尽量使用对象组合(has-a)/聚合(contanis-a)，而不是继承关系达到软件复用的目的。可以使系统更加灵 活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。 继承我们叫做白箱复用，相当于把所有的实现细节暴露给子类。组合/聚合也称之为黑箱 复用，对类以外的对象是无法获取到实现细节的。要根据具体的业务场景来做代码设计，其实也都需要遵循 OOP 模型。</p>
<h2 id="经典框架都在用设计模式解决问题"><a href="#经典框架都在用设计模式解决问题" class="headerlink" title="经典框架都在用设计模式解决问题"></a><strong>经典框架都在用设计模式解决问题</strong></h2><p>Spring 就是一个把设计模式用得淋漓尽致的经典框架，其实从类的命名就能看出来，我来一一列举：</p>
<table>
<thead>
<tr>
<th>设计模式名称</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>工厂模式</td>
<td>BeanFactory</td>
</tr>
<tr>
<td>装饰器模式</td>
<td>BeanWrapper</td>
</tr>
<tr>
<td>代理模式</td>
<td>AopProxy</td>
</tr>
<tr>
<td>委派模式</td>
<td>DispatcherServlet</td>
</tr>
<tr>
<td>策略模式</td>
<td>HandlerMapping</td>
</tr>
<tr>
<td>适配器模式</td>
<td>HandlerAdapter</td>
</tr>
<tr>
<td>模板模式</td>
<td>JdbcTemplate</td>
</tr>
<tr>
<td>观察者模式</td>
<td>ContextLoaderListener</td>
</tr>
</tbody></table>
<p>需要特别声明的是，设计模式从来都不是单个设计模式独立使用的。在实际应用中，通 常是多个设计模式混合使用，你中有我，我中有你。我们的课程中，会围绕 Spring 的 IOC、 AOP、MVC、JDBC 这样的思路展开，根据其设计类型来设计讲解顺序:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>英文</th>
</tr>
</thead>
<tbody><tr>
<td>创建型模式</td>
<td>工厂模式</td>
<td>Factory Pattern</td>
</tr>
<tr>
<td></td>
<td>单例模式</td>
<td>Singleton Pattern</td>
</tr>
<tr>
<td></td>
<td>原型模式</td>
<td>Prototype Pattern</td>
</tr>
<tr>
<td>结构型模式</td>
<td>适配器模式</td>
<td>Adapter Pattern</td>
</tr>
<tr>
<td></td>
<td>装饰器模式</td>
<td>Decorator Pattern</td>
</tr>
<tr>
<td></td>
<td>代理模式</td>
<td>Proxy Pattern</td>
</tr>
<tr>
<td>行为性模式</td>
<td>策略模式</td>
<td>Strategy Pattern</td>
</tr>
<tr>
<td></td>
<td>模板模式</td>
<td>Template Pattern</td>
</tr>
<tr>
<td></td>
<td>委派模式</td>
<td>Delegate Pattern</td>
</tr>
<tr>
<td></td>
<td>观察者模式</td>
<td>Observer Pattern</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>重量级锁（MutexLock）</title>
    <url>/2020/06/18/%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%88MutexLock%EF%BC%89/</url>
    <content><![CDATA[<h1 id="重量级锁（MutexLock）"><a href="#重量级锁（MutexLock）" class="headerlink" title="重量级锁（MutexLock）"></a>重量级锁（MutexLock）</h1><p>Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为“重量级锁”。JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>锁优化</title>
    <url>/2020/06/18/%E9%94%81%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h1><h2 id="减少锁持有时间"><a href="#减少锁持有时间" class="headerlink" title="减少锁持有时间"></a><strong>减少锁持有时间</strong></h2><p>只用在有线程安全要求的程序上加锁</p>
<h2 id="减小锁粒度"><a href="#减小锁粒度" class="headerlink" title="减小锁粒度"></a><strong>减小锁粒度</strong></h2><p>将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是ConcurrentHashMap。</p>
<h2 id="锁分离"><a href="#锁分离" class="headerlink" title="锁分离"></a><strong>锁分离</strong></h2><p>最常见的锁分离就是读写锁 ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能，具体也请查看[高并发 Java 五] JDK 并发包 1。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如LinkedBlockingQueue 从头部取出，从尾部放数据</p>
<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a><strong>锁粗化</strong></h2><p>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。</p>
<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a><strong>锁消除</strong></h2><p>锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作，多数是因为程序员编码不规范引起。</p>
<p>参考：<a href="https://www.jianshu.com/p/39628e1180a9" target="_blank" rel="noopener">https://www.jianshu.com/p/39628e1180a9</a></p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>轻量级锁</title>
    <url>/2020/06/18/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81/</url>
    <content><![CDATA[<h1 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h1><p>锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。</p>
<h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a><strong>锁升级</strong></h2><p>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。</p>
<p>“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
</search>
