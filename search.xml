<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ReentrantLock</title>
    <url>/2020/06/18/ReentrantLock/</url>
    <content><![CDATA[<h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><strong>ReentrantLock</strong></h1><p>ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。</p>
<h2 id="Lock-接口的主要方法"><a href="#Lock-接口的主要方法" class="headerlink" title="Lock 接口的主要方法"></a><strong>Lock</strong> <strong>接口的主要方法</strong></h2><ol>
<li><p>void lock(): 执行此方法时, 如果锁处于空闲状态, 当前线程将获取到锁. 相反, 如果锁已经被其他线程持有, 将禁用当前线程, 直到当前线程获取到锁.</p>
</li>
<li><p>boolean tryLock()：如果锁可用, 则获取锁, 并立即返回 true, 否则返回 false. 该方法和lock()的区别在于, tryLock()只是”试图”获取锁, 如果锁不可用, 不会导致当前线程被禁用, 当前线程仍然继续往下执行代码. 而 lock()方法则是一定要获取到锁, 如果锁不可用, 就一直等待, 在未获得锁之前,当前线程并不继续向下执行. </p>
</li>
<li><p>void unlock()：执行此方法时, 当前线程将释放持有的锁. 锁只能由持有者释放, 如果线程并不持有锁, 却执行该方法, 可能导致异常的发生.</p>
</li>
<li><p>Condition newCondition()：条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的 await()方法，而调用后，当前线程将缩放锁。</p>
</li>
<li><p>getHoldCount() ：查询当前线程保持此锁的次数，也就是执行此线程执行 lock 方法的次数。</p>
</li>
<li><p>getQueueLength（）：返回正等待获取此锁的线程估计数，比如启动 10 个线程，1 个线程获得锁，此时返回的是 9</p>
</li>
<li><p>getWaitQueueLength：（Condition condition）返回等待与此锁相关的给定条件的线程估计数。比如 10 个线程，用同一个 condition 对象，并且此时这 10 个线程都执行了condition 对象的 await 方法，那么此时执行此方法返回 10</p>
</li>
<li><p>hasWaiters(Condition condition)：查询是否有线程等待与此锁有关的给定条件</p>
</li>
</ol>
<p>(condition)，对于指定 contidion 对象，有多少线程执行了 condition.await 方法</p>
<ol start="9">
<li><p>hasQueuedThread(Thread thread)：查询给定线程是否等待获取此锁</p>
</li>
<li><p>hasQueuedThreads()：是否有线程等待此锁</p>
</li>
<li><p>isFair()：该锁是否公平锁</p>
</li>
<li><p>isHeldByCurrentThread()： 当前线程是否保持锁锁定，线程的执行 lock 方法的前后分别是 false 和 true</p>
</li>
<li><p>isLock()：此锁是否有任意线程占用</p>
</li>
<li><p>lockInterruptibly（）：如果当前线程未被中断，获取锁</p>
</li>
<li><p>tryLock（）：尝试获得锁，仅在调用时锁未被线程占用，获得锁</p>
</li>
<li><p>tryLock(long timeout TimeUnit unit)：如果锁在给定等待时间内没有被另一个线程保持，则获取该锁。</p>
</li>
</ol>
<h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a><strong>非公平锁</strong></h2><p>JVM 按随机、就近原则分配锁的机制则称为不公平锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式，默认为非公平锁。非公平锁实际执行的效率要远远超出公平锁，除非程序有特殊需要，否则最常用非公平锁的分配机制。</p>
<h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a><strong>公平锁</strong></h2><p>公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式来定义公平锁。</p>
<h2 id="ReentrantLock-与-synchronized"><a href="#ReentrantLock-与-synchronized" class="headerlink" title="ReentrantLock 与 synchronized"></a><strong>ReentrantLock</strong> <strong>与</strong> <strong>synchronized</strong></h2><ol>
<li><p>ReentrantLock 通过方法 lock()与 unlock()来进行加锁与解锁操作，与 synchronized 会 被 JVM 自动解锁机制不同，ReentrantLock 加锁后需要手动进行解锁。为了避免程序出现异常而无法正常解锁的情况，使用 ReentrantLock 必须在 finally 控制块中进行解锁操作。</p>
</li>
<li><p>ReentrantLock 相比 synchronized 的优势是可中断、公平锁、多个锁。这种情况下需要使用 ReentrantLock。</p>
</li>
</ol>
<h3 id="ReentrantLock-实现"><a href="#ReentrantLock-实现" class="headerlink" title="ReentrantLock 实现"></a><strong>ReentrantLock</strong> <strong>实现</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//Lock lock=new ReentrantLock(true);//公平锁</span></span><br><span class="line"><span class="comment">//Lock lock=new ReentrantLock(false);//非公平锁</span></span><br><span class="line"><span class="keyword">private</span> Condition condition=lock.newCondition();<span class="comment">//创建 Condition</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();<span class="comment">//lock 加锁</span></span><br><span class="line"><span class="comment">//1：wait 方法等待：</span></span><br><span class="line"><span class="comment">//System.out.println("开始 wait");</span></span><br><span class="line">condition.await();</span><br><span class="line"><span class="comment">//通过创建 Condition 对象来使线程 wait，必须先执行 lock.lock 方法获得锁</span></span><br><span class="line"><span class="comment">//:2：signal 方法唤醒</span></span><br><span class="line">condition.signal();<span class="comment">//condition 对象的 signal 方法可以唤醒 wait 线程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"ThreadName="</span> + Thread.currentThread().getName()+ (<span class="string">" "</span> + (i + <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line"><span class="number">121623125152125125</span></span><br><span class="line">&#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125; &#125; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Condition-类和-Object-类锁方法区别区别"><a href="#Condition-类和-Object-类锁方法区别区别" class="headerlink" title="Condition 类和 Object 类锁方法区别区别"></a><strong>Condition</strong> <strong>类和</strong> <strong>Object</strong> <strong>类锁方法区别区别</strong></h3><ol>
<li><p>Condition 类的 awiat 方法和 Object 类的 wait 方法等效</p>
</li>
<li><p>Condition 类的 signal 方法和 Object 类的 notify 方法等效</p>
</li>
<li><p>Condition 类的 signalAll 方法和 Object 类的 notifyAll 方法等效</p>
</li>
<li><p>ReentrantLock 类可以唤醒指定条件的线程，而 object 的唤醒是随机的</p>
</li>
</ol>
<h3 id="tryLock-和-lock-和-lockInterruptibly-的区别"><a href="#tryLock-和-lock-和-lockInterruptibly-的区别" class="headerlink" title="tryLock 和 lock 和 lockInterruptibly 的区别"></a><strong>tryLock</strong> <strong>和</strong> <strong>lock</strong> <strong>和</strong> <strong>lockInterruptibly</strong> <strong>的区别</strong></h3><ol>
<li><p>tryLock 能获得锁就返回 true，不能就立即返回 false，tryLock(long timeout,TimeUnit unit)，可以增加时间限制，如果超过该时间段还没获得锁，返回 false</p>
</li>
<li><p>lock 能获得锁就返回 true，不能的话一直等待获得锁</p>
</li>
<li><p>lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程，lock 不会抛出异常，而 lockInterruptibly 会抛出异常。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-ioc运行时序解析</title>
    <url>/2020/06/18/spring-ioc%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%8F%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="spring-ioc运行时序解析"><a href="#spring-ioc运行时序解析" class="headerlink" title="spring-ioc运行时序解析"></a>spring-ioc运行时序解析</h1><h2 id="Spring-核心之-IOC-容器初体验"><a href="#Spring-核心之-IOC-容器初体验" class="headerlink" title="Spring 核心之 IOC 容器初体验"></a>Spring 核心之 IOC 容器初体验</h2><h3 id="再谈-IOC-与-DI"><a href="#再谈-IOC-与-DI" class="headerlink" title="再谈 IOC 与 DI"></a><strong>再谈 IOC 与 DI</strong></h3><p><strong>IOC</strong>(Inversion of Control)控制反转：所谓控制反转，就是把原先我们代码里面需要实现的对象创 建、依赖的代码，反转给容器来帮忙实现。那么必然的我们需要创建一个容器，同时需要一种描述来让 容器知道需要创建的对象与对象的关系。这个描述最具体表现就是我们所看到的配置文件。 </p>
<p><strong>DI</strong>(Dependency Injection)依赖注入：就是指对象是被动接受依赖类而不是自己主动去找，换句话说就 是指对象不是从容器中查找它依赖的类，而是在容器实例化对象的时候主动将它依赖的类注入给它。</p>
<h3 id="Spring-核心容器类图"><a href="#Spring-核心容器类图" class="headerlink" title="Spring 核心容器类图"></a><strong>Spring 核心容器类图</strong></h3><h4 id="1、BeanFactory"><a href="#1、BeanFactory" class="headerlink" title="1、BeanFactory"></a><strong>1、BeanFactory</strong></h4><p>Spring Bean 的创建是典型的工厂模式，这一系列的 Bean 工厂，也即 IOC 容器为开发者管理对象间的依赖关系提供了很多便利和基础服务，在 Spring 中有许多的 IOC 容器的实现供用户选择和使用，其相互关系如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfw7h16t9ej317m0lg7ir.jpg" alt="image-20200618095413402"></p>
<p>其中 BeanFactory 作为最顶层的一个接口类，它定义了 IOC 容器的基本功能规范，BeanFactory 有三 个重要的子类：ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory。 但是从类图中我们可以发现最终的默认实现类是 DefaultListableBeanFactory，它实现了所有的接口。</p>
]]></content>
      <categories>
        <category>spring源码解读</category>
      </categories>
      <tags>
        <tag>spring-ioc</tag>
      </tags>
  </entry>
  <entry>
    <title>模仿spring-mvc</title>
    <url>/2020/06/17/%E6%A8%A1%E4%BB%BFspring-mvc/</url>
    <content><![CDATA[<h1 id="模仿spring-mvc"><a href="#模仿spring-mvc" class="headerlink" title="模仿spring-mvc"></a>模仿spring-mvc</h1><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfvnfa3619j31gm0tie81.jpg" alt="image-20200617222032762"></p>
<h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><h3 id="配置-application-properties-文件"><a href="#配置-application-properties-文件" class="headerlink" title="配置 application.properties 文件"></a>配置 application.properties 文件</h3><p>为了解析方便，我们用 application.properties 来代替 application.xml 文件，具体配置内容如下：</p>
<p>scanPackage=com.shoufeng.demo</p>
<h3 id="配置-web-xml-文件"><a href="#配置-web-xml-文件" class="headerlink" title="配置 web.xml 文件"></a>配置 web.xml 文件</h3><p>大家都知道，所有依赖于 web 容器的项目，都是从读取 web.xml 文件开始的。我们先配置好 web.xml 中的内容。 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">version</span>=<span class="string">"2.4"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>sf Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>sfmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.shoufeng.mvc.core.servlet.SFDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>application.properties<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>sfmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中 SFDispatcherServlet 是有自己模拟 Spring 实现的核心功能类。 </p>
<h3 id="自定义-Annotation"><a href="#自定义-Annotation" class="headerlink" title="自定义 Annotation"></a>自定义 Annotation</h3><h4 id="SFAutowired-注解："><a href="#SFAutowired-注解：" class="headerlink" title="@SFAutowired 注解："></a>@SFAutowired 注解：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoufeng.mvc.core.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shoufeng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SFAutowired &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SFController-注解："><a href="#SFController-注解：" class="headerlink" title="@SFController 注解："></a>@SFController 注解：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoufeng.mvc.core.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shoufeng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SFController &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SFRequestMapping-注解："><a href="#SFRequestMapping-注解：" class="headerlink" title="@SFRequestMapping 注解："></a>@SFRequestMapping 注解：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoufeng.mvc.core.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shoufeng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SFRequestMapping &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SFRequestParam-注解："><a href="#SFRequestParam-注解：" class="headerlink" title="@SFRequestParam 注解："></a>@SFRequestParam 注解：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoufeng.mvc.core.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shoufeng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.PARAMETER&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SFRequestParam &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SFService-注解："><a href="#SFService-注解：" class="headerlink" title="@SFService 注解："></a>@SFService 注解：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoufeng.mvc.core.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shoufeng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SFService &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="容器初始化"><a href="#容器初始化" class="headerlink" title="容器初始化"></a>容器初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoufeng.mvc.core.servlet;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.shoufeng.mvc.core.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shoufeng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SFDispatcherServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存application.properties配置文件中的内容</span></span><br><span class="line">    <span class="keyword">private</span> Properties contextConfig = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存扫描的所有的类名</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; classNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传说中的IOC容器，我们来揭开它的神秘面纱</span></span><br><span class="line">    <span class="comment">//为了简化程序，暂时不考虑ConcurrentHashMap</span></span><br><span class="line">    <span class="comment">// 主要还是关注设计思想和原理</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; ioc = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存url和Method的对应关系</span></span><br><span class="line"><span class="comment">//    private Map&lt;String,Method&gt; handlerMapping = new HashMap&lt;String,Method&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//思考：为什么不用Map</span></span><br><span class="line">    <span class="comment">//你用Map的话，key，只能是url</span></span><br><span class="line">    <span class="comment">//Handler 本身的功能就是把url和method对应关系，已经具备了Map的功能</span></span><br><span class="line">    <span class="comment">//根据设计原则：冗余的感觉了，单一职责，最少知道原则，帮助我们更好的理解</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Handler&gt; handlerMapping = <span class="keyword">new</span> ArrayList&lt;Handler&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6、调用，运行阶段</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doDispatch(req, resp);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            resp.getWriter().write(<span class="string">"500 Exection,Detail : "</span> + Arrays.toString(e.getStackTrace()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化阶段</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、加载配置文件</span></span><br><span class="line">        doLoadConfig(config.getInitParameter(<span class="string">"contextConfigLocation"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、扫描相关的类</span></span><br><span class="line">        doScanner(contextConfig.getProperty(<span class="string">"scanPackage"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、初始化扫描到的类，并且将它们放入到ICO容器之中</span></span><br><span class="line">        doInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、完成依赖注入</span></span><br><span class="line">        doAutowired();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5、初始化HandlerMapping</span></span><br><span class="line">        initHandlerMapping();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"SF Spring framework is init."</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Handler handler = getHandler(req);</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//        if(!this.handlerMapping.containsKey(url))&#123;</span></span><br><span class="line">            resp.getWriter().write(<span class="string">"404 Not Found!!!"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得方法的形参列表</span></span><br><span class="line">        Class&lt;?&gt;[] paramTypes = handler.getParamTypes();</span><br><span class="line"></span><br><span class="line">        Object[] paramValues = <span class="keyword">new</span> Object[paramTypes.length];</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String[]&gt; params = req.getParameterMap();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String[]&gt; parm : params.entrySet()) &#123;</span><br><span class="line">            String value = Arrays.toString(parm.getValue()).replaceAll(<span class="string">"\\[|\\]"</span>, <span class="string">""</span>)</span><br><span class="line">                    .replaceAll(<span class="string">"\\s"</span>, <span class="string">","</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!handler.paramIndexMapping.containsKey(parm.getKey())) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = handler.paramIndexMapping.get(parm.getKey());</span><br><span class="line">            paramValues[index] = convert(paramTypes[index], value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (handler.paramIndexMapping.containsKey(HttpServletRequest<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())) </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> reqIndex = handler.paramIndexMapping.get(HttpServletRequest<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">            paramValues[reqIndex] = req;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (handler.paramIndexMapping.containsKey(HttpServletResponse<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())) </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> respIndex = handler.paramIndexMapping.get(HttpServletResponse<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">            paramValues[respIndex] = resp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object returnValue = handler.method.invoke(handler.controller, paramValues);</span><br><span class="line">        <span class="keyword">if</span> (returnValue == <span class="keyword">null</span> || returnValue <span class="keyword">instanceof</span> Void) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        resp.getWriter().write(returnValue.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Handler <span class="title">getHandler</span><span class="params">(HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handlerMapping.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//绝对路径</span></span><br><span class="line">        String url = req.getRequestURI();</span><br><span class="line">        <span class="comment">//处理成相对路径</span></span><br><span class="line">        String contextPath = req.getContextPath();</span><br><span class="line">        url = url.replaceAll(contextPath, <span class="string">""</span>).replaceAll(<span class="string">"/+"</span>, <span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Handler handler : <span class="keyword">this</span>.handlerMapping) &#123;</span><br><span class="line">            Matcher matcher = handler.getPattern().matcher(url);</span><br><span class="line">            <span class="keyword">if</span> (!matcher.matches()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> handler;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//url传过来的参数都是String类型的，HTTP是基于字符串协议</span></span><br><span class="line">    <span class="comment">//只需要把String转换为任意类型就好</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">convert</span><span class="params">(Class&lt;?&gt; type, String value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果是int</span></span><br><span class="line">        <span class="keyword">if</span> (Integer<span class="class">.<span class="keyword">class</span> </span>== type) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.valueOf(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Double<span class="class">.<span class="keyword">class</span> </span>== type) &#123;</span><br><span class="line">            <span class="keyword">return</span> Double.valueOf(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果还有double或者其他类型，继续加if</span></span><br><span class="line">        <span class="comment">//这时候，我们应该想到策略模式了</span></span><br><span class="line">        <span class="comment">//在这里暂时不实现，希望小伙伴自己来实现</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化url和Method的一对一对应关系</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ioc.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : ioc.entrySet()) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = entry.getValue().getClass();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!clazz.isAnnotationPresent(SFController<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//保存写在类上面的@SFRequestMapping("/demo")</span></span><br><span class="line">            String baseUrl = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">if</span> (clazz.isAnnotationPresent(SFRequestMapping<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                SFRequestMapping requestMapping = clazz.getAnnotation(SFRequestMapping<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                baseUrl = requestMapping.value();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//默认获取所有的public方法</span></span><br><span class="line">            <span class="keyword">for</span> (Method method : clazz.getMethods()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!method.isAnnotationPresent(SFRequestMapping<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                SFRequestMapping requestMapping = method.getAnnotation(SFRequestMapping<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                <span class="comment">//优化</span></span><br><span class="line">                <span class="comment">// //demo///query</span></span><br><span class="line">                String regex = (<span class="string">"/"</span> + baseUrl + <span class="string">"/"</span> + requestMapping.value())</span><br><span class="line">                        .replaceAll(<span class="string">"/+"</span>, <span class="string">"/"</span>);</span><br><span class="line">                Pattern pattern = Pattern.compile(regex);</span><br><span class="line">                <span class="keyword">this</span>.handlerMapping.add(<span class="keyword">new</span> Handler(pattern, entry.getValue(), method));</span><br><span class="line"><span class="comment">//                handlerMapping.put(url,method);</span></span><br><span class="line">                System.out.println(<span class="string">"Mapped :"</span> + pattern + <span class="string">","</span> + method);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自动依赖注入</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAutowired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ioc.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : ioc.entrySet()) &#123;</span><br><span class="line">            <span class="comment">//Declared 所有的，特定的 字段，包括private/protected/default</span></span><br><span class="line">            <span class="comment">//正常来说，普通的OOP编程只能拿到public的属性</span></span><br><span class="line">            Field[] fields = entry.getValue().getClass().getDeclaredFields();</span><br><span class="line">            <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!field.isAnnotationPresent(SFAutowired<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                SFAutowired autowired = field.getAnnotation(SFAutowired<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果用户没有自定义beanName，默认就根据类型注入</span></span><br><span class="line">                <span class="comment">//这个地方省去了对类名首字母小写的情况的判断，这个作为课后作业</span></span><br><span class="line">                <span class="comment">//小伙伴们自己去完善</span></span><br><span class="line">                String beanName = autowired.value().trim();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">""</span>.equals(beanName)) &#123;</span><br><span class="line">                    <span class="comment">//获得接口的类型，作为key待会拿这个key到ioc容器中去取值</span></span><br><span class="line">                    beanName = field.getType().getName();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果是public以外的修饰符，只要加了@Autowired注解，都要强制赋值</span></span><br><span class="line">                <span class="comment">//反射中叫做暴力访问， 强吻</span></span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//用反射机制，动态给字段赋值</span></span><br><span class="line">                    field.set(entry.getValue(), ioc.get(beanName));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化，为DI做准备</span></span><br><span class="line">        <span class="keyword">if</span> (classNames.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (String className : classNames) &#123;</span><br><span class="line">                Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//什么样的类才需要初始化呢？</span></span><br><span class="line">                <span class="comment">//加了注解的类，才初始化，怎么判断？</span></span><br><span class="line">                <span class="comment">//为了简化代码逻辑，主要体会设计思想，只举例 @Controller和@Service,</span></span><br><span class="line">                <span class="comment">// @Componment...就一一举例了</span></span><br><span class="line">                <span class="keyword">if</span> (clazz.isAnnotationPresent(SFController<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                    Object instance = clazz.newInstance();</span><br><span class="line">                    <span class="comment">//Spring默认类名首字母小写</span></span><br><span class="line">                    String beanName = toLowerFirstCase(clazz.getSimpleName());</span><br><span class="line">                    ioc.put(beanName, instance);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz.isAnnotationPresent(SFService<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                    <span class="comment">//1、自定义的beanName</span></span><br><span class="line">                    SFService service = clazz.getAnnotation(SFService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                    String beanName = service.value();</span><br><span class="line">                    <span class="comment">//2、默认类名首字母小写</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">""</span>.equals(beanName.trim())) &#123;</span><br><span class="line">                        beanName = toLowerFirstCase(clazz.getSimpleName());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Object instance = clazz.newInstance();</span><br><span class="line">                    ioc.put(beanName, instance);</span><br><span class="line">                    <span class="comment">//3、根据类型自动赋值,投机取巧的方式</span></span><br><span class="line">                    <span class="keyword">for</span> (Class&lt;?&gt; i : clazz.getInterfaces()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (ioc.containsKey(i.getName())) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"The “"</span> + i.getName() + <span class="string">"” is exists!!"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//把接口的类型直接当成key了</span></span><br><span class="line">                        ioc.put(i.getName(), instance);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果类名本身是小写字母，确实会出问题</span></span><br><span class="line">    <span class="comment">//但是我要说明的是：这个方法是我自己用，private的</span></span><br><span class="line">    <span class="comment">//传值也是自己传，类也都遵循了驼峰命名法</span></span><br><span class="line">    <span class="comment">//默认传入的值，存在首字母小写的情况，也不可能出现非字母的情况</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了简化程序逻辑，就不做其他判断了，大家了解就OK</span></span><br><span class="line">    <span class="comment">//其实用写注释的时间都能够把逻辑写完了</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">toLowerFirstCase</span><span class="params">(String simpleName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = simpleName.toCharArray();</span><br><span class="line">        <span class="comment">//之所以加，是因为大小写字母的ASCII码相差32，</span></span><br><span class="line">        <span class="comment">// 而且大写字母的ASCII码要小于小写字母的ASCII码</span></span><br><span class="line">        <span class="comment">//在Java中，对char做算学运算，实际上就是对ASCII码做算学运算</span></span><br><span class="line">        chars[<span class="number">0</span>] += <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(chars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//扫描出相关的类</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doScanner</span><span class="params">(String scanPackage)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//scanPackage = com.gupaoedu.demo ，存储的是包路径</span></span><br><span class="line">        <span class="comment">//转换为文件路径，实际上就是把.替换为/就OK了</span></span><br><span class="line">        <span class="comment">//classpath</span></span><br><span class="line">        URL url = <span class="keyword">this</span>.getClass().getClassLoader().getResource(<span class="string">"/"</span> + scanPackage.replaceAll(<span class="string">"\\."</span>, <span class="string">"/"</span>));</span><br><span class="line">        File classPath = <span class="keyword">new</span> File(url.getFile());</span><br><span class="line">        <span class="keyword">for</span> (File file : classPath.listFiles()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                doScanner(scanPackage + <span class="string">"."</span> + file.getName());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!file.getName().endsWith(<span class="string">".class"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String className = (scanPackage + <span class="string">"."</span> + file.getName().replace(<span class="string">".class"</span>, <span class="string">""</span>));</span><br><span class="line">                classNames.add(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载配置文件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doLoadConfig</span><span class="params">(String contextConfigLocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//直接从类路径下找到Spring主配置文件所在的路径</span></span><br><span class="line">        <span class="comment">//并且将其读取出来放到Properties对象中</span></span><br><span class="line">        <span class="comment">//相对于scanPackage=com.gupaoedu.demo 从文件中保存到了内存中</span></span><br><span class="line">        InputStream fis = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(contextConfigLocation);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            contextConfig.load(fis);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != fis) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存一个url和一个Method的关系</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="comment">//必须把url放到HandlerMapping才好理解吧</span></span><br><span class="line">        <span class="keyword">private</span> Pattern pattern;  <span class="comment">//正则</span></span><br><span class="line">        <span class="keyword">private</span> Method method;</span><br><span class="line">        <span class="keyword">private</span> Object controller;</span><br><span class="line">        <span class="keyword">private</span> Class&lt;?&gt;[] paramTypes;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Pattern <span class="title">getPattern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pattern;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> method;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> controller;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt;[] getParamTypes() &#123;</span><br><span class="line">            <span class="keyword">return</span> paramTypes;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//形参列表</span></span><br><span class="line">        <span class="comment">//参数的名字作为key,参数的顺序，位置作为值</span></span><br><span class="line">        <span class="keyword">private</span> Map&lt;String, Integer&gt; paramIndexMapping;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Pattern pattern, Object controller, Method method)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.pattern = pattern;</span><br><span class="line">            <span class="keyword">this</span>.method = method;</span><br><span class="line">            <span class="keyword">this</span>.controller = controller;</span><br><span class="line"></span><br><span class="line">            paramTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">            paramIndexMapping = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">            putParamIndexMapping(method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putParamIndexMapping</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//提取方法中加了注解的参数</span></span><br><span class="line">            <span class="comment">//把方法上的注解拿到，得到的是一个二维数组</span></span><br><span class="line">            <span class="comment">//因为一个参数可以有多个注解，而一个方法又有多个参数</span></span><br><span class="line">            Annotation[][] pa = method.getParameterAnnotations();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pa.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Annotation a : pa[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a <span class="keyword">instanceof</span> SFRequestParam) &#123;</span><br><span class="line">                        String paramName = ((SFRequestParam) a).value();</span><br><span class="line">                        <span class="keyword">if</span> (!<span class="string">""</span>.equals(paramName.trim())) &#123;</span><br><span class="line">                            paramIndexMapping.put(paramName, i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//提取方法中的request和response参数</span></span><br><span class="line">            Class&lt;?&gt;[] paramsTypes = method.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paramsTypes.length; i++) &#123;</span><br><span class="line">                Class&lt;?&gt; type = paramsTypes[i];</span><br><span class="line">                <span class="keyword">if</span> (type == HttpServletRequest<span class="class">.<span class="keyword">class</span> ||</span></span><br><span class="line"><span class="class">                        <span class="title">type</span> </span>== HttpServletResponse<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    paramIndexMapping.put(type.getName(), i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行效果演示"><a href="#运行效果演示" class="headerlink" title="运行效果演示"></a>运行效果演示</h2><h3 id="启动tomcat"><a href="#启动tomcat" class="headerlink" title="启动tomcat"></a>启动tomcat</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfvog5hpifj31h50u0kbt.jpg" alt="image-20200617225559239"></p>
<h3 id="访问接口"><a href="#访问接口" class="headerlink" title="访问接口"></a>访问接口</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfvogof4xpj31j80to77l.jpg" alt="image-20200617225629999"></p>
]]></content>
      <categories>
        <category>spring源码解读</category>
      </categories>
      <tags>
        <tag>模仿spring-mvc</tag>
      </tags>
  </entry>
  <entry>
    <title>Synchronized同步锁</title>
    <url>/2020/06/17/Synchronized%E5%90%8C%E6%AD%A5%E9%94%81/</url>
    <content><![CDATA[<h1 id="Synchronized同步锁"><a href="#Synchronized同步锁" class="headerlink" title="Synchronized同步锁"></a>Synchronized同步锁</h1><p>synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重入锁。</p>
<h2 id="Synchronized-作用范围"><a href="#Synchronized-作用范围" class="headerlink" title="Synchronized 作用范围"></a><strong>Synchronized</strong> <strong>作用范围</strong></h2><ol>
<li><p>作用于方法时，锁住的是对象的实例(this)；</p>
</li>
<li><p>当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen（jdk1.8 则是 metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程；</p>
</li>
<li><p>synchronized 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。</p>
</li>
</ol>
<h2 id="Synchronized-核心组件"><a href="#Synchronized-核心组件" class="headerlink" title="Synchronized 核心组件"></a><strong>Synchronized</strong> <strong>核心组件</strong></h2><ol>
<li><p>Wait Set：哪些调用 wait 方法被阻塞的线程被放置在这里；</p>
</li>
<li><p>Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；</p>
</li>
<li><p>Entry List：Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中；</p>
</li>
<li><p>OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck；</p>
</li>
<li><p>Owner：当前已经获取到所资源的线程被称为 Owner；</p>
</li>
<li><p>!Owner：当前释放锁的线程。</p>
</li>
</ol>
<h2 id="Synchronized-实现"><a href="#Synchronized-实现" class="headerlink" title="Synchronized 实现"></a><strong>Synchronized</strong> <strong>实现</strong></h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfwhot9cepj317s0jstod.jpg" alt="image-20200618154736405"></p>
<ol>
<li><p>JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争，JVM 会将一部分线程移动到 EntryList 中作为候选竞争线程。</p>
</li>
<li><p>Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并指定EntryList 中的某个线程为 OnDeck 线程（一般是最先进去的那个线程）。</p>
</li>
<li><p>Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck，OnDeck 需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM 中，也把这种选择行为称之为“竞争切换”。</p>
</li>
<li><p>OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList中。如果 Owner 线程被 wait 方法阻塞，则转移到 WaitSet 队列中，直到某个时刻通过 notify或者 notifyAll 唤醒，会重新进去 EntryList 中。</p>
</li>
<li><p>处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux 内核下采用 pthread_mutex_lock 内核函数实现的）。</p>
</li>
<li><p>Synchronized 是非公平锁。 Synchronized 在线程进入 ContentionList 时，等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源。参考：<a href="https://blog.csdn.net/zqz_zqz/article/details/70233767" target="_blank" rel="noopener">https://blog.csdn.net/zqz_zqz/article/details/70233767</a></p>
</li>
<li><p>每个对象都有个 monitor 对象，加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的</p>
</li>
<li><p>synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。</p>
</li>
<li><p>Java1.6，synchronized 进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。</p>
</li>
<li><p>锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀；</p>
</li>
<li><p>JDK 1.6 中默认是开启偏向锁和轻量级锁，可以通过-XX:-UseBiasedLocking 来禁用偏向锁。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>乐观锁、悲观锁、自旋锁</title>
    <url>/2020/06/17/%E4%B9%90%E8%A7%82%E9%94%81%E3%80%81%E6%82%B2%E8%A7%82%E9%94%81%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81/</url>
    <content><![CDATA[<h1 id="乐观锁、悲观锁、自旋锁"><a href="#乐观锁、悲观锁、自旋锁" class="headerlink" title="乐观锁、悲观锁、自旋锁"></a>乐观锁、悲观锁、自旋锁</h1><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a><strong>乐观锁</strong></h2><p>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。</p>
<p>java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。</p>
<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a><strong>悲观锁</strong></h2><p>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。</p>
<p>java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如 RetreenLock。</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a><strong>自旋锁</strong></h2><p>自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p>
<p>线程自旋是需要消耗 cup 的，说白了就是让 cup 在做无用功，如果一直获取不到锁，那线程也不能一直占用 cup 自旋做无用功，所以需要设定一个自旋等待的最大时间。</p>
<p>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p>
<h3 id="自旋锁的优缺点"><a href="#自旋锁的优缺点" class="headerlink" title="自旋锁的优缺点"></a><strong>自旋锁的优缺点</strong></h3><p>自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！</p>
<p>但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cup 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁；自旋锁时间阈值（1.6 引入了适应性自旋锁）自旋锁的目的是为了占着 CPU 的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！</p>
<p>JVM 对于自旋周期的选择，jdk1.5 这个限度是一定的写死的，在 1.6 引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时 JVM 还针对当前 CPU 的负荷情况做了较多的优化，如果平均负载小于 CPUs 则一直自旋，如果有超过(CPUs/2)个线程正在自旋，则后来线程直接阻塞，如果正在自旋的线程发现 Owner 发生了变化则延迟自旋时间（自旋计数）或进入阻塞，如果 CPU 处于节电模式则停止自旋，自旋时间的最坏情况是 CPU的存储延迟（CPU A 存储了一个数据，到 CPU B 得知这个数据直接的时间差），自旋时会适当放弃线程优先级之间的差异。</p>
<p><strong>自旋锁的开启</strong></p>
<p>JDK1.6 中-XX:+UseSpinning 开启；</p>
<p>-XX:PreBlockSpin=10 为自旋次数；</p>
<p>JDK1.7 后，去掉此参数，由 jvm 控制；</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java锁</tag>
      </tags>
  </entry>
</search>
