<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"shoufengsfsf.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="MyBatis源码解读带着问题去看源码分析源码，我们还是从编程式的 demo 入手。Spring 的集成我们会在后面讲到。 12345InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder(">
<meta property="og:type" content="article">
<meta property="og:title" content="mybatis源码解读">
<meta property="og:url" content="https://shoufengsfsf.github.io/2020/06/23/mybatis%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/index.html">
<meta property="og:site_name" content="shoufengsfsf.github.io">
<meta property="og:description" content="MyBatis源码解读带着问题去看源码分析源码，我们还是从编程式的 demo 入手。Spring 的集成我们会在后面讲到。 12345InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder(">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gg2mz0ztjcj31oi06k7ac.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gg2ngkhjv1j31fc0ga7fi.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gg35rjp601j30gq048dgn.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gg35rv0bd4j30nq0g2go8.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gg35spwtenj30ne0f476h.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gg35tbjh37j30r004m78r.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gg367vzctdj30jk0cyn5z.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gg369bsc1fj30hk0foqbg.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gg36abstc8j30rq08878a.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gg36f8f6e5j30ei02y75v.jpg">
<meta property="article:published_time" content="2020-06-23T15:17:58.000Z">
<meta property="article:modified_time" content="2020-06-24T02:38:21.905Z">
<meta property="article:author" content="shoufeng">
<meta property="article:tag" content="mybatis源码解读">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gg2mz0ztjcj31oi06k7ac.jpg">

<link rel="canonical" href="https://shoufengsfsf.github.io/2020/06/23/mybatis%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>mybatis源码解读 | shoufengsfsf.github.io</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">shoufengsfsf.github.io</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shoufengsfsf.github.io/2020/06/23/mybatis%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shoufeng">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shoufengsfsf.github.io">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          mybatis源码解读
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-23 23:17:58" itemprop="dateCreated datePublished" datetime="2020-06-23T23:17:58+08:00">2020-06-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-24 10:38:21" itemprop="dateModified" datetime="2020-06-24T10:38:21+08:00">2020-06-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mybatis%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">mybatis源码解读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="MyBatis源码解读"><a href="#MyBatis源码解读" class="headerlink" title="MyBatis源码解读"></a>MyBatis源码解读</h1><h2 id="带着问题去看源码"><a href="#带着问题去看源码" class="headerlink" title="带着问题去看源码"></a>带着问题去看源码</h2><p>分析源码，我们还是从编程式的 demo 入手。Spring 的集成我们会在后面讲到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream); </span><br><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">BlogMapper mapper = session.getMapper(BlogMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Blog blog = mapper.selectBlogById(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>把文件读取成流的这一步我们就省略了。所以下面我们分成四步来分析。</p>
<p>第一步，我们通过建造者模式创建一个工厂类，配置文件的解析就是在这一步完成 的，包括 mybatis-config.xml 和 Mapper 适配器文件。</p>
<p>问题:解析的时候怎么解析的，做了什么，产生了什么对象，结果存放到了哪里。 解析的结果决定着我们后面有什么对象可以使用，和到哪里去取。</p>
<p>第二步，通过 SqlSessionFactory 创建一个 SqlSession。</p>
<p>问题:SqlSession 是用来操作数据库的，返回了什么实现类，除了 SqlSession，还 创建了什么对象，创建了什么环境?</p>
<p>第三步，获得一个 Mapper 对象。</p>
<p>问题:Mapper 是一个接口，没有实现类，是不能被实例化的，那获取到的这个 Mapper 对象是什么对象?为什么要从 SqlSession 里面去获取?为什么传进去一个接 口，然后还要用接口类型来接收?</p>
<p>第四步，调用接口方法。</p>
<p>问题:我们的接口没有创建实现类，为什么可以调用它的方法?那它调用的是什么 方法?它又是根据什么找到我们要执行的 SQL 的?也就是接口方法怎么和 XML 映射器 里面的 StatementID 关联起来的?</p>
<p>此外，我们的方法参数是怎么转换成 SQL 参数的?获取到的结果集是怎么转换成对 象的?</p>
<p>接下来我们就会详细分析每一步的流程，包括里面有哪些核心的对象和关键的方法。</p>
<h2 id="一、配置解析过程"><a href="#一、配置解析过程" class="headerlink" title="一、配置解析过程"></a>一、配置解析过程</h2><p>首先我们要清楚的是配置解析的过程全部只解析了两种文件。一个是 mybatis-config.xml 全局配置文件。另外就是可能有很多个的 Mapper.xml 文件，也包 括在 Mapper 接口类上面定义的注解。</p>
<p>我们从 mybatis-config.xml 开始。在第一节课的时候我们已经分析了核心配置了， 大概明白了 MyBatis 有哪些配置项，和这些配置项的大致含义。这里我们再具体看一下 这里面的标签都是怎么解析的，解析的时候做了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure>

<p>首先我们 new 了一个 SqlSessionFactoryBuilder，非常明显的建造者模式，它里面 定义了很多个 build 方法的重载，最终返回的是一个 SqlSessionFactory 对象(单例模 式)。我们点进去 build 方法。</p>
<p>这里面创建了一个 XMLConfigBuilder 对象(Configuration 对象也是这个时候创 建的)。</p>
<h3 id="XMLConfigBuilder"><a href="#XMLConfigBuilder" class="headerlink" title="XMLConfigBuilder"></a>XMLConfigBuilder</h3><p>XMLConfigBuilder 是抽象类 BaseBuilder 的一个子类，专门用来解析全局配置文 件，针对不同的构建目标还有其他的一些子类，比如:</p>
<p>XMLMapperBuilder:解析 Mapper 映射器 </p>
<p>XMLStatementBuilder:解析增删改查标签</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg2mz0ztjcj31oi06k7ac.jpg" alt="image-20200623232353388"></p>
<p>根据我们解析的文件流，这里后面两个参数都是空的，创建了一个 parser。</p>
<p>这里有两步，第一步是调用 parser 的 parse()方法，它会返回一个 Configuration 类。</p>
<p>之前我们说过，也就是配置文件里面所有的信息都会放在 Configuration 里面。 Configuration 类里面有很多的属性，有很多是跟 config 里面的标签直接对应的。</p>
<p>我们先看一下 parse()方法:</p>
<p>首先会检查是不是已经解析过，也就是说在应用的生命周期里面，config 配置文件</p>
<p>只需要解析一次，生成的 Configuration 对象也会存在应用的整个生命周期中。接下来就是 parseConfiguration 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseConfiguration(parser.evalNode(<span class="string">"/configuration"</span>));</span><br></pre></td></tr></table></figure>

<p>这下面有十几个方法，对应着 config 文件里面的所有一级标签。</p>
<p>问题:MyBatis 全局配置文件的顺序可以颠倒吗?</p>
<h3 id="propertiesElement"><a href="#propertiesElement" class="headerlink" title="propertiesElement()"></a>propertiesElement()</h3><p>第一个是解析&lt;properties&gt;标签，读取我们引入的外部配置文件。这里面又有两种 类型，一种是放在 resource 目录下的，是相对路径，一种是写的绝对路径的。解析的最 终结果就是我们会把所有的配置信息放到名为 defaults 的 Properties 对象里面，最后把 XPathParser 和 Configuration 的 Properties 属性都设置成我们填充后的 Properties 对象。</p>
<h3 id="settingsAsProperties"><a href="#settingsAsProperties" class="headerlink" title="settingsAsProperties()"></a>settingsAsProperties()</h3><p>第二个，我们把&lt;settings&gt;标签也解析成了一个 Properties 对象，对于&lt;settings&gt; 标签的子标签的处理在后面。</p>
<p>在早期的版本里面解析和设置都是在后面一起的，这里先解析成 Properties 对象是 因为下面的两个方法要用到。</p>
<h3 id="loadCustomVfs-settings"><a href="#loadCustomVfs-settings" class="headerlink" title="loadCustomVfs(settings)"></a>loadCustomVfs(settings)</h3><p>loadCustomVfs 是获取 Vitual File System 的自定义实现类，比如我们要读取本地 文件，或者 FTP 远程文件的时候，就可以用到自定义的 VFS 类。我们根据&lt;settings&gt;标 签里面的&lt;vfsImpl&gt;标签，生成了一个抽象类 VFS 的子类，并且赋值到 Configuration 中。</p>
<h3 id="loadCustomLogImpl-settings"><a href="#loadCustomLogImpl-settings" class="headerlink" title="loadCustomLogImpl(settings)"></a>loadCustomLogImpl(settings)</h3><p>loadCustomLogImpl 是根据&lt;logImpl&gt;标签获取日志的实现类，我们可以用到很 多的日志的方案，包括 LOG4J，LOG4J2，SLF4J 等等。这里生成了一个 Log 接口的实 现类，并且赋值到 Configuration 中。</p>
<h3 id="typeAliasesElement"><a href="#typeAliasesElement" class="headerlink" title="typeAliasesElement()"></a>typeAliasesElement()</h3><p>接下来，我们解析&lt;typeAliases&gt;标签，我们在讲配置的时候也讲过，它有两种定义 方式，一种是直接定义一个类的别名，一种就是指定一个包，那么这个 package 下面所 有的类的名字就会成为这个类全路径的别名。</p>
<p>类的别名和类的关系，我们放在一个 TypeAliasRegistry 对象里面。</p>
<h3 id="pluginElement"><a href="#pluginElement" class="headerlink" title="pluginElement()"></a>pluginElement()</h3><p>接下来就是解析&lt;plugins&gt;标签，比如 Pagehelper 的翻页插件，或者我们自定义的 插件。&lt;plugins&gt;标签里面只有&lt;plugin&gt;标签，&lt;plugin&gt;标签里面只有&lt;property&gt;标 签。</p>
<p>标签解析完以后，会生成一个 Interceptor 对象，并且添加到 Configuration 的 InterceptorChain 属性里面，它是一个 List。</p>
<h3 id="objectFactoryElement-、objectWrapperFactoryElement"><a href="#objectFactoryElement-、objectWrapperFactoryElement" class="headerlink" title="objectFactoryElement()、objectWrapperFactoryElement()"></a>objectFactoryElement()、objectWrapperFactoryElement()</h3><p>接 下 来 的 两 个 标 签 是 用 来 实 例 化 对 象 用 的 ， &lt;objectFactory&gt; 和 &lt;objectWrapperFactory&gt; 这 两 个 标 签 ， 分 别 生 成 ObjectFactory 、 ObjectWrapperFactory 对象，同样设置到 Configuration 的属性里面。</p>
<h3 id="reflectorFactoryElement"><a href="#reflectorFactoryElement" class="headerlink" title="reflectorFactoryElement()"></a>reflectorFactoryElement()</h3><p>解析 reflectorFactory 标签，生成 ReflectorFactory 对象(在官方 3.5.1 的 pdf 文 档里面没有找到这个配置)。</p>
<h3 id="settingsElement-settings"><a href="#settingsElement-settings" class="headerlink" title="settingsElement(settings)"></a>settingsElement(settings)</h3><p>这里就是对&lt;settings&gt;标签里面所有子标签的处理了，前面我们已经把子标签全部 转换成了 Properties 对象，所以在这里处理 Properties 对象就可以了。</p>
<p>二级标签里面有很多的配置，比如二级缓存，延迟加载，自动生成主键这些。需要 注意的是，我们之前提到的所有的默认值，都是在这里赋值的。如果说后面我们不知道这个属性的值是什么，也可以到这一步来确认一下。</p>
<p>所有的值，都会赋值到 Configuration 的属性里面去。</p>
<h3 id="environmentsElement"><a href="#environmentsElement" class="headerlink" title="environmentsElement()"></a>environmentsElement()</h3><p>这一步是解析&lt;environments&gt;标签。</p>
<p>我们前面讲过，一个 environment 就是对应一个数据源，所以在这里我们会根据配 置的&lt;transactionManager&gt;创建一个事务工厂，根据&lt;dataSource&gt;标签创建一个数据 源，最后把这两个对象设置成 Environment 对象的属性，放到 Configuration 里面。</p>
<p>回答了前面的问题:数据源工厂和数据源在哪里创建。 先记下这个问题:数据源和事务工厂在哪里会用到?</p>
<h3 id="databaseIdProviderElement"><a href="#databaseIdProviderElement" class="headerlink" title="databaseIdProviderElement()"></a>databaseIdProviderElement()</h3><p>解析 databaseIdProvider 标签，生成 DatabaseIdProvider 对象(用来支持不同厂 商的数据库)。</p>
<h3 id="typeHandlerElement"><a href="#typeHandlerElement" class="headerlink" title="typeHandlerElement()"></a>typeHandlerElement()</h3><p>跟 TypeAlias 一样，TypeHandler 有两种配置方式，一种是单独配置一个类，一种 是指定一个 package。最后我们得到的是 JavaType 和 JdbcType，以及用来做相互映射 的 TypeHandler 之间的映射关系。</p>
<p>最后存放在 TypeHandlerRegistry 对象里面。</p>
<p>问题:这种三个对象(Java 类型，JDBC 类型，Handler)的关系怎么映射?(Map 里面再放一个 Map)</p>
<h3 id="mapperElement"><a href="#mapperElement" class="headerlink" title="mapperElement()"></a>mapperElement()</h3><p><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#mappers" target="_blank" rel="noopener">http://www.mybatis.org/mybatis-3/zh/configuration.html#mappers</a></p>
<p><strong>1)判断</strong></p>
<p>最后就是&lt;mappers&gt;标签的解析。</p>
<table>
<thead>
<tr>
<th>扫描类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>resource</td>
<td>相对路径</td>
</tr>
<tr>
<td>url</td>
<td>绝对路径</td>
</tr>
<tr>
<td>package</td>
<td>包</td>
</tr>
<tr>
<td>class</td>
<td>单个接口</td>
</tr>
</tbody></table>
<p>首先会判断是不是接口，只有接口才解析;然后判断是不是已经注册了，单个 Mapper 重复注册会抛出异常。</p>
<p><strong>2)注册</strong></p>
<p>XMLMapperBuilder.parse()方法，是对 Mapper 映射器的解析。里面有两个方法:</p>
<p>configurationElement()—— 解 析 所 有 的 子 标 签 ， 其 中 buildStatementFromContext()最终获得 MappedStatement 对象。</p>
<p>bindMapperForNamespace()——把 namespace(接口类型)和工厂类绑定起来。</p>
<p>无论是按 package 扫描，还是按接口扫描，最后都会调用到 MapperRegistry 的 addMapper()方法。</p>
<p>MapperRegistry 里面维护的其实是一个 Map 容器，存储接口和代理工厂的映射关 系。</p>
<p>问题:为什么要放一个代理工厂呢?代理工厂用来干什么?</p>
<p><strong>3)处理注解</strong></p>
<p>除了映射器文件，在这里也会去解析 Mapper 接口方法上的注解。在 addMapper() 方法里面创建了一个 MapperAnnotationBuilder，我们点进去看一下 parse()方法。</p>
<p>parseCache() 和 parseCacheRef() 方 法 其 实 是 对 @CacheNamespace 和 @CacheNamespaceRef 这两个注解的处理。</p>
<p>parseStatement()方法里面的各种 getAnnotation()，都是对注解的解析，比如 @Options，@SelectKey，@ResultMap 等等。</p>
<p>最后同样会解析成 MappedStatement 对象，也就是说在 XML 中配置，和使用注 解配置，最后起到一样的效果。</p>
<p><strong>4)收尾</strong></p>
<p>如果注册没有完成，还要从 Map 里面 remove 掉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MapperRegistry.java</span></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">    knownMappers.remove(type); </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>最后，MapperRegistry 也会放到 Configuration 里面去。</p>
<p>第二步是调用另一个 build()方法，返回 DefaultSqlSessionFactory。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>在这一步，我们主要完成了 config 配置文件、Mapper 文件、Mapper 接口上的注 解的解析。</p>
<p>我们得到了一个最重要的对象 Configuration，这里面存放了全部的配置信息，它在属性里面还有各种各样的容器。</p>
<p>最后，返回了一个 DefaultSqlSessionFactory，里面持有了 Configuration 的实例。</p>
<h2 id="二、会话创建过程"><a href="#二、会话创建过程" class="headerlink" title="二、会话创建过程"></a>二、会话创建过程</h2><p>这是第二步，我们跟数据库的每一次连接，都需要创建一个会话，我们用 openSession()方法来创建。</p>
<p>DefaultSqlSessionFactory —— openSessionFromDataSource()</p>
<p>这个会话里面，需要包含一个 Executor 用来执行 SQL。Executor 又要指定事务类 型和执行器的类型。</p>
<p>所以我们会先从 Configuration 里面拿到 Enviroment，Enviroment 里面就有事务 工厂。</p>
<h3 id="1、创建-Transaction"><a href="#1、创建-Transaction" class="headerlink" title="1、创建 Transaction"></a>1、创建 Transaction</h3><table>
<thead>
<tr>
<th>属性</th>
<th>产生工厂类</th>
<th>产生事务</th>
</tr>
</thead>
<tbody><tr>
<td>JDBC</td>
<td>JdbcTransactionFactory</td>
<td>JdbcTransaction</td>
</tr>
<tr>
<td>MANAGED</td>
<td>ManagedTransactionFactory</td>
<td>ManagedTransaction</td>
</tr>
</tbody></table>
<p>如果配置的是 JDBC，则会使用 Connection 对象的 commit()、rollback()、close() 管理事务。</p>
<p>如果配置成 MANAGED，会把事务交给容器来管理，比如 JBOSS，Weblogic。因 为我们跑的是本地程序，如果配置成 MANAGE 不会有任何事务。</p>
<p>如果是 Spring + MyBatis，则没有必要配置，因为我们会直接在 applicationContext.xml 里面配置数据源和事务管理器，覆盖 MyBatis 的配置。</p>
<h3 id="2、创建-Executor"><a href="#2、创建-Executor" class="headerlink" title="2、创建 Executor"></a>2、创建 Executor</h3><p>我们知道，Executor 的基本类型有三种:SIMPLE、BATCH、REUSE，默认是 SIMPLE (settingsElement()读取默认值)，他们都继承了抽象类 BaseExecutor。</p>
<p>为什么要让抽象类实现接口，然后让具体实现类继承抽象类?(模板方法模式)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“定义一个算法的骨架，并允许子类为一个或者多个步骤提供实现。 模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。”</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg2ngkhjv1j31fc0ga7fi.jpg" alt="image-20200623234043164"></p>
<p>问题:三种类型的区别(通过 update()方法对比)?</p>
<p>SimpleExecutor:每执行一次 update 或 select，就开启一个 Statement 对象，用 完立刻关闭 Statement 对象。</p>
<p>ReuseExecutor:执行 update 或 select，以 sql 作为 key 查找 Statement 对象， 存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map 内， 供下一次使用。简言之，就是重复使用 Statement 对象。</p>
<p>BatchExecutor:执行 update(没有 select，JDBC 批处理不支持 select)，将所 有 sql 都添加到批处理中(addBatch())，等待统一执行(executeBatch())，它缓存 了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。</p>
<p>如果配置了 cacheEnabled=ture，会用装饰器模式对 executor 进行包装:new CachingExecutor(executor)。</p>
<p>包装完毕后，会执行:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executor = (Executor) interceptorChain.pluginAll(executor);</span><br></pre></td></tr></table></figure>

<p>此处会对 executor 进行包装。</p>
<p>回答了前面的问题:数据源和事务工厂在哪里会用到——创建执行器的时候。</p>
<p>最终返回 DefaultSqlSession，属性包括 Configuration、Executor 对象。</p>
<p>总结:创建会话的过程，我们获得了一个 DefaultSqlSession，里面包含了一个 Executor，它是 SQL 的执行者。</p>
<h2 id="三、获得-Mapper-对象"><a href="#三、获得-Mapper-对象" class="headerlink" title="三、获得 Mapper 对象"></a>三、获得 Mapper 对象</h2><p>现在我们已经有一个 DefaultSqlSession 了，必须找到 Mapper.xml 里面定义的 Statement ID，才能执行对应的 SQL 语句。</p>
<p>找到 Statement ID 有两种方式:一种是直接调用 session 的方法，在参数里面传入 Statement ID，这种方式属于硬编码，我们没办法知道有多少处调用，修改起来也很麻 烦。</p>
<p>另一个问题是如果参数传入错误，在编译阶段也是不会报错的，不利于预先发现问 题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blog blog = (Blog) session.selectOne(<span class="string">"com.gupaoedu.mapper.BlogMapper.selectBlogById "</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>所以在 MyBatis 后期的版本提供了第二种方式，就是定义一个接口，然后再调用 Mapper 接口的方法。</p>
<p>由于我们的接口名称跟 Mapper.xml 的 namespace 是对应的，接口的方法跟 statement ID 也都是对应的，所以根据方法就能找到对应的要执行的 SQL。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BlogMapper mapper = session.getMapper(BlogMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>在这里我们主要研究一下 Mapper 对象是怎么获得的，它的本质是什么。</p>
<p>DefaultSqlSession 的 getMapper()方法，调用了 Configuration 的 getMapper() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configuration.&lt;T&gt;getMapper()</span><br></pre></td></tr></table></figure>

<p>Configuration 的 getMapper()方法，又调用了 MapperRegistry 的 getMapper() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapperRegistry.getMapper()</span><br></pre></td></tr></table></figure>

<p>我们知道，在解析 mapper 标签和 Mapper.xml 的时候已经把接口类型和类型对应的 MapperProxyFactory 放到了一个 Map 中。获取 Mapper 代理对象，实际上是从Map 中获取对应的工厂类后，调用以下方法创建对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MapperProxyFactory.newInstance()</span><br></pre></td></tr></table></figure>

<p>最终通过代理模式返回代理对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br></pre></td></tr></table></figure>

<p>回答了前面的问题:为什么要保存一个工厂类，它是用来创建代理对象的。</p>
<p>JDK 动态代理和 MyBatis 用到的 JDK 动态代理有什么区别?</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg35rjp601j30gq048dgn.jpg" alt="image-20200624101405063"></p>
<p>JDK 动态代理:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg35rv0bd4j30nq0g2go8.jpg" alt="image-20200624101423155"></p>
<p>JDK 动态代理代理，在实现了 InvocationHandler 的代理类里面，需要传入一个被 代理对象的实现类。</p>
<p>MyBatis 的动态代理:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg35spwtenj30ne0f476h.jpg" alt="image-20200624101459654"></p>
<p>不需要实现类的原因:我们只需要根据接口类型+方法的名称，就可以找到 Statement ID 了，而唯一要做的一件事情也是这件，所以不需要实现类。在 MapperProxy 里面直接执行逻辑(也就是执行 SQL)就可以。</p>
<p>总结:</p>
<p>获得 Mapper 对象的过程，实质上是获取了一个 MapperProxy 的代理对象。 MapperProxy 中有 sqlSession、mapperInterface、methodCache。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg35tbjh37j30r004m78r.jpg" alt="image-20200624101547188"></p>
<p>先记下这个问题:在代理类中为什么要持有一个 SqlSession?</p>
<h2 id="四、执行-SQL"><a href="#四、执行-SQL" class="headerlink" title="四、执行 SQL"></a>四、执行 SQL</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blog blog = mapper.selectBlog(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>由于所有的 Mapper 都是 MapperProxy 代理对象，所以任意的方法都是执行 MapperProxy 的 invoke()方法。</p>
<p>问题 1:我们引入 MapperProxy 为了解决什么问题?硬编码和编译时检查问题。它 需要做的事情是:根据方法查找 Statement ID 的问题。</p>
<p>问题 2:这里没有实现类，进入到 invoke 方法的时候做了什么事情?它是怎么找到 我们要执行的 SQL 的?</p>
<p>我们看一下 invoke()方法:</p>
<h3 id="1、MapperProxy-invoke"><a href="#1、MapperProxy-invoke" class="headerlink" title="1、MapperProxy.invoke()"></a>1、MapperProxy.invoke()</h3><p>1)首先判断是否需要去执行 SQL，还是直接执行方法。<br> Object 本身的方法和 Java 8 中接口的默认方法不需要去执行 SQL。 思考:isDefaultMethod 判断的是什么?写一个什么方法，它会走到这里? 这个是 Java 8 接口中默认方法的示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IService</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"GP"</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2)获取缓存<br> 这里加入缓存是为了提升 MapperMethod 的获取速度:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取缓存，保存了方法签名和接口方法的关系</span></span><br><span class="line"><span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br></pre></td></tr></table></figure>

<p>Map 的 computeIfAbsent()方法:只有 key 不存在或者 value 为 null 的时候才调用 mappingFunction()。</p>
<h3 id="2、MapperMethod-execute"><a href="#2、MapperMethod-execute" class="headerlink" title="2、MapperMethod.execute()"></a>2、MapperMethod.execute()</h3><p>接下来又调用了 mapperMethod 的 execute 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapperMethod.execute(sqlSession, args);</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg367vzctdj30jk0cyn5z.jpg" alt="image-20200624102947618"></p>
<p>apperMethod 里面主要有两个属性，一个是 SqlCommand，一个是 MethodSignature，这两个都是 MapperMethod 的内部类。</p>
<p>另外定义了多个 execute()方法。</p>
<p>在这一步，根据不同的 type 和返回类型:<br>调用 convertArgsToSqlCommandParam()将参数转换为 SQL 的参数。<br>调用 sqlSession 的 insert()、update()、delete()、selectOne ()方法，我们以查询</p>
<p>为例，会走到 selectOne()方法。</p>
<h3 id="3、DefaultSqlSession-selectOne"><a href="#3、DefaultSqlSession-selectOne" class="headerlink" title="3、DefaultSqlSession.selectOne()"></a>3、DefaultSqlSession.selectOne()</h3><p>selectOne()最终也是调用了 selectList()。</p>
<p>在 SelectList()中，我们先根据 command name(Statement ID)从 Configuration 中拿到 MappedStatement，这个 ms 上面有我们在 xml 中配置的所有属性，包括 id、 statementType、sqlSource、useCache、入参、出参等等。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg369bsc1fj30hk0foqbg.jpg" alt="image-20200624103110454"></p>
<p>然后执行了 Executor 的 query()方法。<br>前面我们说到了 Executor 有三种基本类型，同学们还记得是哪几种么? SIMPLE/REUSE/BATCH，还有一种包装类型，CachingExecutor。 那么在这里到底会选择哪一种执行器呢?<br>我们要回过头去看看 DefaultSqlSession 在初始化的时候是怎么赋值的，这个就是我们的会话创建过程。</p>
<p>如果启用了二级缓存，就会先调用 CachingExecutor 的 query()方法，里面有缓存相关的操作，然后才是再调用基本类型的执行器，比如默认的 SimpleExecutor。</p>
<p>在没有开启二级缓存的情况下，先会走到 BaseExecutor 的 query()方法(否则会先 走到 CachingExecutor)。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg36abstc8j30rq08878a.jpg" alt="image-20200624103208406"></p>
<h3 id="4、BaseExecutor-query"><a href="#4、BaseExecutor-query" class="headerlink" title="4、BaseExecutor.query()"></a>4、BaseExecutor.query()</h3><h4 id="1-创建-CacheKey"><a href="#1-创建-CacheKey" class="headerlink" title="1)创建 CacheKey"></a>1)创建 CacheKey</h4><p>从 Configuration 中获取 MappedStatement， 然后从 BoundSql 中获取 SQL 信 息，创建 CacheKey。这个 CacheKey 就是缓存的 Key。</p>
<p>然后再调用另一个 query()方法。</p>
<h4 id="2-清空本地缓存"><a href="#2-清空本地缓存" class="headerlink" title="2)清空本地缓存"></a>2)清空本地缓存</h4><p>queryStack 用于记录查询栈，防止递归查询重复处理缓存。flushCache=true 的时候，会先清理本地缓存(一级缓存):clearLocalCache();</p>
<p>如果没有缓存，会从数据库查询:queryFromDatabase() 如果 LocalCacheScope == STATEMENT，会清理本地缓存。</p>
<h4 id="3-从数据库查询"><a href="#3-从数据库查询" class="headerlink" title="3)从数据库查询"></a>3)从数据库查询</h4><p>a)缓存 先在缓存用占位符占位。执行查询后，移除占位符，放入数据。</p>
<p>b)查询执行 Executor 的 doQuery();默认是 SimpleExecutor。</p>
<h3 id="5、SimpleExecutor-doQuery"><a href="#5、SimpleExecutor-doQuery" class="headerlink" title="5、SimpleExecutor.doQuery()"></a>5、SimpleExecutor.doQuery()</h3><h4 id="1-创建-StatementHandler"><a href="#1-创建-StatementHandler" class="headerlink" title="1)创建 StatementHandler"></a>1)创建 StatementHandler</h4><p>在 configuration.newStatementHandler()中，new 一个 StatementHandler，先 得到 RoutingStatementHandler。</p>
<p>RoutingStatementHandler 里面没有任何的实现，是用来创建基本的 StatementHandler 的。这里会根据 MappedStatement 里面的 statementType 决定 StatementHandler 的 类 型 。 默 认 是 PREPARED ( STATEMENT 、 PREPARED 、 CALLABLE)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (ms.getStatementType()) &#123; </span><br><span class="line">  <span class="keyword">case</span> STATEMENT:</span><br><span class="line">    delegate = <span class="keyword">new</span> SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> PREPARED:</span><br><span class="line">    delegate = <span class="keyword">new</span> PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> CALLABLE:</span><br><span class="line">    delegate = <span class="keyword">new</span> CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Unknown statement type: "</span> + ms.getStatementType()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StatementHandler 里面包含了处理参数的 ParameterHandler 和处理结果集的 ResultSetHandler。</p>
<p>这两个对象都是在上面 new 的时候创建的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line"><span class="keyword">this</span>.resultSetHandler = configuration.newResultSetHandler(executor, mappedStatement, rowBounds,parameterHandler, resultHandler, boundSql);</span><br></pre></td></tr></table></figure>

<p>这三个对象都是可以被插件拦截的四大对象之一，所以在创建之后都要用拦截器进 行包装的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br></pre></td></tr></table></figure>

<p>PS:四大对象还有一个是谁?在什么时候创建的?(Executor)</p>
<h4 id="2-创建-Statement"><a href="#2-创建-Statement" class="headerlink" title="2)创建 Statement"></a>2)创建 Statement</h4><p>用 new 出来的 StatementHandler 创建 Statement 对象——prepareStatement() 方法对语句进行预编译，处理参数。</p>
<p>handler.parameterize(stmt) ;</p>
<h4 id="3-执行的-StatementHandler-的-query-方法"><a href="#3-执行的-StatementHandler-的-query-方法" class="headerlink" title="3)执行的 StatementHandler 的 query()方法"></a>3)执行的 StatementHandler 的 query()方法</h4><p>RoutingStatementHandler 的 query()方法。<br>delegate 委派，最终执行 PreparedStatementHandler 的 query()方法。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg36f8f6e5j30ei02y75v.jpg" alt="image-20200624103651041"></p>
<h4 id="4-执行-PreparedStatement-的-execute-方法"><a href="#4-执行-PreparedStatement-的-execute-方法" class="headerlink" title="4)执行 PreparedStatement 的 execute()方法"></a>4)执行 PreparedStatement 的 execute()方法</h4><p>后面就是 JDBC 包中的 PreparedStatement 的执行了。</p>
<h4 id="5-ResultSetHandler-处理结果集"><a href="#5-ResultSetHandler-处理结果集" class="headerlink" title="5)ResultSetHandler 处理结果集"></a>5)ResultSetHandler 处理结果集</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> resultSetHandler.handleResultSets(ps);</span><br></pre></td></tr></table></figure>

<p>问题:怎么把 ResultSet 转换成 List<Object>?</p>
<p>ResultSetHandler 只有一个实现类:DefaultResultSetHandler。也就是执行 DefaultResultSetHandler 的 handleResultSets ()方法。</p>
<p>首先我们会先拿到第一个结果集，如果没有配置一个查询返回多个结果集的情况， 一般只有一个结果集。如果下面的这个 while 循环我们也不用，就是执行一次。</p>
<p>然后会调用 handleResultSet()方法。</p>
<p>【作业】总结一下，MyBatis 里面用到了哪些设计模式?</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/mybatis%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" rel="tag"># mybatis源码解读</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/23/mybatis%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" rel="prev" title="mybatis体系结构与工作原理">
      <i class="fa fa-chevron-left"></i> mybatis体系结构与工作原理
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#MyBatis源码解读"><span class="nav-number">1.</span> <span class="nav-text">MyBatis源码解读</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#带着问题去看源码"><span class="nav-number">1.1.</span> <span class="nav-text">带着问题去看源码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一、配置解析过程"><span class="nav-number">1.2.</span> <span class="nav-text">一、配置解析过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#XMLConfigBuilder"><span class="nav-number">1.2.1.</span> <span class="nav-text">XMLConfigBuilder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#propertiesElement"><span class="nav-number">1.2.2.</span> <span class="nav-text">propertiesElement()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#settingsAsProperties"><span class="nav-number">1.2.3.</span> <span class="nav-text">settingsAsProperties()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#loadCustomVfs-settings"><span class="nav-number">1.2.4.</span> <span class="nav-text">loadCustomVfs(settings)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#loadCustomLogImpl-settings"><span class="nav-number">1.2.5.</span> <span class="nav-text">loadCustomLogImpl(settings)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#typeAliasesElement"><span class="nav-number">1.2.6.</span> <span class="nav-text">typeAliasesElement()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pluginElement"><span class="nav-number">1.2.7.</span> <span class="nav-text">pluginElement()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#objectFactoryElement-、objectWrapperFactoryElement"><span class="nav-number">1.2.8.</span> <span class="nav-text">objectFactoryElement()、objectWrapperFactoryElement()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reflectorFactoryElement"><span class="nav-number">1.2.9.</span> <span class="nav-text">reflectorFactoryElement()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#settingsElement-settings"><span class="nav-number">1.2.10.</span> <span class="nav-text">settingsElement(settings)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#environmentsElement"><span class="nav-number">1.2.11.</span> <span class="nav-text">environmentsElement()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#databaseIdProviderElement"><span class="nav-number">1.2.12.</span> <span class="nav-text">databaseIdProviderElement()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#typeHandlerElement"><span class="nav-number">1.2.13.</span> <span class="nav-text">typeHandlerElement()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mapperElement"><span class="nav-number">1.2.14.</span> <span class="nav-text">mapperElement()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">1.2.15.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、会话创建过程"><span class="nav-number">1.3.</span> <span class="nav-text">二、会话创建过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、创建-Transaction"><span class="nav-number">1.3.1.</span> <span class="nav-text">1、创建 Transaction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、创建-Executor"><span class="nav-number">1.3.2.</span> <span class="nav-text">2、创建 Executor</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、获得-Mapper-对象"><span class="nav-number">1.4.</span> <span class="nav-text">三、获得 Mapper 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、执行-SQL"><span class="nav-number">1.5.</span> <span class="nav-text">四、执行 SQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、MapperProxy-invoke"><span class="nav-number">1.5.1.</span> <span class="nav-text">1、MapperProxy.invoke()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、MapperMethod-execute"><span class="nav-number">1.5.2.</span> <span class="nav-text">2、MapperMethod.execute()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、DefaultSqlSession-selectOne"><span class="nav-number">1.5.3.</span> <span class="nav-text">3、DefaultSqlSession.selectOne()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、BaseExecutor-query"><span class="nav-number">1.5.4.</span> <span class="nav-text">4、BaseExecutor.query()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-创建-CacheKey"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">1)创建 CacheKey</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-清空本地缓存"><span class="nav-number">1.5.4.2.</span> <span class="nav-text">2)清空本地缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-从数据库查询"><span class="nav-number">1.5.4.3.</span> <span class="nav-text">3)从数据库查询</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、SimpleExecutor-doQuery"><span class="nav-number">1.5.5.</span> <span class="nav-text">5、SimpleExecutor.doQuery()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-创建-StatementHandler"><span class="nav-number">1.5.5.1.</span> <span class="nav-text">1)创建 StatementHandler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-创建-Statement"><span class="nav-number">1.5.5.2.</span> <span class="nav-text">2)创建 Statement</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-执行的-StatementHandler-的-query-方法"><span class="nav-number">1.5.5.3.</span> <span class="nav-text">3)执行的 StatementHandler 的 query()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-执行-PreparedStatement-的-execute-方法"><span class="nav-number">1.5.5.4.</span> <span class="nav-text">4)执行 PreparedStatement 的 execute()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-ResultSetHandler-处理结果集"><span class="nav-number">1.5.5.5.</span> <span class="nav-text">5)ResultSetHandler 处理结果集</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">shoufeng</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shoufeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
